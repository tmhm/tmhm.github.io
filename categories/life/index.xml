<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Life on Well</title>
    <link>https://tmhm.github.io/categories/life/index.xml</link>
    <description>Recent content in Life on Well</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>wells217@163.com (Well)</managingEditor>
    <webMaster>wells217@163.com (Well)</webMaster>
    <copyright>(c) 2017 Well.</copyright>
    <atom:link href="https://tmhm.github.io/categories/life/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>win10禁用自动更新服务</title>
      <link>https://tmhm.github.io/2017/02/13/win10%E7%A6%81%E7%94%A8%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Mon, 13 Feb 2017 00:48:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2017/02/13/win10%E7%A6%81%E7%94%A8%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E6%9C%8D%E5%8A%A1/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;按Win+R，打开运行，输入“services.msc&amp;raquo;打开服务；&lt;/li&gt;
&lt;li&gt;找到“Windows Update”，选择属性，修改为禁用即可；&lt;/li&gt;
&lt;li&gt;开启，反之亦然.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>读《微软的梦工厂》</title>
      <link>https://tmhm.github.io/2016/11/30/%E8%AF%BB%E5%BE%AE%E8%BD%AF%E7%9A%84%E6%A2%A6%E5%B7%A5%E5%8E%82/</link>
      <pubDate>Wed, 30 Nov 2016 07:25:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/11/30/%E8%AF%BB%E5%BE%AE%E8%BD%AF%E7%9A%84%E6%A2%A6%E5%B7%A5%E5%8E%82/</guid>
      <description>&lt;p&gt;前段时间看了扎克伯格和李叔同的传记，最近在看《&lt;span style=&#34;font-family: 隶书;&#34;&gt;微软的梦工厂&lt;/span&gt;》。
&lt;p&gt;看的过程总是会让我想起一些人，想起一些事情。。。&lt;/p&gt;
&lt;p&gt;文字在我的嘴里总是略带苦涩：&lt;/p&gt;
&lt;p&gt;也许这就是环境的影响，MSRA从一开始，就塑造了一个优秀的环境。&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;同时也让我看到自己的渺小，其实曾经我总是会把自己看成&amp;ldquo;全能&amp;rdquo;的，一直活在自己的小世界里，突然不断地让我接触了越来越大的世界，这也是我总是爱多想的次因。&lt;/p&gt;

&lt;p&gt;还有原因是，不愿接受过去的自己，不愿接受依次放大的阶梯，其实我也是在不断成长中，知足，&lt;/p&gt;
&lt;p&gt;沉淀，时间需要沉淀，成长更需要沉淀。&lt;/p&gt;
&lt;p&gt;我总是希望急于求成，希望一下就能学会所有，做到所有，&lt;/p&gt;
&lt;p&gt;做人得符合实际，不急不躁，踏实。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>shadowsocks 在win10下无法使用的问题</title>
      <link>https://tmhm.github.io/2016/11/25/shadowsocks-%E5%9C%A8win10%E4%B8%8B%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 25 Nov 2016 04:38:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/11/25/shadowsocks-%E5%9C%A8win10%E4%B8%8B%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;问题描述：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;按照&lt;a href=&#34;http://my.yizhihongxing.com/knowledgebase.php?action=displayarticle&amp;amp;id=3&#34;&gt;帮助中心&lt;/a&gt;的配置设置好之后.&lt;/li&gt;
&lt;li&gt;启用代理,显示了start，但是就是不能上google，卸载了迅雷也是没用。&lt;/li&gt;
&lt;li&gt;在mac下能正常使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;解决问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;问题在于本地的端口有问题，将默认的1080端口修改为1081，&lt;/li&gt;
&lt;li&gt;即可以打开google，youtobe&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有时是3.3.5不能用，换会用低版本2.5.8的即可以&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>语录收集</title>
      <link>https://tmhm.github.io/2016/11/18/%E8%AF%AD%E5%BD%95%E6%94%B6%E9%9B%86/</link>
      <pubDate>Fri, 18 Nov 2016 08:43:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/11/18/%E8%AF%AD%E5%BD%95%E6%94%B6%E9%9B%86/</guid>
      <description>&lt;p&gt;马化腾，第三次互联网大会
&amp;gt; 创新一定是所有公司都重视的，一定要有突破。腾讯过去再有优势，但在新趋势面前也有压力，微信之后，我们也在思考，未来三年还能做什么？回头看，创新不是搞一个部门，名字叫创新。而是把为用户服务的意识灌输到每一个产品和设计上，不要让员工掉入KPI陷阱。在快速服务用户过程中，用户抱怨，那就是你创新的机会。&lt;/p&gt;

&lt;p&gt;真格基金 王强老师推荐的三本书&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pic.36krcnd.com/201611/17092410/2y1m00k6ocjkz47h!1200&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;沃尔玛的创始人Sam Walton的自传《Made in America》&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pic.36krcnd.com/201611/17093654/8314vcwe06vx4kco!1200&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If Aristotle Ran General Motors《如果亚里士多德来管理通用汽车》&lt;/p&gt;

&lt;p&gt;真，善，美&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pic.36krcnd.com/201611/17094055/wylsehjibfs4wqjt!1200&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;PourYour Heart Into It: How Starbucks Built a Company One Cup at aTime 《将心注入-星巴克传奇》&lt;/p&gt;

&lt;p&gt;星巴克创始人霍华德·舒尔茨（Howard Schultz）的自传。&lt;/p&gt;

&lt;p&gt;Pour your heart into a cup of coffee。“把心倾注进一杯小小的咖啡里”。成功之树的全部秘诀正是在这颗初心的种子里。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>一些书单</title>
      <link>https://tmhm.github.io/2016/10/10/%E4%B8%80%E4%BA%9B%E4%B9%A6%E5%8D%95/</link>
      <pubDate>Mon, 10 Oct 2016 08:40:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/10/10/%E4%B8%80%E4%BA%9B%E4%B9%A6%E5%8D%95/</guid>
      <description>&lt;p&gt;&lt;em&gt;仅对近来的学习做些回顾吧&lt;/em&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;学习永无止境&amp;ndash;&amp;gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2015年已完成书单：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文学：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;硅谷之火&lt;/li&gt;
&lt;li&gt;浪潮之巅&lt;/li&gt;
&lt;li&gt;天才在左疯子在右&lt;/li&gt;
&lt;li&gt;从0到1&lt;/li&gt;
&lt;li&gt;生命咖啡馆&lt;/li&gt;
&lt;li&gt;黑客与画家&lt;/li&gt;
&lt;li&gt;奇思妙想：15位计算机天才及其重大发现&lt;/li&gt;
&lt;li&gt;乔布斯传&lt;/li&gt;
&lt;li&gt;平凡的世界（三部全）&lt;/li&gt;
&lt;li&gt;一只iphone的全球旅行&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;nbsp;专业类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;C++ Primer（中文第五版）匆忙过了一遍，未实现代码。&lt;/li&gt;
&lt;li&gt;ios 游戏开发：创意与实现&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;2016年书单：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文学：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;历史的教训&lt;/li&gt;
&lt;li&gt;硅谷之谜&lt;/li&gt;
&lt;li&gt;文明之光&lt;/li&gt;
&lt;li&gt;facebook 马克 扎克伯格传记：后乔布斯时代的传奇&lt;/li&gt;
&lt;li&gt;弘一大师新传&lt;/li&gt;
&lt;li&gt;三体（未完成，过半后，吸引力下降）&lt;/li&gt;
&lt;li&gt;微软的梦工厂（一口气读完了）&lt;/li&gt;
&lt;li&gt;数学之美（第二版）&lt;/li&gt;
&lt;li&gt;富爸爸穷爸爸&lt;/li&gt;
&lt;li&gt;人类简史&lt;/li&gt;
&lt;li&gt;智能时代（吴军著）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;专业类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;C++语言的设计与演化&lt;/li&gt;
&lt;li&gt;数据结构与算法分析（C语言描述） &amp;nbsp; &amp;nbsp;缺代码实现&lt;/li&gt;
&lt;li&gt;统计学习方法. 李航&lt;/li&gt;
&lt;li&gt;控制系统设计指南（第三版）&lt;/li&gt;
&lt;li&gt;嵌入式Linux系统使用开发（主要包括完成linux系统，c/c++的回顾，多线程等）&lt;/li&gt;
&lt;li&gt;机器学习实践（-ing）&lt;/li&gt;
&lt;li&gt;机器学习.周志华（-ing）&lt;/li&gt;
&lt;li&gt;算法（第四版）. Robert Sedgewick（-ing，看进去以后，相见恨晚）&lt;/li&gt;
&lt;li&gt;Reinforcement learning: An&amp;nbsp;induction.&amp;nbsp;Richard S. Sutton（-ing）&lt;/li&gt;
&lt;li&gt;无人驾驶车辆模型预测控制.北京理工大学出版社（-ing）（发现战线好长，得收敛到某个方向）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;16年的专业书籍还有很多在继续。。&lt;/p&gt;

&lt;p&gt;&lt;p&gt;&lt;strong&gt;&amp;nbsp;2017年书单：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Google 未来之镜&lt;/li&gt;
&lt;li&gt;创新者的窘境 （-ing）&lt;/li&gt;
&lt;li&gt;围城（-ing）&lt;/li&gt;
&lt;/ol&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>vim初探</title>
      <link>https://tmhm.github.io/2016/05/21/vim%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Sat, 21 May 2016 01:49:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/05/21/vim%E5%88%9D%E6%8E%A2/</guid>
      <description>&lt;p&gt;https://github.com/spf13/spf13-vim&lt;/p&gt;
&lt;p&gt;安装了此博主的开源项目。&lt;/p&gt;
&lt;p&gt;：vsp &amp;nbsp; &amp;mdash;&amp;mdash;竖分屏&lt;/p&gt;
&lt;p&gt;：sp &amp;nbsp;　&amp;mdash;&amp;mdash;横分屏&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>spss v21.0 使用笔记</title>
      <link>https://tmhm.github.io/2016/05/14/spss-v21.0-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 14 May 2016 14:50:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/05/14/spss-v21.0-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</guid>
      <description>

&lt;p&gt;有问题，戳&lt;a href=&#34;http://www.ibm.com/support/knowledgecenter/SSLVMB_23.0.0/spss/base/chart_creation_dualy.dita?lang=zh&#34;&gt;官方帮助文档&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;神经网络&#34;&gt;神经网络&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;分析-神经网络-多层感知机&lt;/em&gt;&lt;/p&gt;

&lt;h5 id=&#34;变量&#34;&gt;变量。&lt;/h5&gt;

&lt;p&gt;&lt;em&gt;分析-神经网络-多层感知机-变量&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;预测变量可指定为因子（分类）或协变量（刻度）。&lt;/li&gt;
&lt;li&gt;在因变量框输入&lt;strong&gt;预测Y&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;因子框 必须是&lt;strong&gt;分类的数据&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;协变量允许各种类型的数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;频率分析&#34;&gt;频率分析&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;分析-描述统计-频率&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在统计量里面可以添加选择中位数、众数等&lt;/li&gt;
&lt;li&gt;在图表选项可以添加直方图等&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;画图&#34;&gt;画图&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;图形-旧对话框-&amp;gt;&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;画双y轴图&#34;&gt;画双y轴图&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;图形-图表构建程序- 在选择范围框里面选：双轴&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>求解路由路径问题（华为挑战赛小思）</title>
      <link>https://tmhm.github.io/2016/04/11/%E6%B1%82%E8%A7%A3%E8%B7%AF%E7%94%B1%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E5%8D%8E%E4%B8%BA%E6%8C%91%E6%88%98%E8%B5%9B%E5%B0%8F%E6%80%9D/</link>
      <pubDate>Mon, 11 Apr 2016 13:47:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/04/11/%E6%B1%82%E8%A7%A3%E8%B7%AF%E7%94%B1%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E5%8D%8E%E4%B8%BA%E6%8C%91%E6%88%98%E8%B5%9B%E5%B0%8F%E6%80%9D/</guid>
      <description>&lt;nav&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#问题定义&#34;&gt;问题定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#说明&#34;&gt;说明：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#最终得分机制&#34;&gt;最终得分机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#思&#34;&gt;思：&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#初衷&#34;&gt;初衷：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#于是-开始慢慢地折腾和实现了&#34;&gt;于是，开始慢慢地折腾和实现了 :-)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#算法描述&#34;&gt;算法描述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#缺陷-反思&#34;&gt;缺陷-反思&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/nav&gt;

&lt;p&gt;赛题源自“未来网络”业务发放中的路由计算问题。&lt;/p&gt;

&lt;h6 id=&#34;问题定义&#34;&gt;问题定义&lt;/h6&gt;

&lt;p&gt;给定一个带权重的有向图G=(V,E)，V为顶点集，E为有向边集，每一条有向边均有一个权重。对于给定的顶点s、t，以及V的子集V&amp;rsquo;，寻找从s到t的不成环有向路径P，使得P经过V&amp;rsquo;中所有的顶点(对经过V&amp;rsquo;中节点的顺序不做要求)。
若不存在这样的有向路径P，则输出无解，程序运行时间越短，则视为结果越优；若存在这样的有向路径P，则输出所得到的路径，路径的权重越小，则视为结果越优，在输出路径权重一样的前提下，程序运行时间越短，则视为结果越优。&lt;/p&gt;

&lt;h6 id=&#34;说明&#34;&gt;说明：&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;1）图中所有权重均为[1，20]内的整数；&lt;/li&gt;
&lt;li&gt;2）任一有向边的起点不等于终点；&lt;/li&gt;
&lt;li&gt;3）连接顶点A至顶点B的有向边可能超过一条，其权重可能一样，也可能不一样；&lt;/li&gt;
&lt;li&gt;4）该有向图的顶点不会超过600个，每个顶点出度(以该点为起点的有向边的数量)不超过8；&lt;/li&gt;
&lt;li&gt;5）V&amp;rsquo;中元素个数不超过50；&lt;/li&gt;
&lt;li&gt;6）从s到t的不成环有向路径P是指，P为由一系列有向边组成的从s至t的有向连通路径，且不允许重复经过任一节点；&lt;/li&gt;

&lt;li&gt;&lt;p&gt;7）路径的权重是指所有组成该路径的所有有向边的权重之和。&lt;/p&gt;

&lt;h6 id=&#34;最终得分机制&#34;&gt;最终得分机制&lt;/h6&gt;

&lt;p&gt;华为后台会使用N个测试用例判题，该N个测试用例分为初级、中级、高级三个等级，参赛者对于每个测试用例都会得到一个百分制分数，使用加权平均分(初级权重为0.2，中级权重为0.3，高级权重为0.5)作为该参赛者的最终得分。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;输入输出采用文件的形式。&lt;/p&gt;

&lt;h5 id=&#34;思&#34;&gt;思：&lt;/h5&gt;

&lt;p&gt;对于上述，这么一个问题，
最初的想法是根据dijkstra最短路径算法中贪心的思想，结合剪枝进行求解，但是对于复杂图节点的情况，主要是在于当必经节点变多，这个规则感觉就太多，没法继续下去。&lt;/p&gt;

&lt;p&gt;然后，接触到蚁群算法。
我从旅行商问题（TSP）开始学习这个算法，但是对于我们这个要求经过给定必经点的问题，跟TSP还是有比较大的差距。
TSP问题得以求解的核心思想在于：
&lt;em&gt;每只蚂蚁经过所有的节点，蚂蚁行走相对于cpu总的频率是一样的，当路径越短，其蚂蚁行走的次数就会增大&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;然后，突然有了一个这样类蚂蚁的想法，接下来就是围绕这个想法在实现了。
此处，仅仅是自己的一个思路的回顾，可能会存在一些问题。仅供讨论。&lt;/p&gt;

&lt;h6 id=&#34;初衷&#34;&gt;初衷：&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;将所有蚂蚁丢在 起点和必经点上，然后再让他们自己去走，走到另一必经点，其信息素增大， 如果走到终点，信息素更大，直到某只蚂蚁找到终点。每次信息素更新时，信息素更新量的大小跟该蚂蚁走过的node数量和是否经过必经点有关。 这样来，理想情况下，每次更新时，经过必经点的路径信息素应该是比较大的，每次更新信息素后，进行一次从起点开始贪心搜，每次走信息素最大的，看是否可以走到终点，如果走到终点，本次路径即是一个解。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;因为，我们蚂蚁在每个节点，可供选择的节点是很少的， 最多才8个，而tsp问题是可以去任意个节点的 ，这样更新一遍信息素，就可以去类贪心一次，看是否可以找到解。&lt;/strong&gt;&lt;/p&gt;

&lt;h6 id=&#34;于是-开始慢慢地折腾和实现了&#34;&gt;于是，开始慢慢地折腾和实现了 :-)&lt;/h6&gt;

&lt;p&gt;####### 类邻接表的图表结构&lt;/p&gt;

&lt;p&gt;头结点表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    struct AlGraph{
EdgeNode *adjacencyNode[8];  //
AlGraph *algacency_alGraph[8];  //point to the adjacencyNode struct !!!
short int edgecnt;   // the num of node link to this head node
short int vertexNum;
long distToSource;    // distance from start to this node  ,default = 0;
                        // due to the pre cost among [1:20]
bool known;         // degault = false,  become to true when parse it.
short int path;    //default = -1  // due to the pre node value among [0:600], yes , are node
/*这样的缺点是,不能同时找多条路径,一个点只能记录一个它的path,一个node有多个入度的时候,就会出问题了!
    此path成员只在dijkstra里面用，到后面类蚁群算法并没有用，它通过每只蚂蚁走过的路径来体现*/
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;边节点，它也可能是一个头结点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    struct EdgeNode   //边表节点
    {
       short int adjvex;  //bian jiedian hao
       short int cost;   //cost
       short int linkID;  //the edge id :  point to this node

       /** ant  */
       float pheromone; //
       //short int pheromone_delta;  //改写到蚂蚁身上
       long long nth_antPathVisited;  //nth bits;   all 64  ,实际上只是用来确定该蚂蚁走过这条边, 这样可以尝试走通往该节点的多条边.
       /**
       * 1111 ... ... 1111
       *64,63,... , 3,2,1 nth ant
       **/
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;必经节点结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    struct demandIncNode{
        short int demandID;
        bool gotStatus;
    };
    struct demandNode{
        short int source_id;
        short int destination_id;
        bool reachEndFlag;
        short int includingCnt;
        demandIncNode *includingNode[50];
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;蚂蚁结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    struct sAnt{
        long int ant_pheromone_Q;   // the gross about pheromone of each ant need to different!
        float pheromone_delta ;

        long l_pathMoved_length ;         //the all length of this ant moved from &amp;lt;their&amp;gt; source!!
        short int CommonNode_movedCount ;         //the number of node had moved
        short int DemandNode_movedCount;    //the number of demand node had moved
        short int cakeOnFront ;

        //float prob[8];    // to my own choose
        float  prob[8];              //the temp for calculate probability to choose
        short int curCandidacyNodeNum; //the number of node can be select to move
        short int passedNodeId;//
        short int curNodeId;  //the node now
        short int nextNodeId; // select node
        short int antStartId;

        bool antDie_status;  // this ant may little value
        bool gotDestination;    //pass some demandNode and got destination.
        bool gotDestFromMidway;
        short int timeCnt;  //let this ant stop ,or they run how much

    };

    struct sAntResult{
        short int toNode;
        short int linkId;
       // sAntResult *next;
       // sAntResult *pre;
        //sAntResult(short int n, short int id) : toNode(n) ,linkId(id) {}
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了方便查找索引，建立了一个头结点索引数组，来存储已经读入头结点的值，来防止访问第一个图表，出现野指针的情况。当需要查找某个头结点的相关信息时，先在头结点数组确认存在后， 再去图*graph[600]里面直接按头结点id值等于图索引号获取。&lt;/p&gt;

&lt;h6 id=&#34;算法描述&#34;&gt;算法描述&lt;/h6&gt;

&lt;ol&gt;
&lt;li&gt;将图文件中的节点读进来，按照上面的图表格式存储，然后将有出度的头结点用指针联系起来，方便后面的访问。&lt;/li&gt;
&lt;li&gt;根据demand节点的个数，初始化蚂蚁的个数，并置位ant相关数据。选择每一只蚂蚁第一次的初始位置（起点+所有必经点+随机的非终点）。&lt;/li&gt;
&lt;li&gt;开始进入ant_run的主程序
    1. 将记录蚂蚁经过的路径信息复位；
    2. 让每个蚂蚁run，直到终点，或者没法继续；
            1. 根据当前节点和上一步访问的节点情况，计算本节点出度节点各自的概率，用轮盘选择下一个出度节点（避免一些可推倒的不行解）
            2. 每步记录蚂蚁获得的一些报酬（跟必经点，普通节点，终点，前方有蛋糕的概率等有关），当该蚂蚁停下来时，计算其身上有的信息总量
            3. 待所有蚂蚁都跑完一代，更新他们的信息素到各自走过的路经上
    3. check每只蚂蚁的信息素，并计算各自的增量，叠加到路径的信息素上去；
    4. check本次迭代是否找到解：
            1. 找到一个解（暂时只考虑了一代中多种可行解的优化，和初步环避免）存到一个队列中，返回
            2. 没有找到完整的解，记录返回调试用。目前的路径上的信息素可能有问题，将当次不完整解走过的路径上的信息素，用台风吹吹:-)
    5. 清掉本次迭代图上和ant的各种状态标识等
    6. 直到迭代次数，结束&lt;/li&gt;
&lt;li&gt;善后工作，写结果文件，以及调试打印输出等&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;上述为程序的主要框架，均按照自己某时想法，一步步累积起来的，更多细节部分细节处理&lt;/strong&gt;
相比蚁群算法的核心收敛机制在于cpu的频率，上述方法应该收敛的条件是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;经过更多的必经点，蚂蚁报酬更多，从起点达到终点，经过所有必经点，报酬甚之(理想解);&lt;/li&gt;
&lt;li&gt;可能上一点不完备，有某些问题；&lt;/li&gt;
&lt;li&gt;结合了强化学习正反馈的报酬机制。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;缺陷-反思&#34;&gt;缺陷-反思&lt;/h6&gt;

&lt;p&gt;缺少完备的理论证明。 并没有证明求解空间在这些规则下，是完备的，并且会收敛到最优(目前来看，收敛性不太好)。
因此，实践起来，发现并不如我心意。
需要在一些规则的限制下才能得到较简单问题的解，目前只能得到case0和case1的解，偶尔会出现次优解。因为，我只在一个地方优化了解&lt;em&gt;一次迭代中，当出现多个解得时候，即有多只蚂蚁同时获得解，才会去优化次优的信息素&lt;/em&gt;
所以当代与代之间有时不收敛的时候就只能通过其他的规则才能得到解，我一直在想，这个问题，估计我还有某些方面没考虑到，是不完备的解，所以导致不收敛。理论基础好生重要！&lt;/p&gt;

&lt;p&gt;软件系统规划仍比较薄弱。 没有学过程序设计模式和架构，都是按照自己的一些想法实现的，当遇到问题的时候，再在这上面添加补充和完善。一开始没有很好的布局式设计，如果一开始能把所有的想明白了，做好整体框架，程序的结构性就会好一些。耦合程度也会低一些。当然在实现的过程中，我也尽量使相关性程度比较高的在一起，为了以后更好地维护。&lt;/p&gt;

&lt;p&gt;整个工程的总共时间不长，应该算是我认真做过的项目中最短的了，两个隔离的周末（4天）加基本一周（6天），总共十天（满满的），包括了所有的构思和编码。总共编码在1700行左右，后期并未优化，想想，曾经一个五子棋也写了5000行，当时写dos下的界面花了不少行，当时的AI做的还挺好的，放在班群上也能得到很好的胜率。（当时也实现了自己的一个小想法，不但考虑自己胜算大小，还考虑了对方的，还有梯度的思想，哈哈~）&lt;/p&gt;

&lt;p&gt;此处仅当做学习的一个总结，全是自己一行一行码的代码，勿拍砖，不足之处敬请指正与讨论。：-)&lt;/p&gt;

&lt;p&gt;其实当每一次认真地做一个project，只要能单纯实现自己的一些想法，也是一件很美妙的事情，目前来看，至少也有6个这样的项目了吧
- 第一块电路板和自制电源
- 独角兽&amp;lt;一代,历时半年多，收货也大大&amp;gt;
- 倒立摆&amp;lt;惊喜之作&amp;gt;
- 四轴&amp;lt;历时也整整半年多，但不太尽人意&amp;gt;
- 五子棋&amp;lt;琢磨&amp;gt;
- 此次也算吧&lt;/p&gt;

&lt;p&gt;&amp;lt;感受码代码过程中的&amp;mdash;-那份喜悦与微妙&amp;gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;独角兽，幸运；更需要实力
2016.4.11晚&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>shell学习</title>
      <link>https://tmhm.github.io/2016/03/10/shell%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Thu, 10 Mar 2016 08:36:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/03/10/shell%E5%AD%A6%E4%B9%A0/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;readlink是linux系统中一个常用工具，主要用来找出符号链接所指向的位置。&lt;/li&gt;
&lt;li&gt;定义变量“=”两边不能有空格，否则会被shell解析错误。&lt;/li&gt;
&lt;li&gt;tee 同时将输出内容显示在屏幕上、记录在文件里&lt;/li&gt;

&lt;li&gt;&lt;p&gt;三种引号‘’，“”，``。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rm -rf ‘my document’  &amp;mdash;-当命令行里面包含空格时，用单引号包含起来&lt;/li&gt;
&lt;li&gt;这时也可由用双引号，区别在于双引号的值会被变量的之替换，单引号保持原样。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;$ ABC=hello
$ echo &#39;string is ${ABC}&#39;
string is ${ABC}
$ echo &amp;quot;string is ${ABC}&amp;quot;
string is hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;反引号实际上就是命令替换&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo `uname`  #等价 echo $(uname)
$ echo `uname -a`
Linux ubuntu 3.13.0-24-generic #46-Ubuntu SMP Thu Apr 10 19:11:08 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux
$ uname -a
Linux ubuntu 3.13.0-24-generic #46-Ubuntu SMP Thu Apr 10 19:11:08 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;脚本的执行&#34;&gt;脚本的执行&lt;/h4&gt;

&lt;p&gt;&lt;div class=&#34;cnblogs_code&#34;&gt;
&lt;pre&gt;&lt;span style=&#34;color: #000000;&#34;&gt;$ vi test.sh
$ cat test.sh
echo &lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;&amp;laquo;&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt; this is a test&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;&amp;laquo;&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;&lt;/p&gt;

&lt;p&gt;$ ls &lt;/span&gt;-&lt;span style=&#34;color: #000000;&#34;&gt;al
total &lt;/span&gt;&lt;span style=&#34;color: #800080;&#34;&gt;12&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;
drwxr&lt;/span&gt;-xr-x  &lt;span style=&#34;color: #800080;&#34;&gt;2&lt;/span&gt; xwei xwei &lt;span style=&#34;color: #800080;&#34;&gt;4096&lt;/span&gt; Mar &lt;span style=&#34;color: #800080;&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color: #800080;&#34;&gt;16&lt;/span&gt;:&lt;span style=&#34;color: #800080;&#34;&gt;49&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt; .
drwxr&lt;/span&gt;-xr-x &lt;span style=&#34;color: #800080;&#34;&gt;16&lt;/span&gt; xwei xwei &lt;span style=&#34;color: #800080;&#34;&gt;4096&lt;/span&gt; Mar &lt;span style=&#34;color: #800080;&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color: #800080;&#34;&gt;15&lt;/span&gt;:&lt;span style=&#34;color: #800080;&#34;&gt;28&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt; ..
&lt;/span&gt;-rw-rw-r&amp;ndash;  &lt;span style=&#34;color: #800080;&#34;&gt;1&lt;/span&gt; xwei xwei   &lt;span style=&#34;color: #800080;&#34;&gt;26&lt;/span&gt; Mar &lt;span style=&#34;color: #800080;&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color: #800080;&#34;&gt;16&lt;/span&gt;:&lt;span style=&#34;color: #800080;&#34;&gt;49&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt; test.sh
$ . test.sh  #以source test.sh 方式执行，读入文件中的命令，在当前shell执行，source内置命令，无需执行权限，其可以缩写为一个小数点
 &lt;/span&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;this&lt;/span&gt; &lt;span style=&#34;color: #0000ff;&#34;&gt;is&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt; a test
$ .&lt;/span&gt;/&lt;span style=&#34;color: #000000;&#34;&gt;test.sh  #
bash: .&lt;/span&gt;/&lt;span style=&#34;color: #000000;&#34;&gt;test.sh: Permission denied&lt;/p&gt;

&lt;p&gt;xwei@ubuntu:&lt;/span&gt;~/Desktop$ chmod a+&lt;span style=&#34;color: #000000;&#34;&gt;x test.sh
xwei@ubuntu:&lt;/span&gt;~/Desktop$ ls -&lt;span style=&#34;color: #000000;&#34;&gt;al
total &lt;/span&gt;&lt;span style=&#34;color: #800080;&#34;&gt;12&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;
drwxr&lt;/span&gt;-xr-x  &lt;span style=&#34;color: #800080;&#34;&gt;2&lt;/span&gt; xwei xwei &lt;span style=&#34;color: #800080;&#34;&gt;4096&lt;/span&gt; Mar &lt;span style=&#34;color: #800080;&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color: #800080;&#34;&gt;16&lt;/span&gt;:&lt;span style=&#34;color: #800080;&#34;&gt;49&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt; .
drwxr&lt;/span&gt;-xr-x &lt;span style=&#34;color: #800080;&#34;&gt;16&lt;/span&gt; xwei xwei &lt;span style=&#34;color: #800080;&#34;&gt;4096&lt;/span&gt; Mar &lt;span style=&#34;color: #800080;&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color: #800080;&#34;&gt;15&lt;/span&gt;:&lt;span style=&#34;color: #800080;&#34;&gt;28&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt; ..
&lt;/span&gt;-rwxrwxr-x  &lt;span style=&#34;color: #800080;&#34;&gt;1&lt;/span&gt; xwei xwei   &lt;span style=&#34;color: #800080;&#34;&gt;26&lt;/span&gt; Mar &lt;span style=&#34;color: #800080;&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color: #800080;&#34;&gt;16&lt;/span&gt;:&lt;span style=&#34;color: #800080;&#34;&gt;49&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt; test.sh
$ .&lt;/span&gt;/&lt;span style=&#34;color: #000000;&#34;&gt;test.sh  #在一个子shell中执行命令
 &lt;/span&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;this&lt;/span&gt; &lt;span style=&#34;color: #0000ff;&#34;&gt;is&lt;/span&gt; a test&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>QT环境下，全局变量共享问题</title>
      <link>https://tmhm.github.io/2016/03/08/qt%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 08 Mar 2016 12:47:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/03/08/qt%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;&lt;strong&gt;开始的技术路线是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;首先有两个主线程：&lt;/p&gt;
&lt;p&gt;　　1，gui线程&lt;/p&gt;
&lt;p&gt;　　2，等待客户端socket连接用的，listen线程&lt;/p&gt;
&lt;p&gt;　　（当有客户端连接时，即creat一个新的线程2用来跟客户端通信，再来新的客户端，继续creat新的work线程3用于通信，以此类推，目前最多可以creat5个线程，即可以同时跟5台客户端通信，设置了监听的socket服务器最多监听5个队列。线程2继续listen）&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出现的问题是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　用来通信的work线程3，收到一个来自客户端的xml文件，然后解析文件，并将其数据放在一个全局的静态struct数组里。数据正常，线程2和线程3均可以看到已经更新的数据值。但是，&lt;/p&gt;
&lt;p&gt;　　当gui线程去访问时，发现数据并没有更新到其线程，在gui线程下改变该全局变量的数值，也并没有更新到线程2和3，不知何解？&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;一博主，有如此解释&lt;/em&gt;：&lt;/p&gt;
&lt;div id=&#34;article_content&#34; class=&#34;article_content&#34;&gt;&lt;a href=&#34;http://blog.csdn.net/lmh12506/article/details/8452700&#34; target=&#34;_blank&#34;&gt;其实在Linux 中，新建的线程并不是在原先的进程中，而是系统通过一个系统调用clone() 。该系统copy 了一个和原先进程完全一样的进程，并在这个进程中执行线程函数。不过这个copy 过程和fork 不一样。copy 后的进程和原先的进程共享了所有的变量，运行环境（clone的实现是可以指定新进程与老进程之间的共享关系，100%共享就表示创建了一个线程）。这样，原先进程中的变量变动在copy 后的进程中便能体现出来。&lt;/a&gt;&lt;/div&gt;
&lt;div class=&#34;bdsharebuttonbox tracking-ad bdshare-button-style0-16&#34; data-mod=&#34;popu_172&#34; data-bd-bind=&#34;1457096202549&#34;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div id=&#34;digg&#34;&gt;&amp;nbsp;不过，问题并没有清晰化。&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&lt;/div&gt;
&lt;div&gt;想到的解决方案暂时有两种：&lt;/div&gt;
&lt;div&gt;　　1，不在work线程里面解析数据，直接在gui线程里面解析数据。&lt;/div&gt;
&lt;div&gt;&amp;nbsp;　　2，采用&lt;a href=&#34;https://www.ibm.com/developerworks/cn/linux/thread/posix_threadapi/part2/&#34; target=&#34;_blank&#34;&gt;线程私有数据&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&lt;/div&gt;
&lt;p&gt;（此处出现过，小插曲：QT的变量查看器，在调试时不太稳定，更新过后的值在窗口中查看，并没有得到及时更新，需要通过程序判定验证！）&lt;/p&gt;
&lt;p&gt;　&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://images2015.cnblogs.com/blog/781469/201603/781469-20160309170140991-312431222.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;由于程序需要在线程创建之后必须返回到gui主线程，所以采用创建两次线程的方式：创建线程A，返回，然后在线程A里面创建&lt;/p&gt;
&lt;p&gt;在多线程POSIX标准下，主线程（1），即是GUI线程。它初始化一个类，并调用其一个成员函数创建一个线程3（ininlistenThred）【不知，为什么不从2开始？】，然后在线程3里面一直循环检测是否有新的客户端发来socket连接。当有新的客户端连接上时，即创建一个新的线程专门用于socket通信。&lt;/p&gt;
&lt;p&gt;此时有一客户端连接上，创建了通信工作线程4（listenthreadwork）。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;输出g_buf[0].carid的代码位置分别为：&lt;/p&gt;
&lt;p&gt;1，initlistenthread线程在进入循环入口 即打印出：&lt;/p&gt;
&lt;div class=&#34;cnblogs_code&#34;&gt;
&lt;p&gt;for( ; ; )&lt;br /&gt;    {&lt;/p&gt;
&lt;p&gt;　　 &amp;nbsp;qDebug(&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;listenthread g_buf[0].carid: %s &lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;,g_buf[&lt;span style=&#34;color: #800080;&#34;&gt;0&lt;/span&gt;&lt;span&gt;].carid);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&#34;__mceDel&#34;&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;&amp;nbsp; 　　char&lt;/span&gt; *t = &amp;amp;(g_buf[&lt;span style=&#34;color: #800080;&#34;&gt;0&lt;/span&gt;].carid[&lt;span style=&#34;color: #800080;&#34;&gt;0&lt;/span&gt;&lt;span&gt;]);&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;em id=&#34;__mceDel&#34;&gt;&lt;em id=&#34;__mceDel&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;　　qDebug(&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;dizhi: %d&lt;/span&gt;&lt;/em&gt;&lt;span style=&#34;color: #800000;&#34;&gt; \n\n&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;,&amp;amp;t);&lt;br /&gt;//......&lt;br /&gt;}&lt;/em&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;2，gui主线程在点击按钮的时候，即打印：&lt;/p&gt;
&lt;div class=&#34;cnblogs_code&#34;&gt;
&lt;pre&gt;qDebug(&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;mainwindow g_buf[0].carid: %s&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;,g_buf[&lt;span style=&#34;color: #800080;&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;].carid);
&lt;/span&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;char&lt;/span&gt; *t = &amp;amp;(g_buf[&lt;span style=&#34;color: #800080;&#34;&gt;0&lt;/span&gt;].carid[&lt;span style=&#34;color: #800080;&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;]);
qDebug(&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;dizhi: %d \n\n&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;,&amp;amp;t);&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;3，listenthreadwork线程在循环工作的时候开始就打印信息：（一进去此线程就会先打印一次值，然后每次收到文件就会打印一次）&lt;/p&gt;
&lt;div class=&#34;cnblogs_code&#34;&gt;
&lt;pre&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;for&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;( ; ; )
    {
        qDebug(&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;listenthreadwork g_buf[0].carid: %s&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;,g_buf[&lt;span style=&#34;color: #800080;&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;].carid);
        &lt;/span&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;char&lt;/span&gt; *t = &amp;amp;(g_buf[&lt;span style=&#34;color: #800080;&#34;&gt;0&lt;/span&gt;].carid[&lt;span style=&#34;color: #800080;&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;]);
        qDebug(&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;dizhi: %d \n\n&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;,&amp;amp;&lt;span style=&#34;color: #000000;&#34;&gt;t);
&lt;/span&gt;&lt;span style=&#34;color: #008000;&#34;&gt;//&lt;/span&gt;&lt;span style=&#34;color: #008000;&#34;&gt;.........&lt;/span&gt;
}&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线程3和4的值一样的！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程1跟另外两个线程是不同的值！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;nbsp;跟类没关系的两个线程值一样&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://images2015.cnblogs.com/blog/781469/201603/781469-20160309171434179-548213179.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://images2015.cnblogs.com/blog/781469/201603/781469-20160309191531804-530669003.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://images2015.cnblogs.com/blog/781469/201603/781469-20160309191541944-1721815549.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>流形学习笔记</title>
      <link>https://tmhm.github.io/2015/09/18/%E6%B5%81%E5%BD%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 18 Sep 2015 14:50:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2015/09/18/%E6%B5%81%E5%BD%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;维数约简&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;特征选择，依据某一标准选择性质最突出的特征&lt;/li&gt;
&lt;li&gt;特征抽取，经已有特征的某种变换获取约简特征&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;增加特征数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以增加信息量，进而提高准确度&lt;/li&gt;
&lt;li&gt;增加训练分类器的难度，进而带来维数灾难。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;解决办法：&lt;/p&gt;
&lt;p&gt;　　选取尽可能多的、可能有用的特征，然后根据需要进行特征约简。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主成分分析（PCA）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong style=&#34;line-height: 1.5;&#34;&gt;&lt;img style=&#34;display: block; margin-left: auto; margin-right: auto;&#34; src=&#34;http://images2015.cnblogs.com/blog/781469/201509/781469-20150918214617414-906516153.png&#34; alt=&#34;&#34; /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目的：&lt;/p&gt;
&lt;p&gt;　　寻找能够表示采样数据的最好投影子空间。&lt;/p&gt;
&lt;p&gt;求解：&lt;/p&gt;
&lt;p&gt;　　对样本的散布矩阵（scatter matrix）进行特征值分解，所求之空间为过样本均值，（何为过样本均值？）&lt;/p&gt;
&lt;p&gt;以最大特征值所对应的特征向量为方向的之空间。&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对椭球状分布的样本集具有很好的效果，理论上，学习到的主方向就是椭圆的主轴方向。&lt;/li&gt;
&lt;li&gt;非监督学习算法，能找到很好地代表所有样本的方向，但是，对于分类未必是最有利的，如下图：　　&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img style=&#34;display: block; margin-left: auto; margin-right: auto;&#34; src=&#34;http://images2015.cnblogs.com/blog/781469/201509/781469-20150918215131414-1106255874.png&#34; alt=&#34;&#34; width=&#34;451&#34; height=&#34;260&#34; /&gt;&lt;/p&gt;
&lt;p&gt;线性判别分析（LDA）&lt;/p&gt;
&lt;p&gt;思想：&lt;/p&gt;
&lt;p&gt;　　寻找最能把两类样本分开的投影直线&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;p&gt;　　监督的维数约简&lt;/p&gt;
&lt;p&gt;目标：&lt;/p&gt;
&lt;p&gt;　　是投影后两类样本的均值之差与投影样本的总类散步的比值最大。&lt;/p&gt;
&lt;p&gt;&lt;img style=&#34;display: block; margin-left: auto; margin-right: auto;&#34; src=&#34;http://images2015.cnblogs.com/blog/781469/201509/781469-20150918215637336-153431327.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;求解：&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多重判别分析（MDA）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　LDA往多类情况的推广&lt;/p&gt;
&lt;p&gt;　　解法与LDA类似，对于C－类问题，把样本投影到C－１维之空间。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;线性方法的缺点：&lt;/p&gt;
&lt;p&gt;线性方法对于某些数据不能进行有效的处理，这类数据，在现实中，往往很多。比如下图：&lt;/p&gt;
&lt;p&gt;&lt;img style=&#34;display: block; margin-left: auto; margin-right: auto;&#34; src=&#34;http://images2015.cnblogs.com/blog/781469/201509/781469-20150918220506773-237605601.jpg&#34; alt=&#34;&#34; width=&#34;389&#34; height=&#34;292&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;另外，现实中的数据往往并不是特征的线性组合。&lt;/p&gt;
&lt;p&gt;比如　paper：A Global Geometric Framework　for Nonlinear Dimensionality　Reduction　所提到的人脸模型&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;流形学习&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;是线性之空间的一种非线性推广；&lt;/li&gt;
&lt;li&gt;一种局部可坐标话的拓扑空间结构；&lt;/li&gt;
&lt;li&gt;一种非线性额维数约简方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基本思想：&lt;/p&gt;
&lt;p&gt;　　高维观测空间中的点是由少数独立变量的共同作用在观测空间张成一个流形，如果能有效地展开观测空间卷曲的流形或者发现其内在的主要变量，就可以对该数据集进行降维。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;可行性分析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;许多高维采样数据都是由少数几个隐含变量所决定的, 如人脸采样由光线亮度, 人离相机的距离, 人的头部姿势, 人的脸部肌肉等因素决定；&lt;/li&gt;
&lt;li&gt;从认知心理学的角度来看, 心理学家认为人的认知过程是基于认知流形和拓扑连续性的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;几种经典的流形学习方法：&lt;/p&gt;
&lt;p&gt;　　局部线性嵌入（LLE）　Nonlinear dimensionality reduction by locally linear embedding. Science&lt;/p&gt;
&lt;p&gt;　　等距映射（IsoMap）A global geometric framework for nonlinear dimensionality reduction. Science,&lt;/p&gt;
&lt;p&gt;　　拉普拉斯特征映射（Laplacian　Eigenmap）Laplacian Eigenmaps for Dimensionality Reduction and Data Representation. Neural Computation,&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自动化所　流形学习　课件。&lt;/li&gt;
&lt;li&gt;paper：A Global Geometric Framework　for Nonlinear Dimensionality　Reduction，　ｓｃｉｅｎｃｅ，２０００&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>