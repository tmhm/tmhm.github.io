<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on Well</title>
    <link>https://tmhm.github.io/categories/algorithm/</link>
    <description>Recent content in Algorithm on Well</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>wells217@163.com (Well)</managingEditor>
    <webMaster>wells217@163.com (Well)</webMaster>
    <copyright>(c) 2017 Well.</copyright>
    <lastBuildDate>Sat, 17 Sep 2016 10:44:00 +0000</lastBuildDate>
    <atom:link href="https://tmhm.github.io/categories/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>stacks and queues--codility</title>
      <link>https://tmhm.github.io/2016/09/17/stacks-and-queues--codility/</link>
      <pubDate>Sat, 17 Sep 2016 10:44:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/09/17/stacks-and-queues--codility/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.7.1&#34;&gt;1. Nesting&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.7.2&#34;&gt;2. StoneWall&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.7.3&#34;&gt;3. Brackets&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.7.4&#34;&gt;4. Finsh&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id = &#34;1.7&#34;&gt;
lesson 7: &lt;i&gt;stacks and queues&lt;/i&gt;
&lt;/h3&gt;

&lt;h4 id = &#34;1.7.1&#34;&gt;
1. Nesting
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Determine whether given string of parentheses is properly nested.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A string S consisting of N characters is called properly nested if:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;S is empty;&lt;/li&gt;
&lt;li&gt;S has the form &amp;laquo;(U)&amp;raquo; where U is a properly nested string;&lt;/li&gt;
&lt;li&gt;S has the form &amp;laquo;VW&amp;raquo; where V and W are properly nested strings.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example, string &amp;laquo;(()(())())&amp;raquo; is properly nested but string &amp;laquo;())&amp;raquo; isn&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Assume that:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;N is an integer within the range [0..1,000,000];&lt;/li&gt;
&lt;li&gt;string S consists only of the characters &amp;laquo;(&amp;raquo; and/or &amp;laquo;)&amp;raquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Complexity:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;expected worst-case time complexity is O(N);&lt;/li&gt;
&lt;li&gt;expected worst-case space complexity is O(1) (not counting the storage required for input arguments).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;solution:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;li&gt;used stack&lt;/li&gt;
&lt;li&gt;must have &amp;laquo;(&amp;raquo; before &amp;laquo;)&amp;raquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(S):
    # write your code in Python 2.7
    tmp = 0
    for elem in S:
        if elem == &amp;quot;(&amp;quot;:
            tmp += 1
        elif elem == &amp;quot;)&amp;quot;:
            tmp -= 1
            if tmp &amp;lt; 0:
                return 0
    if tmp == 0:
        return 1
    else:
        return 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.7.2&#34;&gt;
2. StoneWall
&lt;/h4&gt;

&lt;p&gt;You are going to build a stone wall. The wall should be straight and N meters long, and its thickness should be constant; however, it should have different heights in different places. The height of the wall is specified by a zero-indexed array H of N positive integers. H[I] is the height of the wall from I to I+1 meters to the right of its left end. In particular, H[0] is the height of the wall&amp;rsquo;s left end and H[N−1] is the height of the wall&amp;rsquo;s right end.&lt;/p&gt;

&lt;p&gt;The wall should be built of cuboid stone blocks (that is, all sides of such blocks are rectangular). Your task is to compute the minimum number of blocks needed to build the wall.&lt;/p&gt;

&lt;p&gt;For example, given array H containing N = 9 integers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      H[0] = 8    H[1] = 8    H[2] = 5
      H[3] = 7    H[4] = 9    H[5] = 8
      H[6] = 7    H[7] = 4    H[8] = 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the function should return 7. The figure shows one possible arrangement of seven blocks.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://codility-frontend-prod.s3.amazonaws.com/media/task_img/stone_wall/media/auto/mp2e167f4181a5967a0844fbd70a3a5bfb.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Assume that:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;N is an integer within the range [1..100,000];&lt;/li&gt;
&lt;li&gt;each element of array H is an integer within the range [1..1,000,000,000].&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Cover &amp;laquo;Manhattan skyline&amp;raquo; using the minimum number of rectangles.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(H):
    # write your code in Python 2.7
    cnt = 0
    stack = []
    for elem in H:
        while len(stack)!= 0 and stack[-1] &amp;gt; elem:
            stack.pop()

        if len(stack) != 0 and stack[-1] == elem:
            pass
        else:
            stack.append(elem)
            cnt += 1
    return cnt

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.7.3&#34;&gt;
3. Brackets

&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Determine whether a given string of parentheses is properly nested.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Task description&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A string S consisting of N characters is considered to be properly nested if any of the following conditions is true:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;S is empty;&lt;/li&gt;
&lt;li&gt;S has the form &amp;laquo;(U)&amp;raquo; or &amp;laquo;[U]&amp;raquo; or &amp;laquo; {
    U
}&amp;raquo; where U is a properly nested string;&lt;/li&gt;
&lt;li&gt;S has the form &amp;laquo;VW&amp;raquo; where V and W are properly nested strings.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example, the string &amp;laquo; {
        [()()]
}&amp;raquo; is properly nested but &amp;laquo;([)()]&amp;raquo; is not.&lt;/p&gt;

&lt;p&gt;For example, given S = &amp;laquo;{[()()]}&amp;laquo;, the function should return 1 and given S = &amp;laquo;([)()]&amp;laquo;, the function should return 0, as explained above.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Assume that:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;N is an integer within the range [0..200,000];&lt;/li&gt;
&lt;li&gt;string S consists only of the following characters: &amp;laquo;(&amp;raquo;, &amp;laquo;{&amp;raquo;, &amp;laquo;[&amp;laquo;, &amp;laquo;]&amp;raquo;, &amp;laquo;}&amp;raquo; and/or &amp;laquo;)&amp;raquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Complexity:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;expected worst-case time complexity is O(N);&lt;/li&gt;
&lt;li&gt;expected worst-case space complexity is O(N) (not counting the storage required for input arguments).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用一个stack，当栈头和新来的元素配对，即弹出，否则压栈。
注意：list为空的时候， 还有多个空值的list。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;solution：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def check(t,s):
    if len(t) &amp;lt; 1:
        return 0
    if s == &#39;)&#39; and t[-1] == &#39;(&#39;:
        return 1
    elif s == &#39;]&#39; and t[-1] == &#39;[&#39;:
        return 1
    elif s == &#39;}&#39; and t[-1] == &#39;{&#39;:
        return 1
    else:
        return 0


def solution(S):
    tmp = []
    for elem in S:
        if elem == &#39; &#39;:
            continue
        if check(tmp, elem):
            tmp.pop()
        else:
            tmp.append(elem)
            #print &amp;quot;append: %s, len: %s&amp;quot; %(elem,len(tmp))

    if len(tmp) &amp;lt; 1:
        return 1
    else:
        return 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.7.4&#34;&gt;

4. Fish

&lt;/h4&gt;

&lt;p&gt;Given two non-empty zero-indexed arrays A and B consisting of N integers. Arrays A and B represent N voracious fish in a river, ordered downstream along the flow of the river.&lt;/p&gt;

&lt;p&gt;The fish are numbered from 0 to N ? 1. If P and Q are two fish and P &amp;lt; Q, then fish P is initially upstream of fish Q. Initially, each fish has a unique position.&lt;/p&gt;

&lt;p&gt;Fish number P is represented by A[P] and B[P]. Array A contains the sizes of the fish. All its elements are unique. Array B contains the directions of the fish. It contains only 0s and/or 1s, where:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0 represents a fish flowing upstream,&lt;/li&gt;
&lt;li&gt;1 represents a fish flowing downstream.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If two fish move in opposite directions and there are no other (living) fish between them, they will eventually meet each other. Then only one fish can stay alive ? the larger fish eats the smaller one. More precisely, we say that two fish P and Q meet each other when P &amp;lt; Q, B[P] = 1 and B[Q] = 0, and there are no living fish between them. After they meet:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If A[P] &amp;gt; A[Q] then P eats Q, and P will still be flowing downstream,&lt;/li&gt;
&lt;li&gt;If A[Q] &amp;gt; A[P] then Q eats P, and Q will still be flowing upstream.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We assume that all the fish are flowing at the same speed. That is, fish moving in the same direction never meet. The goal is to calculate the number of fish that will stay alive.&lt;/p&gt;

&lt;p&gt;For example, consider arrays A and B such that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      A[0] = 4    B[0] = 0
      A[1] = 3    B[1] = 1
      A[2] = 2    B[2] = 0
      A[3] = 1    B[3] = 0
      A[4] = 5    B[4] = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Initially all the fish are alive and all except fish number 1 are moving upstream. Fish number 1 meets fish number 2 and eats it, then it meets fish number 3 and eats it too. Finally, it meets fish number 4 and is eaten by it. The remaining two fish, number 0 and 4, never meet and therefore stay alive.&lt;/p&gt;

&lt;p&gt;For example, given the arrays shown above, the function should return 2, as explained above.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Assume that:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;N is an integer within the range [1..100,000];&lt;/li&gt;
&lt;li&gt;each element of array A is an integer within the range [0..1,000,000,000];&lt;/li&gt;
&lt;li&gt;each element of array B is an integer that can have one of the following values: 0, 1;&lt;/li&gt;
&lt;li&gt;the elements of A are all distinct.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Complexity:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;expected worst-case time complexity is O(N);&lt;/li&gt;
&lt;li&gt;expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;考虑到所有鱼的速度一致，那么从上游开始check，
前面的鱼如果是往上游走的话，即永远不会被吃或者吃其他鱼,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def solution(A, B):
    # write your code in Python 2.7
    # record the num of fish with downstream
    lastFishDir = 0
    stackTmp = []

    # check fish from upstream
    for fish, curDir in zip(A,B):
        if lastFishDir &amp;lt; 1:
            stackTmp.append(fish)
            #lastFishDir += curDir
        else:
            if curDir == 0:
                while lastFishDir &amp;gt; 0 and fish &amp;gt; stackTmp[-1]:
                    stackTmp.pop()
                    lastFishDir -= 1
                if len(stackTmp) &amp;gt; 0 and fish &amp;lt; stackTmp[-1]:
                    continue
                stackTmp.append(fish)
            else:
                stackTmp.append(fish)

        lastFishDir += curDir
    return len(stackTmp)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;思考方式很重要：&lt;/p&gt;

&lt;p&gt;由于，上游的鱼如果是往上游走的话，即永远不会被吃或者吃其他鱼,
如果把这样的鱼也放在stack里面，每次fight之后，不太好处理，
故我们可以把一定可以存活的鱼直接计数， 将需要fight的鱼放在stack里面&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;[100%]&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A, B):
    lastFishDir = 0  # record the num of fish with downstream
    stackDown = []
    aliveCnt = 0

    # check fish from upstream
    for fish, curDir in zip(A,B):
        if curDir == 1:
            # only the downstream fish need fight,
            stackDown.append(fish)
        else:
            while lastFishDir &amp;gt; 0 :
                if fish &amp;gt; stackDown[-1]:
                    stackDown.pop()
                    lastFishDir -= 1
                else:
                    break
            else:
                aliveCnt += 1

        lastFishDir += curDir

    return len(stackDown)+aliveCnt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该博主分析的很详细，&lt;a href=&#34;https://codesays.com/2014/solution-to-fish-by-codility/&#34;&gt;https://codesays.com/2014/solution-to-fish-by-codility/&lt;/a&gt;
&amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def solution(A, B):
    alive_count = 0        # The number of fish that will stay alive
    downstream = []        # To record the fishs flowing downstream
    downstream_count = 0   # To record the number of elements in downstream

    for index in xrange(len(A)):
        # Compute for each fish
        if B[index] == 1:
            # This fish is flowing downstream. It would
            # NEVER meet the previous fishs. But possibly
            # it has to fight with the downstream fishs.
            downstream.append(A[index])
            downstream_count += 1
        else:
            # This fish is flowing upstream. It would either
            #    eat ALL the previous downstream-flow fishs,
            #    and stay alive.
            # OR
            #    be eaten by ONE of the previous downstream-
            #    flow fishs, which is bigger, and died.
            while downstream_count != 0:
                # It has to fight with each previous living
                # fish, with nearest first.
                if downstream[-1] &amp;lt; A[index]:
                    # Win and to continue the next fight
                    downstream_count -= 1
                    downstream.pop()
                else:
                    # Lose and die
                    break
            else:
                # This upstream-flow fish eat all the previous
                # downstream-flow fishs. Win and stay alive.
                alive_count += 1

    # Currently, all the downstream-flow fishs in stack
    # downstream will not meet with any fish. They will
    # stay alive.
    alive_count += len(downstream)

    return alive_count
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>sorting--codility</title>
      <link>https://tmhm.github.io/2016/09/14/sorting--codility/</link>
      <pubDate>Wed, 14 Sep 2016 09:36:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/09/14/sorting--codility/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.6.1&#34;&gt;1. Distinct&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.6.2&#34;&gt;2. Triangle&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.6.3&#34;&gt;2. MaxProductOfThree&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.6.4&#34;&gt;4. NumberOfDiscIntersections&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id = &#34;1.6&#34;&gt;
lesson 6: &lt;i&gt;sorting&lt;/i&gt;
&lt;/h3&gt;

&lt;h4 id=&#34;exercise&#34;&gt;exercise&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Problem:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You are given a zero-indexed array A consisting of n &amp;gt; 0 integers; you must return the number of unique values in array A.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Solution O(nlogn):&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;First, sort array A; similar values will then be next to each other. Finally, just count the number of distinct pairs in adjacent cells.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The number of distinct values — O(nlogn).
def distinct(A):
        n = len(A)
        A.sort()
        result = 1
        for k in xrange(1, n):
                if A[k] != A[k - 1]: result += 1
        return result
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The time complexity is O(n log n), in view of the sorting time.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id = &#34;1.6.1&#34;&gt;
1. Distinct
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Compute number of distinct values in an array.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;将list保存为set 即可&lt;/li&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;li&gt;也可以排序，然后对不同数进行计数，如exercise那样&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    Aset = set(A)
    return len(Aset)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.6.2&#34;&gt;
2. Triangle
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Determine whether a triangle can be built from a given set of edges.
&lt;a href=&#34;https://codesays.com/2014/solution-to-triangle-by-codility/&#34;&gt;https://codesays.com/2014/solution-to-triangle-by-codility/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;On one hand, there is no false triangular. Since the array is sorted, we already know A[index] &amp;lt; = A[index+1] &amp;lt;= A[index+2], and all values are positive. A[index] &amp;lt;= A[index+2], so it must be true that A[index] &amp;lt; A[index+1] + A[index+2]. Similarly, A[index+1] &amp;lt; A[index] + A[index+2]. Finally, we ONLY need to check &lt;strong&gt;A[index]+A[index+1] &amp;gt; A[index+2]&lt;/strong&gt; to confirm the existence of triangular.&lt;/p&gt;

&lt;p&gt;On the other hand, there is no underreporting triangular. If the inequality can hold for three out-of-order elements, to say, A[index]+A[index+m] &amp;gt; A[index+n], where n&amp;gt;m&amp;gt;1. Again, because the array is sorted, we must have A[index] &amp;lt; = A[index+m-1] and A[index+m+1] &amp;lt;= A[index + n]. So A[index+m-1] +A[index+m] &amp;gt;= A[index]+A[index+m] &amp;gt; A[index+n] &amp;gt;= A[index+m+1]. After simplification, A[index+m-1] +A[index+m] &amp;gt; A[index+m+1]. In other words, if we have any inequality holding for out-of-order elements, we MUST have AT LEAST an inequality holding for three consecutive elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    length = len(A)
    if length &amp;lt; 3:
        return 0
    A.sort()
    for idx in xrange(0,length -2):
        if A[idx]+A[idx + 1] &amp;gt; A[idx + 2]:
            return 1
    return 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.6.3&#34;&gt;
3. MaxProductOfThree
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Maximize A[P] * A[Q] * A[R] for any triplet (P, Q, R).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;solution-1&#34;&gt;solution 1&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;O(N)&lt;/li&gt;
&lt;li&gt;Test score  100% OJ test is O(N * log(N))&lt;/li&gt;
&lt;li&gt;考虑到有负数存在， 故乘积最大的三个数，会出现在两种情况：

&lt;ul&gt;
&lt;li&gt;三个数均是正数，且是三个最大的数&lt;/li&gt;
&lt;li&gt;两个负数和一个正数，最大正数和最小的两个负数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    ma1, ma2, ma3 = -1000, -1000, -1000
    mi1, mi2 = 1000, 1000
    for elem in A:
        if elem &amp;gt; ma1:
            ma1, ma2, ma3 = elem, ma1, ma2
        elif elem &amp;gt; ma2:
            ma2, ma3 = elem, ma2
        elif elem &amp;gt; ma3:
            ma3 = elem

        if elem &amp;lt; mi1:
            mi1,mi2 = elem, mi1
        elif elem &amp;lt; mi2:
            mi2 = elem
    a, b = ma1*ma2*ma3, ma1*mi1*mi2
    return a if a &amp;gt; b else b
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution-2&#34;&gt;solution 2&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;just need return the value of the max product,&lt;/li&gt;
&lt;li&gt;基于解法一，我们可以先排序，然后直接取，不需要每个比较，相对来说，时间成本稍大&lt;/li&gt;

&lt;li&gt;&lt;p&gt;so, we can just consider the first or last teiplet, after sort&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Detected time complexity: O(N * log(N))&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    A.sort()
    return max(A[0]*A[1]*A[-1], A[-1]*A[-2]*A[-3])

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.6.4&#34;&gt;
4. NumberOfDiscIntersections
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;We draw N discs on a plane. The discs are numbered from 0 to N − 1. A zero-indexed array A of N non-negative integers, specifying the radiuses of the discs, is given. The J-th disc is drawn with its center at (J, 0) and radius A[J].&lt;/p&gt;

&lt;p&gt;We say that the J-th disc and K-th disc intersect if J ≠ K and the J-th and K-th discs have at least one common point (assuming that the discs contain their borders).&lt;/p&gt;

&lt;p&gt;The figure below shows discs drawn for N = 6 and A as follows:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;      A[0] = 1
      A[1] = 5
      A[2] = 2
      A[3] = 1
      A[4] = 4
      A[5] = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://codility-frontend-prod.s3.amazonaws.com/media/task_img/number_of_disc_intersections/media/auto/mpaecfada7c1e52a7b01b04916c859b15d.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;There are eleven (unordered) pairs of discs that intersect, namely:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;discs 1 and 4 intersect, and both intersect with all the other discs;&lt;/li&gt;
&lt;li&gt;disc 2 also intersects with discs 0 and 3.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;problem:&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Compute the number of intersections in a sequence of discs.&lt;/p&gt;

&lt;p&gt;given an array A describing N discs as explained above, returns the number of (unordered) pairs of intersecting discs. The function should return −1 if the number of intersecting pairs exceeds 10,000,000.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Assume that:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;N is an integer within the range [0..100,000];&lt;/li&gt;
&lt;li&gt;each element of array A is an integer within the range [0..2,147,483,647].&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Complexity:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;expected worst-case time complexity is O(N*log(N));&lt;/li&gt;
&lt;li&gt;expected worst-case space complexity is O(N).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/dear0607/article/details/42671621&#34;&gt;参考csdn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/4801242/algorithm-to-calculate-number-of-intersecting-discs#&#34;&gt;stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;initially we calculate all start and end points of discs. After go by all line and check count of discs inside current point. If in current point started some discs and intersection count increased by: already active distsc multiplied by count of started in current point (result += t * dps[i]) and count of intersections of started(result += dps[i] * (dps[i] - 1) / 2) eg. if started 5 discs in one of point it will increased by(1+2+3+4+5 intersections, or 5*(5-1) / 2[sum formula]).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;构造成区间，[i-A[i],i+A[i]]

&lt;ul&gt;
&lt;li&gt;e.g. A ＝ ［1，5，2，1，4，0］&lt;/li&gt;
&lt;li&gt;=&amp;gt; [－1,1],[-4,6],[0,4],[2,4],[0,8],[5,5]&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;因为我们圆的中心位置在［0，len(A)],e.g. 在上例中 [0,5], 所以起点数组dps计算［0，i-A[i]］的范围，故有max(0,i-A[i])&lt;/li&gt;
&lt;li&gt;终点数组不要超过每个圆心的最大值，即小于len（A）－1， 故有min（length－1，i+A［i］）&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;sloution-100&#34;&gt;sloution:[100%]&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    result = 0
    length = len(A)
    dps = [0]*length
    dpe = [0]*length
    for i in xrange(length):
        dps[max(0, i-A[i])] += 1
        dpe[min(length-1, i+A[i])] += 1
    tmp = 0
    for i in xrange(length):
        if dps[i] &amp;gt; 0:
            result += tmp*dps[i]
            result += dps[i] * (dps[i] - 1)/2
            if result &amp;gt; 10000000:
                return -1
            tmp += dps[i]
        tmp -= dpe[i]
    return result
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>prefix sums--codility</title>
      <link>https://tmhm.github.io/2016/09/04/prefix-sums--codility/</link>
      <pubDate>Sun, 04 Sep 2016 09:08:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/09/04/prefix-sums--codility/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.5.1&#34;&gt;1. PassingCars&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.5.2&#34;&gt;2. CountDiv&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.5.3&#34;&gt;3. GenomicRangeQuery&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.5.4&#34;&gt;4. MinAvgTwoSlice&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id = &#34;1.5&#34;&gt;
lesson 5: &lt;i&gt;prefix sums&lt;/i&gt;
&lt;/h3&gt;

&lt;h4 id = &#34;1.5.1&#34;&gt;
1. &lt;i&gt; PassingCars&lt;/i&gt;
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Count the number of passing cars on the road.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A non-empty zero-indexed array A consisting of N integers is given. The consecutive elements of array A represent consecutive cars on a road.&lt;/p&gt;

&lt;p&gt;Array A contains only 0s and/or 1s:&lt;/p&gt;

&lt;p&gt;0 represents a car traveling east,
1 represents a car traveling west.
The goal is to count passing cars. We say that a pair of cars (P, Q), where 0 ≤ P &amp;lt; Q &amp;lt; N, is passing when P is traveling to the east and Q is traveling to the west.&lt;/p&gt;

&lt;p&gt;For example, consider array A such that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  A[0] = 0
  A[1] = 1
  A[2] = 0
  A[3] = 1
  A[4] = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have five pairs of passing cars: (0, 1), (0, 3), (0, 4), (2, 3), (2, 4).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Assume that:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;N is an integer within the range [1..100,000];&lt;/li&gt;
&lt;li&gt;each element of array A is an integer that can have one of the following values: 0, 1.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Complexity:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;expected worst-case time complexity is O(N);&lt;/li&gt;
&lt;li&gt;expected worst-case space complexity is O(1),&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以计算suffix sum的方式&lt;/li&gt;
&lt;li&gt;然后，从前面开始遍历list，遇到a ＝ 0，result即加上当前的suffix sum的值&lt;/li&gt;

&lt;li&gt;&lt;p&gt;此题元素是0，1，故可以不用保留每一步的计算，题目有要求限制O(1)的space， 也是给出提示，用一个变量retsum值来记录，每一步的prefix sum值，每移动一步，元素是1的话，将retsum 减1， 即是下一个prefix sum 值。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Detected time complexity: O(N)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[100%]&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    result = 0
    retsum = sum(A)
    for a in A:
        if a == 0:
            result += retsum
            if result &amp;gt; 1000000000:
                return -1
        else:
            retsum -= 1
    return result
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.5.2&#34;&gt;
2. &lt;i&gt; CountDiv &lt;/i&gt;
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Compute number of integers divisible by k in range [a..b].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;given three integers A, B and K, returns the number of integers within the range [A..B] that are divisible by K, i.e.:&lt;/p&gt;

&lt;p&gt;{ i : A ≤ i ≤ B, i mod K = 0 }&lt;/p&gt;

&lt;p&gt;For example, for A = 6, B = 11 and K = 2, your function should return 3, because there are three numbers divisible by 2 within the range [6..11], namely 6, 8 and 10.&lt;/p&gt;

&lt;p&gt;Assume that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A and B are integers within the range [0..2,000,000,000];&lt;/li&gt;
&lt;li&gt;K is an integer within the range [1..2,000,000,000];
A ≤ B.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Complexity:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;expected worst-case time complexity is O(1);&lt;/li&gt;
&lt;li&gt;expected worst-case space complexity is O(1).&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;countdiv-solution-1:7636a8ab415e12ff71d303247ac5f18e&#34;&gt;CountDiv solution 1&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A, B, K):
    # write your code in Python 2.7
    ra = -1 if A == 0 else (A - 1)/K
    rb = B/K

    return rb -ra

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution-2:7636a8ab415e12ff71d303247ac5f18e&#34;&gt;solution 2&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A, B, K):
    # write your code in Python 2.7
    c = 1 if A%K == 0 else 0
    return B/K -A/K + c

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;def solution(A, B, K):
    # write your code in Python 2.7
    return (B/K - A/K) if (A%K != 0 ) else (B/K - A/K + 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.5.3&#34;&gt;
3. GenomicRangeQuery
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Find the minimal nucleotide from a range of sequence DNA.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A DNA sequence can be represented as a string consisting of the letters A, C, G and T, which correspond to the types of successive nucleotides in the sequence. Each nucleotide has an impact factor, which is an integer. Nucleotides of types A, C, G and T have impact factors of 1, 2, 3 and 4, respectively. You are going to answer several queries of the form: What is the minimal impact factor of nucleotides contained in a particular part of the given DNA sequence?&lt;/p&gt;

&lt;p&gt;The DNA sequence is given as a non-empty string S = S[0]S[1]&amp;hellip;S[N-1] consisting of N characters. There are M queries, which are given in non-empty arrays P and Q, each consisting of M integers. The K-th query (0 ≤ K &amp;lt; M) requires you to find the minimal impact factor of nucleotides contained in the DNA sequence between positions P[K] and Q[K](inclusive).&lt;/p&gt;

&lt;p&gt;For example, consider string S = CAGCCTA and arrays P, Q such that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    P[0] = 2    Q[0] = 4
    P[1] = 5    Q[1] = 5
    P[2] = 0    Q[2] = 6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The answers to these M = 3 queries are as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The part of the DNA between positions 2 and 4 contains nucleotides G and C (twice), whose impact factors are 3 and 2 respectively, so the answer is 2.&lt;/li&gt;
&lt;li&gt;The part between positions 5 and 5 contains a single nucleotide T, whose impact factor is 4, so the answer is 4.&lt;/li&gt;
&lt;li&gt;The part between positions 0 and 6 (the whole string) contains all nucleotides, in particular nucleotide A whose impact factor is 1, so the answer is 1.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;the function should return the values [2, 4, 1], as explained above.&lt;/p&gt;

&lt;p&gt;Assume that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;N is an integer within the range [1..100,000];&lt;/li&gt;
&lt;li&gt;M is an integer within the range [1..50,000];&lt;/li&gt;
&lt;li&gt;each element of arrays P, Q is an integer within the range [0..N − 1];&lt;/li&gt;
&lt;li&gt;P[K] ≤ Q[K], where 0 ≤ K &amp;lt; M;&lt;/li&gt;
&lt;li&gt;string S consists only of upper-case English letters A, C, G, T.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Complexity:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;expected worst-case time complexity is O(N+M);&lt;/li&gt;
&lt;li&gt;expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;解法一:7636a8ab415e12ff71d303247ac5f18e&#34;&gt;解法一：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Test score  62%&lt;/li&gt;
&lt;li&gt;Detected time complexity:
O(N * M)&lt;/li&gt;
&lt;li&gt;最初的想法是：根据给出的范围，用set保存，看是否有各元素&lt;/li&gt;
&lt;li&gt;时间复杂度，明显达不到O(N+M)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def getMinFactor(S,l,i,j):
    if j == (l-1):
        tmp = set(S[i:])  #
    else:
        tmp = set(S[i:(j+1)])
    if &#39;A&#39; in tmp:
        return 1
    elif &#39;C&#39; in tmp:
        return 2
    elif &#39;G&#39; in tmp:
        return 3
    else:
        return 4

def solution(S, P, Q):
    # write your code in Python 2.7
    length = len(S)
    result = []
    for x,y in zip(P,Q):
        #print x,y
        result.append(getMinFactor(S,length,x,y))
    return result
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;解法二:7636a8ab415e12ff71d303247ac5f18e&#34;&gt;解法二：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;li&gt;used each list to save that states whether has element or not&lt;/li&gt;
&lt;li&gt;在用prefix sum 做差的方式，依次检查是否存在A,C,G,T字符&lt;/li&gt;
&lt;li&gt;注意数值关系&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def calcPrefixSum(S):
    l = len(S)+1
    pa,pc,pg = [0]*l,[0]*l,[0]*l
    for idx,elem in enumerate(S):
        a,c,g = 0,0,0
        if elem == &#39;A&#39;:
            a = 1
        elif elem == &#39;C&#39;:
            c = 1
        elif elem == &#39;G&#39;:
            g = 1
        pa[idx+1] = pa[idx] + a
        pc[idx+1] = pc[idx] + c
        pg[idx+1] = pg[idx] + g
    return pa,pc,pg

def solution(S, P, Q):
    # write your code in Python 2.7
    pA,pC,pG = calcPrefixSum(S)
    result = []
    for i,j in zip(P,Q):
        if pA[j+1] - pA[i] &amp;gt; 0:
            ret = 1
        elif pC[j+1] - pC[i] &amp;gt; 0:
            ret = 2
        elif pG[j+1] - pG[i] &amp;gt; 0:
            ret = 3
        else:
            ret = 4
        result.append(ret)
    return result

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;根据prefix sum list:
pA = [0, 0, 1, 1, 1, 1, 1, 2]
pC = [0, 1, 1, 1, 2, 3, 3, 3]
pG = [0, 0, 0, 1, 1, 1, 1, 1]

故，是下标［j＋1］－［i］
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.5.4&#34;&gt;
4. MinAvgTwoSlice
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Find the minimal average of any slice containing at least two elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A non-empty zero-indexed array A consisting of N integers is given. A pair of integers (P, Q), such that 0 ≤ P &amp;lt; Q &amp;lt; N, is called a slice of array A (notice that the slice contains at least two elements). The average of a slice (P, Q) is the sum of A[P] + A[P + 1] + &amp;hellip; + A[Q] divided by the length of the slice. To be precise, the average equals (A[P] + A[P + 1] + &amp;hellip; + A[Q]) / (Q − P + 1).&lt;/p&gt;

&lt;p&gt;For example, array A such that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    A[0] = 4
    A[1] = 2
    A[2] = 2
    A[3] = 5
    A[4] = 1
    A[5] = 5
    A[6] = 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;contains the following example slices:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;slice (1, 2), whose average is (2 + 2) / 2 = 2;&lt;/li&gt;
&lt;li&gt;slice (3, 4), whose average is (5 + 1) / 2 = 3;&lt;/li&gt;
&lt;li&gt;slice (1, 4), whose average is (2 + 2 + 5 + 1) / 4 = 2.5.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The goal is to find the starting position of a slice whose average is minimal.&lt;/p&gt;

&lt;p&gt;Complexity:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;expected worst-case time complexity is O(N);&lt;/li&gt;
&lt;li&gt;expected worst-case space complexity is O(N),&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;sloution:7636a8ab415e12ff71d303247ac5f18e&#34;&gt;sloution&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt; transfer to 2/3 ,
- 只要查看相邻两个和三个的数的平均值即可
- &lt;a href=&#34;https://github.com/daotranminh/playground/blob/master/src/codibility/MinAvgTwoSlice/proof.pdf&#34;&gt;proof&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    length = len(A)
    minStartPos = 0
    minSum = (A[0] + A[1])/2.0

    for i in xrange(length - 2):
        tmp = (A[i] + A[i+1])/2.0
        if tmp &amp;lt; minSum:
            minSum = tmp
            minStartPos = i
        tmp = (tmp*2 + A[i+2])/3.0
        if tmp &amp;lt; minSum:
            minSum = tmp
            minStartPos = i
    if (A[-1] + A[-2])/2.0 &amp;lt; minSum:
        minStartPos = length - 2

    return minStartPos
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>counting elements--codility</title>
      <link>https://tmhm.github.io/2016/09/01/counting-elements--codility/</link>
      <pubDate>Thu, 01 Sep 2016 15:46:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/09/01/counting-elements--codility/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.4.1&#34;&gt;1. FrogRiverOne&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.4.2&#34;&gt;2. PermCheck&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.4.3&#34;&gt;3. MissingInteger&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.4.4&#34;&gt;4. MaxCounters&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id = &#34;1.4&#34;&gt;
lesson 4: &lt;i&gt;counting elements&lt;/i&gt;
&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;exercise&lt;/li&gt;
&lt;li&gt;Problem: You are given an integer m (1 &amp;lt;= m &amp;lt;= 1,000,000) and two non-empty, zero-indexed arrays A and B of n integers, a0,a1,&amp;hellip;,an−1 and b0,b1,&amp;hellip;,bn−1 respectively (0 &amp;lt;= ai,bi &amp;lt;= m).&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;For every element of array B, we assume that we will swap it with some element from array A. The difference d tells us the value from array A that we are interested in swapping, because only one value will cause the two totals to be equal. The occurrence of this value can be found in constant time from the array used for counting.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;假设A中ai和B中的bj交换可以满足要求，则有：A＋bj－ai ＝＝ B＋ai－bj&lt;/li&gt;
&lt;li&gt;假设 d ＝ bj － ai， 则有 A ＋ d ＝ B － d&lt;/li&gt;
&lt;li&gt;故有A－B ＝ 2d， 因此，两个数组的差必须是2的整数倍，即偶数，否则不存在交换可以满足题意的元素&lt;/li&gt;
&lt;li&gt;然后由d ＝ bj － ai，得到在A中存在元素ai ＝ bj － d。我们可以对每一个B中的元素bj，查找A中是否有bj－d 即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def counting(A, m):
        n = len(A)
        count=[0]*(m+1)
        for k in xrange(n):
                count[A[k]] += 1
        return count


## from collections import Counter
def fast_solution(A, B, m):
        n = len(A)
        sum_a = sum(A)
        sum_b = sum(B)
        d = sum_b - sum_a
        if d%2==1:
                return False
        d//=2
        count = counting(A, m)
        for i in xrange(n):
                if 0 &amp;lt;= B[i] - d &amp;lt;= m and count[B[i] - d] &amp;gt; 0:
                        return True
        return False

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;根本目的是找到A中存在元素ai ＝ bj － d， 前面的Bj －d 范围在 ［0，m］只是限定count的范围，防止越界！&lt;/p&gt;

&lt;p&gt;若使用collections 的Counter 函数计数，则可以直接查看是否存在bj－d这个元素即可，即count[bj-d] &amp;gt; 0要求。&lt;/p&gt;

&lt;p&gt;我们也可以直接用for everyone B element， 判断if （bj － d） in A 也可以,但是这样的复杂度又变高了， 变成O(N^2)了。因为，每次查找（bj － d） 是否in A 的时候就要N次遍历查找。
&lt;strong&gt;因此，还是用计数的方式好，首先统计A中的元素，以后只要O(1)的时间查找是否存在我们需要的ai。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以有如下解答：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;so,we can do it as follows:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from collections import Counter
def fast_solution(A, B, m):
        n = len(A)
        sum_a = sum(A)
        sum_b = sum(B)
        d = sum_b - sum_a
        if d%2==1:
                return False
        d//=2
        count = Counter(A, m)
        for i in xrange(n):
                if count[B[i] - d] &amp;gt; 0:
                        return True
        return False

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.4.1&#34;&gt;
1. FrogRiverOne----[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Find the earliest time when a frog can jump to the other side of a river.&lt;/p&gt;

&lt;p&gt;The goal is to find the earliest time when the frog can jump to the other side of the river. The frog can cross only when leaves appear at every position across the river from 1 to X (that is, we want to find the earliest moment when all the positions from 1 to X are covered by leaves). You may assume that the speed of the current in the river is negligibly small, i.e. the leaves do not change their positions once they fall in the river.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;each element of array A is an integer within the range [1..X].&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;鉴于元素的范围，所以，可以用list保存出现过的元素，比较list的长度跟X的关系，就可以得到第一次出现X的位置&lt;/li&gt;
&lt;li&gt;这里需要考虑的一个问题是，是第一次访问过所有的元素种类，停留的位置不要求必须是X元素；另一种情况是，不仅仅要求访问过所有的元素种类，还要最后停留在X元素上，再算达到要求。&lt;strong&gt;本题解法是第一种情况。&lt;/strong&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若是第二种情况的话，只需要在set的长度等于X后，多加一次判断，找到接下来第一次出现X的位置即好。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;鉴于O(N) -time  O(X)-space ,每次在保存过的元素中查找费时间，可以直接用set保存，因为set加入新元素的时候，重复元素不会再次加入，这里应该看看&lt;a href=&#34;http://svn.python.org/view/python/trunk/Objects/setobject.c?view=markup&#34;&gt;python源码set&lt;/a&gt;怎么加入的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(X, A):
    # write your code in Python 2.7
    visited = set()
    for idx,elem in enumerate(A):
        visited.add(elem)
        if len(visited) == X:
            return idx
    return -1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.4.2&#34;&gt;
2. PermCheck----[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Check whether array A is a permutation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;思路一：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用最大值是否等于set的长度来测试.
仔细看好题意， 比如是要求从1 开始的list ，
就不需要记最小的值，求长度了，只要记下最大值。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    #A.sort() # Nlog(N)
    if len(A) == 1:
        return 1 if (A[0] == 1) else 0

    sigle = set()
    #maxelem, minelem = A[0], A[0]   #needless minelem,owing to from 1 !!
    maxelem = A[0]
    for elem in A:
        if elem not in sigle:
            sigle.add(elem)
            if elem &amp;gt; maxelem:
                maxelem = elem
        else:
            #print &amp;quot;test&amp;quot;
            return 0
    #print sigle
    return 1 if (len(sigle) == maxelem) else 0

    #return 1 if (A[-1]-A[0]+1) == len(A) else 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;思路二：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果元素的取值是在N个范围内，即数组有N个元素，每个元素范围是[1,N] ,则我们可以用求sum的方式来做 ［score ：100%］&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    set_a = set(A)

    length = len(set_a)
    total = length*(length+1)//2
    tmp = sum(A)
    return 1 if total == tmp else 0

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.4.3&#34;&gt;
3. MissingInteger----[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Find the minimal positive integer not occurring in a given sequence.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;O(N) time &amp;amp; space complexity,if sort, will exceed.&lt;/li&gt;
&lt;li&gt;考虑到不能排序，从解空间出发考虑。返回解一定会在1~len(所给数组)+1的区间。用map记录这些数据是否都在，不在的话，找最小的空缺，都在的时候就是map/list最后一个数加1.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    length = len(A)
    tmp = [True]*(length + 1)
    #print tmp
    for elem in A:
        if 0 &amp;lt; elem &amp;lt; length+1:
            tmp[elem-1] = False
    for idx,elem in enumerate(tmp):
        if elem == True:
            return idx+1
    return length +1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    length = len(A)+1
    tmp = [True]*length
    for a in A:
        if 0 &amp;lt; a &amp;lt; length:
            tmp[a-1] = a
    for idx, a in enumerate(tmp):
        if a is True:
            return idx+1
    #return length

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;将tmp数组增大一位，就不需要最后考虑全部是有序的，再return length ＋ 1了&lt;/em&gt;&lt;/p&gt;

&lt;h3 id = &#34;1.4.4&#34;&gt;
4. MaxCounters
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Calculate the values of counters after applying all alternating operations:increase counter by 1; set value of all counters to current maximum.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;You are given N counters, initially set to 0, and you have two possible operations on them:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;increase(X) − counter X is increased by 1,&lt;/li&gt;
&lt;li&gt;max counter − all counters are set to the maximum value of any counter.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A non-empty zero-indexed array A of M integers is given. This array represents consecutive operations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;if A[K] = X, such that 1 ≤ X ≤ N, then operation K is increase(X),&lt;/li&gt;
&lt;li&gt;if A[K] = N + 1 then operation K is max counter.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example, given integer N = 5 and array A such that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A[0] = 3
A[1] = 4
A[2] = 4
A[3] = 6
A[4] = 1
A[5] = 4
A[6] = 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the values of the counters after each consecutive operation will be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(0, 0, 1, 0, 0)
(0, 0, 1, 1, 0)
(0, 0, 1, 2, 0)
(2, 2, 2, 2, 2)
(3, 2, 2, 2, 2)
(3, 2, 2, 3, 2)
(3, 2, 2, 4, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The goal is to calculate the value of every counter after all operations.&lt;/p&gt;

&lt;h5 id=&#34;解法一&#34;&gt;解法一：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Detected time complexity: O(N*M)&lt;/li&gt;
&lt;li&gt;Test score 66%&lt;/li&gt;
&lt;li&gt;Correctness 100%      Performance     60%&lt;/li&gt;
&lt;li&gt;计算正确，但是时间复杂度不满足要求。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(N, A):
    # write your code in Python 2.7
    ret = [0]*N
    #print ret

    for elem in A:
        if elem &amp;lt; (N + 1):
            #print elem
            #print ret
            ret[int(elem -1)] += 1
        else:
            #tmp = max(ret)
            #print &amp;quot;tmp&amp;quot;,tmp
            #ret = [tmp]*N
            ret = [max(ret)]*N
            #print &amp;quot;ret&amp;quot;,ret
    return ret
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;解法二&#34;&gt;解法二&lt;/h5&gt;

&lt;p&gt;[100%] MaxCounters
&amp;gt;
Calculate the values of counters after applying all alternating operations: increase counter by 1; set value of all counters to current maximum.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;分别记录上次update的值，在update的基础上，再记录当前最大值。&lt;/li&gt;
&lt;li&gt;有点类似操作系统的内存管理，按需分配的味道， 当出现缺页中断的时候再去分配内存。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这里是当出现N+1的时候，再去update 上次没有update的元素，并且在最后一次需要再检查一次update&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Detected time complexity:
O(N + M)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(N, A):
    # write your code in Python 2.7
    ret = [0]*N

    maxOfArray = 0
    last_update = 0
    tn = N + 1
    for elem in A:
        if elem &amp;lt; tn:
            if ret[elem -1] &amp;lt; last_update:
                ret[elem -1] = last_update

            ret[elem -1] += 1
            if ret[elem -1] &amp;gt; maxOfArray:
                maxOfArray = ret[elem -1]
        else:
            last_update = maxOfArray
            #print &amp;quot;last_update&amp;quot;,last_update
            #ret = [maxOfArray]*N

            #print &amp;quot;ret&amp;quot;,ret
    for elem in xrange(N):
        if ret[elem] &amp;lt; last_update:
            ret[elem] = last_update
    return ret
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;def solution(N, A):
    # write your code in Python 2.7
    tn = N + 1
    maxOfCounter = 0
    lastUpdate = 0
    ret = [0]*N
    for a in A:
        if a &amp;lt; tn:
            if ret[a-1] &amp;lt; lastUpdate :
                ret[a-1] = lastUpdate
            ret[a-1] += 1
            if ret[a-1] &amp;gt; maxOfCounter:
                # update max counter
                maxOfCounter = ret[a-1]
        else:
            lastUpdate = maxOfCounter
    for elem in xrange(N):
        if ret[elem-1] &amp;lt; lastUpdate:
            ret[elem-1] = lastUpdate
    return ret
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Time complexity--codility</title>
      <link>https://tmhm.github.io/2016/09/01/time-complexity--codility/</link>
      <pubDate>Thu, 01 Sep 2016 15:44:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/09/01/time-complexity--codility/</guid>
      <description>&lt;h3 id = &#34;1.3&#34;&gt;
lesson 3: &lt;i&gt;Time complexity&lt;/i&gt;
&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;exercise:&lt;/li&gt;
&lt;li&gt;Problem: You are given an integer n. Count the total of 1+2+&amp;hellip;+n.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def sumN(N):
    return N*(N+1)//2

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.3.1&#34;&gt;
1. TapeEquilibrium -----[100%]
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Minimize the value
|(A[0] + &amp;hellip; + A[P-1]) - (A[P] + &amp;hellip; + A[N-1])|.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A non-empty zero-indexed array A consisting of N integers is given. Array A represents numbers on a tape.&lt;/p&gt;

&lt;p&gt;Any integer P, such that 0 &amp;lt; P &amp;lt; N, splits this tape into two non-empty parts: A[0], A[1], &amp;hellip;, A[P − 1] and A[P], A[P + 1], &amp;hellip;, A[N − 1].&lt;/p&gt;

&lt;p&gt;The difference between the two parts is the value of: |(A[0] + A[1] + &amp;hellip; + A[P − 1]) − (A[P] + A[P + 1] + &amp;hellip; + A[N − 1])|&lt;/p&gt;

&lt;p&gt;In other words, it is the absolute difference between the sum of the first part and the sum of the second part.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt; 依次求sum&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):

    #left,right =A[0], sum(A)-A[0]
    left,right =A[0], sum(A[1:])
    result = abs(right - left)

    for elem in A[1:-1]:
        left,right = left + elem, right - elem
        retmp = abs(right - left)
        if retmp &amp;lt; result:
            result = retmp
    return result
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.3.2&#34;&gt;
2. FrogJmp -----[100%]
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Count minimal number of jumps from position X to Y.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A small frog wants to get to the other side of the road. The frog is currently located at position X and wants to get to a position greater than or equal to Y. The small frog always jumps a fixed distance, D.&lt;/p&gt;

&lt;p&gt;Count the minimal number of jumps that the small frog must perform to reach its target.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt; O(1) time complexity, 注意是否在边界上，否则加1即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def solution(X, Y, D):
    # write your code in Python 2.7
    if X == Y:
        return 0
    else:
        flag = (Y - X)%D
        ret = (Y - X)/D
        return ret if flag == 0 else ret + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.3.3&#34;&gt;
3. PermMissingElem -----[100%]
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Find the missing element in a given permutation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A zero-indexed array A consisting of N different integers is given. The array contains integers in the range [1..(N + 1)], which means that exactly one element is missing.&lt;/p&gt;

&lt;p&gt;Your goal is to find that missing element.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;简单思路是排序，然后依此比较是否是增1关系，也可以用求sum的方式&lt;/li&gt;
&lt;li&gt;注意边界条件，N取值［0，100，000］， 元素取值［1，N+1］，&lt;/li&gt;
&lt;li&gt;故当没有元素的时候，返回1；当只有一个元素的时候，需要考虑元素是否是1&lt;/li&gt;
&lt;li&gt;当全部有序的时候，考虑最后元素＋1返回。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    if len(A) == 0:
        return 1
    elif len(A) == 1:
        return A[0]+1 if A[0] == 1 else A[0] -1
    A.sort()
    left = A[0]
    for elem in A[1:]:
        if elem == left + 1:
            left = elem
            continue
        else:
            return left + 1

    return A[-1]+1 if A[0] == 1 else A[0]-1
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    length = len(A)
    if length &amp;lt; 1:
        return 1
    #elif length &amp;lt; 2:  # can belong to the next tatal_sum
    #    return 1 if A[0]==2 else 2

    tatal = sum([i for i in xrange(1,length+2,1) ])
    tmp = sum(A)
    return tatal - tmp

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Arrays--codility</title>
      <link>https://tmhm.github.io/2016/09/01/arrays--codility/</link>
      <pubDate>Thu, 01 Sep 2016 15:40:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/09/01/arrays--codility/</guid>
      <description>&lt;h2 id = &#34;1.2&#34;&gt;
lesson 2: &lt;i&gt;Arrays&lt;/i&gt;
&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;exercise:&lt;/li&gt;
&lt;li&gt;Problem: Given array A consisting of N integers, return the reversed array.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def myreverse(A):
    length = len(A)
    for i in xrange(length//2):
        A[i], A[length -i-1] = A[length - i-1], A[i]
    return A

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.2.1&#34;&gt;
1. CyclicRotation------[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Rotate an array to the right by a given number of steps.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A zero-indexed array A consisting of N integers is given. Rotation of the array means that each element is shifted right by one index, and the last element of the array is also moved to the first place.&lt;/p&gt;

&lt;p&gt;For example, the rotation of array A = [3, 8, 9, 7, 6] is [6, 3, 8, 9, 7]. The goal is to rotate array A K times; that is, each element of A will be shifted to the right by K indexes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def re_enumerate(seq):
    n = -1
    length = len(seq)
    for elem in reversed(seq):
        yield length + n, elem
        n = n - 1

def solution(A, K):
    length = len(A)
    if length &amp;lt; 2:
        return A
    shift_times = K%length
    #print shift_times
    tmp= A[-shift_times:]
    #print tmp
    tmp.extend(A[:- shift_times])
    return tmp
    #for idx, ai in re_enumerate(A):
    #    if idx &amp;gt;= shift_times:
    #        A[idx] = A[idx-shift_times]
    #
    #    else:
    #        A[idx] = tmp[idx]
    #return A

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;要注意边界条件，考虑数组的长度少于旋转的次数，以及只有一个元素和数组为空&lt;/li&gt;
&lt;li&gt;当有除法的时候，注意是否除以零&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A, K):
    # write your code in Python 2.7
    length = len(A)
    #print length
    #print K
    if K == 0 or length == 0 or length == 1:
        return A
    if K &amp;gt; length:
        K %= length

    #print K
    tmp = [0]*K
    #print tmp
    for i in xrange(K):
        tmp[i] = A[length - K + i]
    tmp.extend(A[:-K])
    return tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.2.2&#34;&gt;
2. OddOccurrencesInArray ---[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Find value that occurs in odd number of elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A non-empty zero-indexed array A consisting of N integers is given. The array contains an odd number of elements, and each element of the array can be paired with another element that has the same value, except for one element that is left unpaired.&lt;/p&gt;

&lt;p&gt;For example, in array A such that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      A[0] = 9  A[1] = 3  A[2] = 9
      A[3] = 3  A[4] = 9  A[5] = 7
      A[6] = 9
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;the elements at indexes 0 and 2 have value 9,&lt;/li&gt;
&lt;li&gt;the elements at indexes 1 and 3 have value 3,&lt;/li&gt;
&lt;li&gt;the elements at indexes 4 and 6 have value 9,&lt;/li&gt;
&lt;li&gt;the element at index 5 has value 7 and is unpaired.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解题思路：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将数组排序，相同的数会在一起，比较前后两个数是否相同&lt;/li&gt;
&lt;li&gt;偶数个数的，继续测试下一个数，找到单独的一个数，返回&lt;/li&gt;
&lt;li&gt;当直到数组最后，还有没有找到单独的一个元素，我们得返回最后一个元素，因为我们统计的一直的是last 元素&lt;/li&gt;
&lt;li&gt;注意临界条件，只有一个元素&lt;/li&gt;
&lt;li&gt;O(N)时间复杂度&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    if len(A) == 1:
        return A[0]
    A.sort()
    #print A
    last_a,cnt = A[0],1
    #print last_a
    for ai in A[1:]:
        if ai == last_a:
            cnt += 1
        else:
            if cnt%2 != 0:
                return last_a
            last_a,cnt = ai,1

    return A[-1]

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    if len(A) &amp;lt; 2:
        return A[0]
    A.sort()
    last_a, cnt = A[0], 1
    for a in A[1:]:
        if last_a == a:
            cnt += 1
        else:
            if cnt%2 == 0 :
                last_a, cnt = a, 1
            else:
                return last_a
    return A[-1]

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Iterations --codility</title>
      <link>https://tmhm.github.io/2016/09/01/iterations---codility/</link>
      <pubDate>Thu, 01 Sep 2016 15:35:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/09/01/iterations---codility/</guid>
      <description>&lt;h3 id = &#34;1.1&#34;&gt;
lesson 1：&lt;i&gt;Iterations&lt;/i&gt;
&lt;/h3&gt;

&lt;h4 id = &#34;1.1.1&#34;&gt;
1. BinaryGap-----[100%]
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Find longest sequence of zeros in binary representation of an integer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A binary gap within a positive integer N is any maximal sequence of consecutive zeros that is surrounded by ones at both ends in the binary representation of N.&lt;/p&gt;

&lt;p&gt;For example, number 9 has binary representation 1001 and contains a binary gap of length 2. The number 529 has binary representation 1000010001 and contains two binary gaps: one of length 4 and one of length 3. The number 20 has binary representation 10100 and contains one binary gap of length 1. The number 15 has binary representation 1111 and has no binary gaps.&lt;/p&gt;

&lt;p&gt;解题思路：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将整型数据转为二进制，然后利用python的split函数按‘1’分割，再用max函数找到最大的切片即可&lt;/li&gt;
&lt;li&gt;注意二进制为全1，或者第一位为1，后面全为0的数，e.g. 1, 100, 11111, 用log次的循环判定下即可&lt;/li&gt;
&lt;li&gt;满足于O(log(N))的时间复杂度&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;from math import log
def solution(N):

    #if N == 1:   #can belong to the next for i = 0
    #    return 0
    for i in xrange(int(log(N,2))+1):

        tmp = 2**i
        #print tmp
        if tmp == N+1 or tmp == N:
            return 0

    strb = bin(N).split(&amp;quot;1&amp;quot;)
    #print strb[1:-1]
        #last one can&#39;t included. e.g.1001000-&amp;gt;2, so [1:-1]
    if strb[1:-1] is None:
        #print &amp;quot;test&amp;quot;
        return 0
    return max([len(l) for l in strb[1:-1]])
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>codility lessons</title>
      <link>https://tmhm.github.io/2016/08/30/codility-lessons/</link>
      <pubDate>Tue, 30 Aug 2016 14:19:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/08/30/codility-lessons/</guid>
      <description>

&lt;pre&gt;&lt;code&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;http://yandex.st/highlightjs/6.2/styles/googlecode.min.css&amp;quot;&amp;gt;

&amp;lt;script src=&amp;quot;http://code.jquery.com/jquery-1.7.2.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;http://yandex.st/highlightjs/6.2/highlight.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;script&amp;gt;hljs.initHighlightingOnLoad();&amp;lt;/script&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
 $(document).ready(function() {
        $(&amp;quot;h2,h3,h4,h5,h6&amp;quot;).each(function(i,item){
        var tag = $(item).get(0).localName;
        $(item).attr(&amp;quot;id&amp;quot;,&amp;quot;wow&amp;quot;+i);
        $(&amp;quot;.newh2&amp;quot;).css(&amp;quot;margin-left&amp;quot;,0);
        $(&amp;quot;.newh3&amp;quot;).css(&amp;quot;margin-left&amp;quot;,20);
        $(&amp;quot;.newh4&amp;quot;).css(&amp;quot;margin-left&amp;quot;,40);
        $(&amp;quot;.newh5&amp;quot;).css(&amp;quot;margin-left&amp;quot;,60);
        $(&amp;quot;.newh6&amp;quot;).css(&amp;quot;margin-left&amp;quot;,80);
});
 });
&amp;lt;/script&amp;gt;
&amp;lt;div id=&amp;quot;category&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;hr /&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;#1&#34;&gt;codility lessons&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.1&#34;&gt;lesson 1: &lt;em&gt;Iterations&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1.1.1&#34;&gt;1. BinaryGap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.2&#34;&gt;lesson 2: &lt;em&gt;Arrays&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1.2.1&#34;&gt;1. CyclicRotation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.2.2&#34;&gt;2. OddOccurrencesInArray&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.3&#34;&gt;lesson 3: &lt;em&gt;Time complexity&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1.3.1&#34;&gt;1. TapeEquilibrium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.3.2&#34;&gt;2. FrogJmp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.3.3&#34;&gt;3. PermMissingElem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.4&#34;&gt;lesson 4: &lt;em&gt;counting elements&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1.4.1&#34;&gt;1. FrogRiverOne&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.4.2&#34;&gt;2. PermCheck&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.4.3&#34;&gt;3. MissingInteger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.4.4&#34;&gt;4. MaxCounters&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.5&#34;&gt;lesson 5: &lt;em&gt;prefix sums&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1.5.1&#34;&gt;1. PassingCars&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.5.2&#34;&gt;2. CountDiv&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.5.3&#34;&gt;3. GenomicRangeQuery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.5.4&#34;&gt;4. MinAvgTwoSlice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.6&#34;&gt;lesson 6: &lt;em&gt;sorting&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1.6.1&#34;&gt;1. Distinct&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.6.2&#34;&gt;2. MaxProductOfThree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.6.3&#34;&gt;3. Triangle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.6.4&#34;&gt;4. none&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.7&#34;&gt;lesson 7: &lt;em&gt;stacks and queues&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1.7.1&#34;&gt;1. none&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.7.2&#34;&gt;2. Nesting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.7.3&#34;&gt;3. none&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.4.4&#34;&gt;4. MaxCounters&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id = &#34;1&#34;&gt;
codility lessons
&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;切记临界点， 比如一个最小，最大的值， len(0), max() 无数据等&lt;/li&gt;
&lt;li&gt;仔细看好题意， 比如是要求从1 开始的list ，就不需要记最好的值，求长度了，只要记下最大值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id = &#34;1.1&#34;&gt;
lesson 1：&lt;i&gt;Iterations&lt;/i&gt;
&lt;/h2&gt;

&lt;h3 id = &#34;1.1.1&#34;&gt;
1. BinaryGap-----[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Find longest sequence of zeros in binary representation of an integer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;from math import log
def solution(N):
    # write your code in Python 2.7

    if N == 1:
        return 0
    for i in xrange(int(log(N,2))+1):

        tmp = 2**i
        #print tmp
        if tmp == N+1 or tmp == N:
            return 0

    strb = bin(N).split(&amp;quot;1&amp;quot;)
    #print strb[1:-1]
    if strb[1:-1] is None:
        #print &amp;quot;test&amp;quot;
        return 0
    return max([len(l) for l in strb[1:-1]])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id = &#34;1.2&#34;&gt;
lesson 2: &lt;i&gt;Arrays&lt;/i&gt;
&lt;/h2&gt;

&lt;h3 id = &#34;1.2.1&#34;&gt;
1. CyclicRotation------[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Rotate an array to the right by a given number of steps.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;
def re_enumerate(seq):
    n = -1
    length = len(seq)
    for elem in reversed(seq):
        yield length + n, elem
        n = n - 1

def solution(A, K):
    # write your code in Python 2.7
    length = len(A)
    if length &amp;lt; 2:
        return A
    shift_times = K%length
    #print shift_times
    tmp= A[-shift_times:]
    #print tmp
    tmp.extend(A[:- shift_times])
    return tmp
    #for idx, ai in re_enumerate(A):
    #    if idx &amp;gt;= shift_times:
    #        A[idx] = A[idx-shift_times]
    #
    #    else:
    #        A[idx] = tmp[idx]
    #return A
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.2.2&#34;&gt;
2. OddOccurrencesInArray ---[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Find value that occurs in odd number of elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    if len(A) == 1:
        return A[0]
    A.sort()
    #print A
    last_a,cnt = A[0],1
    #print last_a
    for ai in A[1:]:
        if ai == last_a:
            cnt += 1
        else:
            if cnt%2 != 0:
                return last_a
            last_a,cnt = ai,1

    return A[-1]

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id = &#34;1.3&#34;&gt;
lesson 3: &lt;i&gt;Time complexity&lt;/i&gt;
&lt;/h2&gt;

&lt;h3 id = &#34;1.3.1&#34;&gt;
1. TapeEquilibrium -----[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Minimize the value
|(A[0] + &amp;hellip; + A[P-1]) - (A[P] + &amp;hellip; + A[N-1])|.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7

    left,right =A[0], sum(A)-A[0]
    result = abs(right - left)

    for elem in A[1:-1]:
        left,right = left + elem, right - elem
        retmp = abs(right - left)
        if retmp &amp;lt; result:
            result = retmp
    return result
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.3.2&#34;&gt;
2. FrogJmp -----[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Count minimal number of jumps from position X to Y.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;def solution(X, Y, D):
    # write your code in Python 2.7
    if X == Y:
        return 0
    else:
        flag = (Y - X)%D
        ret = (Y - X)/D
        return ret if flag == 0 else ret + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.3.3&#34;&gt;
3. PermMissingElem -----[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Find the missing element in a given permutation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    if len(A) == 0:
        return 1
    elif len(A) == 1:
        return A[0]+1 if A[0] == 1 else A[0] -1
    A.sort()
    left = A[0]
    for elem in A[1:]:
        if elem == left + 1:
            left = elem
            continue
        else:
            return left + 1

    return A[-1]+1 if A[0] == 1 else A[0]-1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id = &#34;1.4&#34;&gt;
lesson 4: &lt;i&gt;counting elements&lt;/i&gt;
&lt;/h2&gt;

&lt;h3 id = &#34;1.4.1&#34;&gt;
1. FrogRiverOne----[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Find the earliest time when a frog can jump to the other side of a river.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;def solution(X, A):
    # write your code in Python 2.7
    ret = -1
    visited = set()
    for idx,elem in enumerate(A):
        visited.add(elem)
        if len(visited) == X:
            return idx
    return -1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.4.2&#34;&gt;
2. PermCheck----[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Check whether array A is a permutation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt;
仔细看好题意， 比如是要求从1 开始的list ，
就不需要记最好的值，求长度了，只要记下最大值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    #A.sort() # Nlog(N)
    if len(A) == 1:
        return 1 if (A[0] == 1) else 0

    sigle = set()
    #maxelem, minelem = A[0], A[0]   #needless minelem,owing to from 1 !!
    maxelem = A[0]
    for elem in A:
        if elem not in sigle:
            sigle.add(elem)
            if elem &amp;gt; maxelem:
                maxelem = elem
        else:
            #print &amp;quot;test&amp;quot;
            return 0
    #print sigle
    return 1 if (len(sigle) == maxelem) else 0

    #return 1 if (A[-1]-A[0]+1) == len(A) else 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.4.3&#34;&gt;
3. MissingInteger----[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Find the minimal positive integer not occurring in a given sequence.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt;
考虑到不能排序， 返回解一定会在1~len(所给数组)+1的区间。用map记录这些数据是否都在，不在的话，找最小的空缺，都在的时候就是map/list最后一个数加1.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    length = len(A)
    tmp = [True]*(length + 1)
    #print tmp
    for elem in A:
        if 0 &amp;lt; elem &amp;lt; length+1:
            tmp[elem-1] = False
    for idx,elem in enumerate(tmp):
        if elem == True:
            return idx+1
    return length +1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.4.4&#34;&gt;
4. MaxCounters
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Calculate the values of counters after applying all alternating operations:
increase counter by 1; set value of all counters to current maximum.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;解法一&#34;&gt;解法一：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Detected time complexity: O(N*M)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(N, A):
    # write your code in Python 2.7
    ret = [0]*N
    #print ret

    for elem in A:
        if elem &amp;lt; (N + 1):
            #print elem
            #print ret
            ret[int(elem -1)] += 1
        else:
            #tmp = max(ret)
            #print &amp;quot;tmp&amp;quot;,tmp
            #ret = [tmp]*N
            ret = [max(ret)]*N
            #print &amp;quot;ret&amp;quot;,ret
    return ret
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;解法二&#34;&gt;解法二&lt;/h5&gt;

&lt;p&gt;[100%] MaxCounters
&amp;gt;
Calculate the values of counters after applying all alternating operations: increase counter by 1; set value of all counters to current maximum.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt;
分别记录上次update的值，在update的基础上，再记录当前最大值。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Detected time complexity:
O(N + M)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(N, A):
    # write your code in Python 2.7
    ret = [0]*N

    maxOfArray = 0
    last_update = 0
    tn = N + 1
    for elem in A:

        if elem &amp;lt; tn:
            if ret[elem -1] &amp;lt; last_update:
                ret[elem -1] = last_update

            ret[elem -1] += 1
            if ret[elem -1] &amp;gt; maxOfArray:
                maxOfArray = ret[elem -1]
        else:
            last_update = maxOfArray
            #print &amp;quot;last_update&amp;quot;,last_update
            #ret = [maxOfArray]*N

            #print &amp;quot;ret&amp;quot;,ret
    for elem in xrange(N):
        if ret[elem] &amp;lt; last_update:
            ret[elem] = last_update
    return ret
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id = &#34;1.5&#34;&gt;
lesson 5: &lt;i&gt;prefix sums&lt;/i&gt;
&lt;/h2&gt;

&lt;h3 id = &#34;1.5.1&#34;&gt;
1. &lt;i&gt; PassingCars&lt;/i&gt;
&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;[100%]
&amp;gt;
Count the number of passing cars on the road.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Detected time complexity:
O(N)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    total = sum(A)
    ret = 0
    for elem in A:
        if elem == 0:
            ret += total
            if ret &amp;gt; 1000000000:
                return -1
        else:
            total -= elem
    return ret
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.5.2&#34;&gt;
2. &lt;i&gt; CountDiv &lt;/i&gt;
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Compute number of integers divisible by k in range [a..b].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;countdiv-solution-1&#34;&gt;CountDiv solution 1&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;test score 67%&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A, B, K):
    # write your code in Python 2.7
    ret = 0
    if A%K == 0:
        ret += 1
    if A != B and B%K == 0 :
        ret += 1

    if (B-A)%K == 0:
        if ret == 2:
            ret += ((B-A)/K - 1)
        else:
            ret += (B-A)/K
    else:
        ret += (B-A)/K
    return ret
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;countdiv-solution-2&#34;&gt;CountDiv solution 2&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A, B, K):
    # write your code in Python 2.7
    ret = 0
    ra = -1 if A == 0 else (A - 1)/K
    rb = B/K

    return rb -ra

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution-3&#34;&gt;solution 3&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A, B, K):
    # write your code in Python 2.7
    c = 1 if A%K == 0 else 0
    return B/K -A/K + c

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.5.3&#34;&gt;
3. GenomicRangeQuery
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Find the minimal nucleotide from a range of sequence DNA.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;解法一-1&#34;&gt;解法一：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Test score  37%&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def getMinFactor(S,l,i,j):
    if j == (l-1):
        tmp = set(S[i:-1])  # error ，should be s[i:]
    else:
        tmp = set(S[i:(j+1)])
    if &#39;A&#39; in tmp:
        return 1
    elif &#39;C&#39; in tmp:
        return 2
    elif &#39;G&#39; in tmp:
        return 3
    else:
        return 4

def solution(S, P, Q):
    # write your code in Python 2.7
    length = len(S)
    result = []
    for x,y in zip(P,Q):
        #print x,y
        result.append(getMinFactor(S,length,x,y))
    return result
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;解法二-1&#34;&gt;解法二：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%
&amp;gt; used each list to save that states whether has element or not&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def calcPrefixSum(s,l):
    category_a, category_c, category_g = [0]*(l+1), [0]*(l+1), [0]*(l+1)
    for i in xrange(l):
        a,c,g = 0,0,0
        if s[i] == &#39;A&#39;:
            a = 1
        elif s[i] == &#39;C&#39;:
            c = 1
        elif s[i] == &#39;G&#39;:
            g = 1
        category_a[i+1] += category_a[i] + a
        category_c[i+1] += category_c[i] + c
        category_g[i+1] += category_g[i] + g

    return category_a, category_c, category_g

def solution(S, P, Q):
    # write your code in Python 2.7

    length = len(S)
    result = []
    a, c, g =  calcPrefixSum(S,length)
    for x,y in zip(P,Q):
        #print x,y
        #result.append(getMinFactor(S,length,x,y))
        if a[y+1] - a[x] &amp;gt; 0:
            result.append(1)
        elif c[y+1] - c[x] &amp;gt; 0:
            result.append(2)
        elif g[y+1] - g[x] &amp;gt; 0:
            result.append(3)
        else:
            result.append(4)

    return result
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.5.4&#34;&gt;
4. MinAvgTwoSlice
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Find the minimal average of any slice containing at least two elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt; transfer to 2/3&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    length = len(A)
    minStartPos = 0
    minSum = (A[0] + A[1])/2.0

    for i in xrange(length - 2):
        tmp = (A[i] + A[i+1])/2.0
        if tmp &amp;lt; minSum:
            minSum = tmp
            minStartPos = i
        tmp = (tmp*2 + A[i+2])/3.0
        if tmp &amp;lt; minSum:
            minSum = tmp
            minStartPos = i
    if (A[-1] + A[-2])/2.0 &amp;lt; minSum:
        minStartPos = length - 2

    return minStartPos
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id = &#34;1.6&#34;&gt;
lesson 6: &lt;i&gt;sorting&lt;/i&gt;
&lt;/h2&gt;

&lt;h3 id = &#34;1.6.1&#34;&gt;
1. Distinct
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Compute number of distinct values in an array.
- Test score 100%&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    Aset = set(A)
    return len(Aset)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.6.2&#34;&gt;
2. MaxProductOfThree
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Maximize A[P] * A[Q] * A[R] for any triplet (P, Q, R).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;solution-1&#34;&gt;solution 1&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;O(N)&lt;/li&gt;
&lt;li&gt;Test score  100% OJ test is O(N * log(N))&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    ma1, ma2, ma3 = -1000, -1000, -1000
    mi1, mi2 = 1000, 1000
    for elem in A:
        if elem &amp;gt; ma1:
            ma1, ma2, ma3 = elem, ma1, ma2
        elif elem &amp;gt; ma2:
            ma2, ma3 = elem, ma2
        elif elem &amp;gt; ma3:
            ma3 = elem

        if elem &amp;lt; mi1:
            mi1,mi2 = elem, mi1
        elif elem &amp;lt; mi2:
            mi2 = elem
    a, b = ma1*ma2*ma3, ma1*mi1*mi2
    return a if a &amp;gt; b else b
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution-2&#34;&gt;solution 2&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;just need return the value of the max product,&lt;/li&gt;

&lt;li&gt;&lt;p&gt;so, we can just consider the first or last teiplet, after sort&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Detected time complexity: O(N * log(N))&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    A.sort()
    return max(A[0]*A[1]*A[-1], A[-1]*A[-2]*A[-3])

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.6.3&#34;&gt;
3. Triangle
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Determine whether a triangle can be built from a given set of edges.
&lt;a href=&#34;https://codesays.com/2014/solution-to-triangle-by-codility/&#34;&gt;https://codesays.com/2014/solution-to-triangle-by-codility/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    length = len(A)
    if length &amp;lt; 3:
        return 0
    A.sort()
    for idx in xrange(0,length -2):
        if A[idx]+A[idx + 1] &amp;gt; A[idx + 2]:
            return 1
    return 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id = &#34;1.7&#34;&gt;
lesson 7: &lt;i&gt;stacks and queues&lt;/i&gt;
&lt;/h2&gt;

&lt;h3 id = &#34;1.7.2&#34;&gt;
2. Nesting
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Determine whether given string of parentheses is properly nested.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(S):
    # write your code in Python 2.7
    tmp = 0
    for elem in S:
        if elem == &amp;quot;(&amp;quot;:
            tmp += 1
        elif elem == &amp;quot;)&amp;quot;:
            tmp -= 1
            if tmp &amp;lt; 0:
                return 0
    if tmp == 0:
        return 1
    else:
        return 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.7.4&#34;&gt;
4. StoneWall
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Cover &amp;laquo;Manhattan skyline&amp;raquo; using the minimum number of rectangles.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(H):
    # write your code in Python 2.7
    cnt = 0
    stack = []
    for elem in H:
        while len(stack)!= 0 and stack[-1] &amp;gt; elem:
            stack.pop()

        if len(stack) != 0 and stack[-1] == elem:
            pass
        else:
            stack.append(elem)
            cnt += 1
    return cnt

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>按位操作</title>
      <link>https://tmhm.github.io/2016/08/30/%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 30 Aug 2016 10:54:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/08/30/%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C/</guid>
      <description>

&lt;h3 id=&#34;异或&#34;&gt;异或&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;异或自己 变成零&lt;/li&gt;
&lt;li&gt;异或零，值不变&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;与&#34;&gt;与 &amp;amp;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;递归与自己的减一按位与，返回的是该数化为二进制数后，数字1的个数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;int fun(int x){
    int c = 0;
    while(x){
        c++;
        x = x&amp;amp;(x-1);
        cout&amp;lt;&amp;lt; x &amp;lt;&amp;lt; endl;
    }
    return c;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>数学随记（转）</title>
      <link>https://tmhm.github.io/2016/08/30/%E6%95%B0%E5%AD%A6%E9%9A%8F%E8%AE%B0%E8%BD%AC%E8%BD%BD/</link>
      <pubDate>Tue, 30 Aug 2016 10:50:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/08/30/%E6%95%B0%E5%AD%A6%E9%9A%8F%E8%AE%B0%E8%BD%AC%E8%BD%BD/</guid>
      <description>

&lt;h3 id=&#34;数学随记&#34;&gt;数学随记&lt;/h3&gt;

&lt;p&gt;转载自：&lt;a href=&#34;http://www.matrix67.com/blog/archives/4294&#34;&gt;随记：我们需要怎样的数学教育？&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;虚数i&#34;&gt;虚数i&lt;/h3&gt;

&lt;p&gt;虚数是什么？&lt;/p&gt;

&lt;p&gt;为什么要承认虚数？&lt;/p&gt;

&lt;p&gt;虚数怎么就表示旋转了？&lt;/p&gt;

&lt;p&gt;其实，人们建立复数理论，并不是因为人们有时需要处理根号里是负数的情况，而是因为下面这个不可抗拒的理由：如果承认虚数，那么 n 次多项式就会有恰好 n 个根，数系一下子就如同水晶球一般的完美了。&lt;/p&gt;

&lt;p&gt;但复数并不能形象地反映在数轴上，这不仅是因为实数在数轴上已经完备了，还有另外一个原因：没有什么几何操作连做两次就能实现取相反数。比如，“乘以 3”就代表数轴上的点离原点的距离扩大到原来的三倍，“3 的平方”，也就是“乘以 3 再乘以 3”，就是把上述操作连做两次，即扩大到 9 倍。同样地，“乘以 -1”表示把点翻折到数轴另一侧，“-1 的平方”就会把这个点又翻回来。&lt;/p&gt;

&lt;p&gt;但是，怎么在数轴上表示“乘以 i ”的操作？换句话说，什么操作连做两次能够把 1 变成 -1 ？一个颇具革命性的创意答案便是，把这个点绕着原点旋转 90 度。转 90 度转两次，自然就跑到数轴的另一侧了。&lt;/p&gt;

&lt;p&gt;没错，这就把数轴扩展到了整个平面，正好解决了复数没地方表示的问题。于是，复数的乘法可以解释为缩放加旋转，复数本身自然也就有了 z = r (cosθ + sinθi) 的表示方式。顺着这个道理推下去，一切都顺理成章了。复数不但有了几何解释，有时还能更便捷地处理几何问题&lt;/p&gt;

&lt;h2 id=&#34;线性代数&#34;&gt;线性代数&lt;/h2&gt;

&lt;p&gt;此处&lt;a href=&#34;http://mathoverflow.net/questions/7584/what-are-the-most-misleading-alternate-definitions-in-taught-mathematics&#34;&gt;网页&lt;/a&gt;，有人一语道破线性代数的真谛。
就好像把 x 变成 2 x 一样，我们经常需要把 (x, y) 变成 (2 x + y, x – 3 y) 之类的东西，这就叫做线性变换。&lt;/p&gt;

&lt;p&gt;于是才想到定义矩阵乘法，用于表示一切线性变换。几何上看，把平面上的每个点 (x, y) 都变到 (2 x + y, x – 3 y) 的位置上去，效果就相当于对这个平面进行了一个“线性的拉扯”。&lt;/p&gt;

&lt;p&gt;矩阵的乘法，其实就是多个线性变换叠加的效果，它显然满足结合律，但不满足交换律。&lt;/p&gt;

&lt;p&gt;主对角线全是 1 的矩阵所对应的线性变换其实就是不变的意思，因此它叫做单位矩阵。&lt;/p&gt;

&lt;p&gt;矩阵 A 乘以矩阵 B 得单位矩阵，就是做完线性变换 A 后再做一次线性变换 B 就又变回去了的意思，难怪我们说矩阵 B 是矩阵 A 的逆矩阵。&lt;/p&gt;

&lt;p&gt;课本上对行列式的定义千奇百怪，又是什么递归，又是什么逆序对，还编写口诀帮助大家记忆。&lt;/p&gt;

&lt;p&gt;其实，行列式的真正定义就一句话：&lt;strong&gt;每个单位正方形在线性变换之后的面积&lt;/strong&gt;。因此，单位矩阵的行列式当然就为 1，某行全为 0 的行列式显然为 0 （因为某一维度会被无视掉，线性变换会把整个平面压扁）， |A·B| 显然等于 |A|·|B| 。行列式为 0 ，对应的矩阵当然不可逆，因为这样的线性变换已经把平面压成一条线了，什么都不能把它变回去了。当然，更高阶的矩阵就对应了更高维的空间。&lt;/p&gt;

&lt;p&gt;一瞬间，所有东西都解释清楚了。&lt;/p&gt;

&lt;p&gt;最近看到李泽湘教授的一句话，“很多工业界用的算法是错的，所以很难做到质量标准的提升，和工匠的定位。”&lt;/p&gt;

&lt;p&gt;做技术研究，做到最后发现都是数学问题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>数据的对齐</title>
      <link>https://tmhm.github.io/2016/08/30/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%B9%E9%BD%90/</link>
      <pubDate>Tue, 30 Aug 2016 10:50:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/08/30/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%B9%E9%BD%90/</guid>
      <description>

&lt;p&gt;cpu在读写内存的时候，如果所给的地址是机器字长的整数倍，则操作效率会比较高，这可以称之为地址的对齐。&lt;/p&gt;

&lt;p&gt;在一般的32bits机器上，地址对齐的界线默认是4的整数倍。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct my_struct {
char ch1;  //1字节
            char ch2; //1字节
            int n; //4字节
            char ch3; 1字节
};//整个结构体在32bits系统占12个字节
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对结构体类型采用sizeof操作符，得到的是结构体占用的内存字节数，包括所有的空闲字节，显然，这个值并不一定等于它的所有成员的大小之和。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#pragma pack(1) //将地址对齐界线改为1的整数
struct my_struct {
	char ch1;  //1字节
	char ch2; //1字节
	int n; //4字节
	char ch3; 1字节
};//整个结构体占7个字节
#pragma pack() //将地址对齐界线改回原来的值
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;对齐规则-参考-http-www-cnblogs-com-graphics-archive-2010-08-12-1797953-html&#34;&gt;对齐规则&lt;a href=&#34;http://www.cnblogs.com/graphics/archive/2010/08/12/1797953.html&#34;&gt;参考&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;该博文也给出了#pragma pack(show) 和#pragma pack(num)的说明以及在VS中的设置；默认num＝8.&lt;/p&gt;

&lt;p&gt;这内存宝贵的应用场合，比如嵌入式系统，一般要考虑对齐，一般原则，可以是从小到大排，把多个小字节变量放一起，并且跟对齐的大小对齐。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一般来说，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;结构体的对齐规则是先按数据类型自身进行对齐，这里需要比较＃pragma pack(num)中num的数值和数据类型的大小，取小的作为基准；&lt;/li&gt;
&lt;li&gt;然后再按整个结构体进行对齐，对齐值必须是2的幂，比如1，2， 4， 8， 16。准确来讲，&lt;strong&gt;结构的总大小是其成员中最大类型的sizeof(该类型)整数倍。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果一个类型按n字节对齐，那么该类型的变量起始地址必须是n的倍数。比如int按四字节对齐，那么int类型的变量起始地址一定是4的倍数，比如0x0012ff60，0x0012ff48等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;查看系统是多少位的&#34;&gt;查看系统是多少位的&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;file /sbin/init&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;/sbin/init: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=7a4c688d009fc1f06ffc692f5f42ab09e68582b2, stripped
&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;file /bin/ls&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;/bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=3bf9ca54ea5e261943509c2e47bc814bb1248921, stripped
&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;uname -a&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;Linux ubuntu 3.13.0-79-generic #123-Ubuntu SMP Fri Feb 19 14:27:58 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux
&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;cat /proc/version&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;Linux version 3.13.0-79-generic (buildd@lcy01-24) (gcc version 4.8.2 (Ubuntu 4.8.2-19ubuntu1) ) #123-Ubuntu SMP Fri Feb 19 14:27:58 UTC 2016
&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;cat /etc/issue&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;Ubuntu 15.04 \n \l
&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;测试数据所占字节&#34;&gt;测试数据所占字节&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;因为在数据对齐的时候需要考虑是在什么系统下，各数据类型所占字节大小，纠正网上一些有问题的解答，比如long是只占4bits的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;cout &amp;lt;&amp;lt; &amp;quot;char: &amp;quot; &amp;lt;&amp;lt; sizeof(char) &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;quot;short: &amp;quot; &amp;lt;&amp;lt; sizeof(short) &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;quot;int: &amp;quot; &amp;lt;&amp;lt; sizeof(int) &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;quot;long: &amp;quot; &amp;lt;&amp;lt; sizeof(long) &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;quot;unsigned long: &amp;quot; &amp;lt;&amp;lt; sizeof(unsigned long) &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;quot;long long: &amp;quot; &amp;lt;&amp;lt; sizeof(long long) &amp;lt;&amp;lt; endl;
//在vc6.0下不支持 long long 数据类型。
cout &amp;lt;&amp;lt; &amp;quot;double: &amp;quot; &amp;lt;&amp;lt; sizeof(double) &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;quot;char*: &amp;quot; &amp;lt;&amp;lt; sizeof(char*) &amp;lt;&amp;lt; endl;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;32bit windows xp (VC6.0 IDE 32bits) 测试：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    char: 1
    short: 2
    int: 4
    long: 4
    unsigned long: 4
    double: 8
    char*: 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;64bit windows 10 (Dev-C++ 5.11 64bits的)测试：&lt;/strong&gt;
&amp;gt; Window系统下的MinGW，总是编译为32位代码。因为MinGW只支持32位代码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    char: 1
    short: 2
    int: 4
    long: 4             // 不知道为什指针又是8字节的！！！
    unsigned long: 4
    long long: 8
    double: 8
    char*: 8            //指针所占内存大小有区别，每字节8位，跟总线搭配
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;64bit ubuntu15.04 (g++ 4.8.4)测试：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    char: 1
    short: 2
    int: 4
    long: 8         // 8 !!
    unsigned long: 8
    long long: 8
    double: 8
    char*: 8    //指针所占内存大小有区别，每字节8位，跟总线搭配
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;地址对齐&lt;/strong&gt;的概念：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;由于硬件设计的特点，CPU在读写内存时，如果所给的地址是机器字长的整数倍，则操作效率会比较高。&lt;/li&gt;
&lt;li&gt;有的CPU甚至不支持读写地址不对齐的内存单元。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为了提高程序运行的效率，编译器会尽量避免一个变量（包括结构体成员）的存储空间跨越地址对齐的界线。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;实验（64bits 环境）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
#include &amp;lt;iostream&amp;gt;
using namespace std;
typedef struct{ 

}test_null;          // test 1

typedef struct{
    double d1;  //8
    char c1;    //1
    short s1;   //补1+2
    char ch2;   //1
    int i1;     //补3+4+补4  =&amp;gt; 24
}testdouble;        // test 2   

typedef struct{
    int d1;     //4
    char c1;    //1
    short s1;   //fill 1 + 2
    char ch2;   //1
    int i1;     //fill 3 + 4  =&amp;gt; 16
}testint;           // test 3

#pragma pack(2)
typedef struct{
    int d1;     //4
    char c1;    //1
    short s1;   //fill 1 +2
    char ch2;   //1
    int i1;     //fill 1 + 4  =&amp;gt; 14
}testint2; 

class BU{
     int number;                //4
     union UBffer{
         char buffer[13];//13
         int number;    //4
     }ubuf;                     //-&amp;gt;13  
     void foo(){}               //0
     typedef char*(*f)(void*);  //0
     enum{hdd,ssd,blueray}disk; //fill 1 + 4
     int* a;                    //8         =&amp;gt; 30
}bu;                // test 4
#pragma(4)

#pragma pack(1) //
 typedef struct {
    char ch1;   //1
    char ch2;   //1
    int n;      //4
    char ch3;   //1
}stch3_1;   // -&amp;gt; 7

class clt_1{
    char ch1;   //1
    int a;      //4
    short b;    //2
    char c;     //1
    stch3_1 st1;//7 =&amp;gt; 15
}st_inside;         // test 5
#pragma pack(4) //

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;输出控制:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;64bits win10（GCC 4.9.2）测试结果：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    test null struct: 1
    sizeof(bu): 30
    sizeof(testdouble):24
    sizeof(testint):16
    sizeof(testint2):14
    st_inside: 15,  inside stch3_1: 7
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;64bits ubuntu (gcc version 4.8.4 ) 测试结果：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    test null struct: 1
    sizeof(bu): 30
    sizeof(testdouble):24
    sizeof(testint):16
    sizeof(testint2):14
    st_inside: 15,  inside stch3_1: 7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;空的结构体在linux系统中并不是0，它和windows 一样，均是占一个字节；&lt;/li&gt;
&lt;li&gt;long类型在32bits 是占4个字节，64bits 编译器中是8字节；&lt;/li&gt;
&lt;li&gt;在32bits 系统中指针是4字节，64bits系统占8字节，由于总线物理跟指针的空间是一样大的：4*8 -&amp;gt; 32 ; 8*8 -&amp;gt; 64 .&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>比较字符串（包含以及变位词）</title>
      <link>https://tmhm.github.io/2016/06/04/%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB%E4%BB%A5%E5%8F%8A%E5%8F%98%E4%BD%8D%E8%AF%8D/</link>
      <pubDate>Sat, 04 Jun 2016 09:48:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/06/04/%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB%E4%BB%A5%E5%8F%8A%E5%8F%98%E4%BD%8D%E8%AF%8D/</guid>
      <description>

&lt;h5 id=&#34;description:90262507d577af3b6d8bd16478af3fcf&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;Write a method anagram(s,t) to decide if two strings are anagrams or not.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is Anagram?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Two strings are anagram if they can be the same after change the order of characters.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;example:90262507d577af3b6d8bd16478af3fcf&#34;&gt;Example&lt;/h5&gt;

&lt;p&gt;Given s = &amp;laquo;abcd&amp;raquo;, t = &amp;laquo;dcab&amp;raquo;, return true.&lt;/p&gt;

&lt;p&gt;Given s = &amp;laquo;ab&amp;raquo;, t = &amp;laquo;ab&amp;raquo;, return true.&lt;/p&gt;

&lt;p&gt;Given s = &amp;laquo;ab&amp;raquo;, t = &amp;laquo;ac&amp;raquo;, return false.&lt;/p&gt;

&lt;h5 id=&#34;solution:90262507d577af3b6d8bd16478af3fcf&#34;&gt;solution：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;class Solution:
    &amp;quot;&amp;quot;&amp;quot;
    @param s: The first string
    @param b: The second string
    @return true or false
    &amp;quot;&amp;quot;&amp;quot;
    def countchar(self,ch):
        result = {}
        for item in ch:
            ikey = ord(item)
            if result.has_key(ikey):
                result[ikey] +=1
            else:
                result.setdefault(ikey,0)
        return result

    def anagram(self, s, t):
        # write your code here
        dicS = self.countchar(s)
        dicT = self.countchar(t)
        if not cmp(dicS,dicT):
             return True
        else:
            return False
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;compare-strings:90262507d577af3b6d8bd16478af3fcf&#34;&gt;Compare Strings&lt;/h4&gt;

&lt;h5 id=&#34;description-1:90262507d577af3b6d8bd16478af3fcf&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;Compare two strings A and B, determine whether A contains all of the characters in B.&lt;/p&gt;

&lt;p&gt;The characters in string A and B are all Upper Case letters.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Notice&lt;/strong&gt;
&amp;gt;The characters of B in A are not necessary continuous or ordered.&lt;/p&gt;

&lt;h5 id=&#34;example-1:90262507d577af3b6d8bd16478af3fcf&#34;&gt;Example&lt;/h5&gt;

&lt;p&gt;For A = &amp;laquo;ABCD&amp;raquo;, B = &amp;laquo;ACD&amp;raquo;, return true.&lt;/p&gt;

&lt;p&gt;For A = &amp;laquo;ABCD&amp;raquo;, B = &amp;laquo;AABC&amp;raquo;, return false.&lt;/p&gt;

&lt;h5 id=&#34;solution-1:90262507d577af3b6d8bd16478af3fcf&#34;&gt;solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;class Solution:
    &amp;quot;&amp;quot;&amp;quot;
    @param A : A string includes Upper Case letters
    @param B : A string includes Upper Case letters
    @return :  if string A contains all of the characters in B return True else return False
    &amp;quot;&amp;quot;&amp;quot;
    # used a list with 26 iterm to save the number of each alphabet

    def compareStrings(self, A, B):
        # write your code here
        if B is None:
            return True
        elif A is None:
            return False

        CntA = self.countString(A)
        CntB = self.countString(B)

        for order in range(ord(&amp;quot;Z&amp;quot;)-ord(&amp;quot;A&amp;quot;) + 1):
            if CntA[order] &amp;lt; CntB[order]:
                return False

        return True

    def countString(self,string):
        count = []
        for item in range(ord(&amp;quot;Z&amp;quot;)-ord(&amp;quot;A&amp;quot;) + 1):
            count.append(0)
        for item in string:
            count[ord(item) - ord(&amp;quot;A&amp;quot;)] +=1
        return count
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>统计学习笔记（0）</title>
      <link>https://tmhm.github.io/2016/04/20/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B00/</link>
      <pubDate>Wed, 20 Apr 2016 15:26:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/04/20/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B00/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;监督学习 （supervised learning）&lt;/li&gt;
&lt;li&gt;非监督学习 （unsupervised learning）&lt;/li&gt;
&lt;li&gt;半监督学习 （semi-supervised learning）&lt;/li&gt;
&lt;li&gt;强化学习 （reinforcement learning）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;一直以为强化学习不属于统计学习的范畴，看来过去臆想了。&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;监督学习基本概念:01aa4df5ab2620b953a14d2f7f42805e&#34;&gt;监督学习基本概念&lt;/h3&gt;

&lt;h4 id=&#34;输入-特征-输出空间:01aa4df5ab2620b953a14d2f7f42805e&#34;&gt;输入、特征、输出空间&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;输入与输出的所有值分别称之为&lt;strong&gt;输入空间&lt;/strong&gt;和&lt;strong&gt;输出空间&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;所有特征向量存在的空间称为&lt;strong&gt;特征空间&lt;/strong&gt;，特征空间的每一维对应于一个特征；&lt;/li&gt;
&lt;li&gt;有时，输入空间会和特征空间一致；有时会不同，输入空间往往会经过某些变换将输入空间映射到特征空间；&lt;/li&gt;
&lt;li&gt;模型实际是都是定义在特征空间上的；&lt;/li&gt;
&lt;li&gt;人们根据输入和输出变量的不同类型来*区分不同的预测任务*：

&lt;ul&gt;
&lt;li&gt;输入和输出均为连续变量的预测问题称之为&lt;strong&gt;回归问题&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;输出为有限个离散变量的预测问题称之为&lt;strong&gt;分类问题&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;输入和输出均为变量序列的预测问题称之为&lt;strong&gt;标注问题&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;联合概率分布:01aa4df5ab2620b953a14d2f7f42805e&#34;&gt;联合概率分布&lt;/h4&gt;

&lt;p&gt;监督学习假设输入和输出遵循联合概率分布$P(X,Y)$.&lt;/p&gt;

&lt;h4 id=&#34;假设空间:01aa4df5ab2620b953a14d2f7f42805e&#34;&gt;假设空间&lt;/h4&gt;

&lt;p&gt;监督学习的目的在于学习一个有输入到输出的映射，这一映射由模型来表示。
模型属于由输入空间到输出空间的映射的集合，这一集合就是&lt;strong&gt;假设空间（hypothesis space）&lt;/strong&gt;，假设空间的确定意味着学习范围的确定。&lt;/p&gt;

&lt;p&gt;监督学习的模型可以是概率模型或非概率模型，用条件概率分布或决策函数表示。&lt;/p&gt;

&lt;h4 id=&#34;问题形式化:01aa4df5ab2620b953a14d2f7f42805e&#34;&gt;问题形式化&lt;/h4&gt;

&lt;p&gt;监督学习分学习和预测两个过程。学习过程是利用训练数据集学习一个模型，再用学习到的模型对测试样本进行预测，即预测过程。&lt;/p&gt;

&lt;p&gt;一个具体的模型$y=f(x)$,对一个输入$x_i$,可以产生一个输出$f(x_i)$,而训练模型中对应的输出是$y_i$,如果这个模型训练的足够好，有很好的预测能力，则其训练样本的输出$y_i$和模型的输出$f(x_i)$之间的差就应该足够小。学习系统就是通过不断尝试，选取最好的模型，以便对训练数据集具有最好的预测，同时对未知的测试数据集的预测也有尽可能好的推广，即泛化能力。&lt;/p&gt;

&lt;h3 id=&#34;统计学习三要素:01aa4df5ab2620b953a14d2f7f42805e&#34;&gt;统计学习三要素&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;模型

&lt;ul&gt;
&lt;li&gt;模型的假设空间包含所有可能的条件概率或决策函数&lt;/li&gt;
&lt;li&gt;参数空间&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;策略
（学习的准则）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;损失函数和风险函数&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;0-1、 平方、 绝对、 对数损失函数&lt;/li&gt;
&lt;li&gt;损失函数的期望，即平均意义下的损失，称之为风险函数或期望损失&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;经验风险最小化与结构风险最小化&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;经验最小化的策略认为经验最小的模型是最优的，当样本数量很小时会出现“过拟合”&lt;/li&gt;
&lt;li&gt;结构最小化是为了防止“过拟合”提出，其等价于正则化。结构风险在经验风险上加上表示模型复杂度的正则项或者惩罚项&lt;/li&gt;
&lt;li&gt;$\frac{1}{N} \sum_{i=1}^{N} L(y_i,f(x_i)) +\lambda \ast J(f)$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;$J(f)$为模型的复杂度，模型越复杂，复杂度越大，即复杂度表示了对复杂模型的惩罚，$\lambda$系数 大于0， 用以权衡经验风险和模型复杂度。结构风险小需要经验风险与模型复杂度同时小。&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;算法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;统计学习问题归结为最优化问题&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;模型的评估与模型选择:01aa4df5ab2620b953a14d2f7f42805e&#34;&gt;模型的评估与模型选择&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;一般考虑到&lt;strong&gt;训练误差&lt;/strong&gt;和&lt;strong&gt;测试误差&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;避免过拟合&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;正则化与交叉验证:01aa4df5ab2620b953a14d2f7f42805e&#34;&gt;正则化与交叉验证&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;正则项一般有1-范数和2-范数&lt;/li&gt;

&lt;li&gt;&lt;p&gt;交叉验证&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;简单交叉验证，即随机将已知数据分2部分，分别作为训练和测试，然后将训练集在各种参数条件下训练，最后在测试集上评估，选出测试误差最小的模型；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;S折交叉验证，首先随机将数据切分为S个互不相交的大小相同的子集，然后用S-1个子集用于训练，余下的作为测试，重复选择S次，最后选择S次测试中平均测试误差最小的模型&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;留一交叉验证，S折交叉验证的特殊情形S=N，N为给定数据集的容量，即每次只有一个数据样本用于测试。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;泛化能力:01aa4df5ab2620b953a14d2f7f42805e&#34;&gt;泛化能力&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;即模型对未知数据的预测能力。&lt;/li&gt;
&lt;li&gt;理论上可以通过泛化误差上界的大小来进行分析。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;生成模型与判别模型:01aa4df5ab2620b953a14d2f7f42805e&#34;&gt;生成模型与判别模型&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;根据采用的方式是生成方法和判别方法而来。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生成方法&lt;/strong&gt;是由数据学习联合概率分布，然后求得条件概率分布作为模型
    * 典型有：朴素贝叶斯法和隐马尔科夫模型&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;判别方法&lt;/strong&gt;是由数据直接学习决策函数或者条件概率分布作为模型
    * 典型有：K近邻，感知机，决策树，逻辑回归，最大熵模型，SVM，提升方法（AdaBoost），条件随机场等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;区别：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;生成方法可以还原出联合概率分布，判别则不行；&lt;/li&gt;
&lt;li&gt;生成方法学习的收敛速度更快&lt;/li&gt;
&lt;li&gt;当存在隐变量，仍可以用生成方法，而此时判别方法行不通&lt;/li&gt;
&lt;li&gt;判别方法直接学习条件概率或决策函数，直接预测，往往学习的准确率更高；由于直接学习，可以对数据进行各种程度上的抽象、定义特征并使用特征，也可以简化学习问题&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;面向问题:01aa4df5ab2620b953a14d2f7f42805e&#34;&gt;面向问题&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;分类问题&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;指标:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TP&amp;ndash;将正类分为正的；&lt;/li&gt;
&lt;li&gt;FN&amp;ndash;将正类分为负的；&lt;/li&gt;
&lt;li&gt;FP&amp;ndash;将负类分为正的；&lt;/li&gt;

&lt;li&gt;&lt;p&gt;TN&amp;ndash;将负类分为负的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;精确率 P = TP/(TP+FP)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;召回率 R = TP/(TP+FN)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;以上两者的调和均值 2/F = 1/P + 1/R&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;标注问题&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;回归问题&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一元回归和多元回归&lt;/li&gt;
&lt;li&gt;线性和非线性&lt;/li&gt;
&lt;li&gt;常用损失函数&amp;ndash;平方损失函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;非监督学习:01aa4df5ab2620b953a14d2f7f42805e&#34;&gt;非监督学习&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;数据没有类别信息，也不给定目标值&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;典型代表:01aa4df5ab2620b953a14d2f7f42805e&#34;&gt;典型代表：&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;聚类&lt;/strong&gt;将数据集合分成由类似的对象组成的多个类&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;密度估计&lt;/strong&gt;用于寻找数据统计值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;降维&lt;/strong&gt;，用于展示数据或者预处理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;e.g&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;K-均值&lt;/li&gt;
&lt;li&gt;最大期望算法&lt;/li&gt;
&lt;li&gt;DBSCAN(Density-based spatial clustering of applications with noise)&lt;/li&gt;
&lt;li&gt;Parzen窗设计&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;统计学习方法，李航
机器学习实战， Peter Harrington&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>求解路由路径问题（华为挑战赛小思）</title>
      <link>https://tmhm.github.io/2016/04/11/some-idea_search/</link>
      <pubDate>Mon, 11 Apr 2016 13:47:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/04/11/some-idea_search/</guid>
      <description>&lt;nav&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#问题定义:0ba0c5309010af3a84f484f67a82e239&#34;&gt;问题定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#说明:0ba0c5309010af3a84f484f67a82e239&#34;&gt;说明：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#最终得分机制:0ba0c5309010af3a84f484f67a82e239&#34;&gt;最终得分机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#思:0ba0c5309010af3a84f484f67a82e239&#34;&gt;思：&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#初衷:0ba0c5309010af3a84f484f67a82e239&#34;&gt;初衷：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#于是-开始慢慢地折腾和实现了:0ba0c5309010af3a84f484f67a82e239&#34;&gt;于是，开始慢慢地折腾和实现了 :-)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#算法描述:0ba0c5309010af3a84f484f67a82e239&#34;&gt;算法描述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#缺陷-反思:0ba0c5309010af3a84f484f67a82e239&#34;&gt;缺陷-反思&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/nav&gt;

&lt;p&gt;赛题源自“未来网络”业务发放中的路由计算问题。&lt;/p&gt;

&lt;h6 id=&#34;问题定义:0ba0c5309010af3a84f484f67a82e239&#34;&gt;问题定义&lt;/h6&gt;

&lt;p&gt;给定一个带权重的有向图G=(V,E)，V为顶点集，E为有向边集，每一条有向边均有一个权重。对于给定的顶点s、t，以及V的子集V&amp;rsquo;，寻找从s到t的不成环有向路径P，使得P经过V&amp;rsquo;中所有的顶点(对经过V&amp;rsquo;中节点的顺序不做要求)。
若不存在这样的有向路径P，则输出无解，程序运行时间越短，则视为结果越优；若存在这样的有向路径P，则输出所得到的路径，路径的权重越小，则视为结果越优，在输出路径权重一样的前提下，程序运行时间越短，则视为结果越优。&lt;/p&gt;

&lt;h6 id=&#34;说明:0ba0c5309010af3a84f484f67a82e239&#34;&gt;说明：&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;1）图中所有权重均为[1，20]内的整数；&lt;/li&gt;
&lt;li&gt;2）任一有向边的起点不等于终点；&lt;/li&gt;
&lt;li&gt;3）连接顶点A至顶点B的有向边可能超过一条，其权重可能一样，也可能不一样；&lt;/li&gt;
&lt;li&gt;4）该有向图的顶点不会超过600个，每个顶点出度(以该点为起点的有向边的数量)不超过8；&lt;/li&gt;
&lt;li&gt;5）V&amp;rsquo;中元素个数不超过50；&lt;/li&gt;
&lt;li&gt;6）从s到t的不成环有向路径P是指，P为由一系列有向边组成的从s至t的有向连通路径，且不允许重复经过任一节点；&lt;/li&gt;

&lt;li&gt;&lt;p&gt;7）路径的权重是指所有组成该路径的所有有向边的权重之和。&lt;/p&gt;

&lt;h6 id=&#34;最终得分机制:0ba0c5309010af3a84f484f67a82e239&#34;&gt;最终得分机制&lt;/h6&gt;

&lt;p&gt;华为后台会使用N个测试用例判题，该N个测试用例分为初级、中级、高级三个等级，参赛者对于每个测试用例都会得到一个百分制分数，使用加权平均分(初级权重为0.2，中级权重为0.3，高级权重为0.5)作为该参赛者的最终得分。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;输入输出采用文件的形式。&lt;/p&gt;

&lt;h5 id=&#34;思:0ba0c5309010af3a84f484f67a82e239&#34;&gt;思：&lt;/h5&gt;

&lt;p&gt;对于上述，这么一个问题，
最初的想法是根据dijkstra最短路径算法中贪心的思想，结合剪枝进行求解，但是对于复杂图节点的情况，主要是在于当必经节点变多，这个规则感觉就太多，没法继续下去。&lt;/p&gt;

&lt;p&gt;然后，接触到蚁群算法。
我从旅行商问题（TSP）开始学习这个算法，但是对于我们这个要求经过给定必经点的问题，跟TSP还是有比较大的差距。
TSP问题得以求解的核心思想在于：
&lt;em&gt;每只蚂蚁经过所有的节点，蚂蚁行走相对于cpu总的频率是一样的，当路径越短，其蚂蚁行走的次数就会增大&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;然后，突然有了一个这样类蚂蚁的想法，接下来就是围绕这个想法在实现了。
此处，仅仅是自己的一个思路的回顾，可能会存在一些问题。仅供讨论。&lt;/p&gt;

&lt;h6 id=&#34;初衷:0ba0c5309010af3a84f484f67a82e239&#34;&gt;初衷：&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;将所有蚂蚁丢在 起点和必经点上，然后再让他们自己去走，走到另一必经点，其信息素增大， 如果走到终点，信息素更大，直到某只蚂蚁找到终点。每次信息素更新时，信息素更新量的大小跟该蚂蚁走过的node数量和是否经过必经点有关。 这样来，理想情况下，每次更新时，经过必经点的路径信息素应该是比较大的，每次更新信息素后，进行一次从起点开始贪心搜，每次走信息素最大的，看是否可以走到终点，如果走到终点，本次路径即是一个解。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;因为，我们蚂蚁在每个节点，可供选择的节点是很少的， 最多才8个，而tsp问题是可以去任意个节点的 ，这样更新一遍信息素，就可以去类贪心一次，看是否可以找到解。&lt;/strong&gt;&lt;/p&gt;

&lt;h6 id=&#34;于是-开始慢慢地折腾和实现了:0ba0c5309010af3a84f484f67a82e239&#34;&gt;于是，开始慢慢地折腾和实现了 :-)&lt;/h6&gt;

&lt;p&gt;####### 类邻接表的图表结构&lt;/p&gt;

&lt;p&gt;头结点表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    struct AlGraph{
EdgeNode *adjacencyNode[8];  //
AlGraph *algacency_alGraph[8];  //point to the adjacencyNode struct !!!
short int edgecnt;   // the num of node link to this head node
short int vertexNum;
long distToSource;    // distance from start to this node  ,default = 0;
                        // due to the pre cost among [1:20]
bool known;         // degault = false,  become to true when parse it.
short int path;    //default = -1  // due to the pre node value among [0:600], yes , are node
/*这样的缺点是,不能同时找多条路径,一个点只能记录一个它的path,一个node有多个入度的时候,就会出问题了!
    此path成员只在dijkstra里面用，到后面类蚁群算法并没有用，它通过每只蚂蚁走过的路径来体现*/
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;边节点，它也可能是一个头结点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    struct EdgeNode   //边表节点
    {
       short int adjvex;  //bian jiedian hao
       short int cost;   //cost
       short int linkID;  //the edge id :  point to this node

       /** ant  */
       float pheromone; //
       //short int pheromone_delta;  //改写到蚂蚁身上
       long long nth_antPathVisited;  //nth bits;   all 64  ,实际上只是用来确定该蚂蚁走过这条边, 这样可以尝试走通往该节点的多条边.
       /**
       * 1111 ... ... 1111
       *64,63,... , 3,2,1 nth ant
       **/
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;必经节点结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    struct demandIncNode{
        short int demandID;
        bool gotStatus;
    };
    struct demandNode{
        short int source_id;
        short int destination_id;
        bool reachEndFlag;
        short int includingCnt;
        demandIncNode *includingNode[50];
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;蚂蚁结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    struct sAnt{
        long int ant_pheromone_Q;   // the gross about pheromone of each ant need to different!
        float pheromone_delta ;

        long l_pathMoved_length ;         //the all length of this ant moved from &amp;lt;their&amp;gt; source!!
        short int CommonNode_movedCount ;         //the number of node had moved
        short int DemandNode_movedCount;    //the number of demand node had moved
        short int cakeOnFront ;

        //float prob[8];    // to my own choose
        float  prob[8];              //the temp for calculate probability to choose
        short int curCandidacyNodeNum; //the number of node can be select to move
        short int passedNodeId;//
        short int curNodeId;  //the node now
        short int nextNodeId; // select node
        short int antStartId;

        bool antDie_status;  // this ant may little value
        bool gotDestination;    //pass some demandNode and got destination.
        bool gotDestFromMidway;
        short int timeCnt;  //let this ant stop ,or they run how much

    };

    struct sAntResult{
        short int toNode;
        short int linkId;
       // sAntResult *next;
       // sAntResult *pre;
        //sAntResult(short int n, short int id) : toNode(n) ,linkId(id) {}
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了方便查找索引，建立了一个头结点索引数组，来存储已经读入头结点的值，来防止访问第一个图表，出现野指针的情况。当需要查找某个头结点的相关信息时，先在头结点数组确认存在后， 再去图*graph[600]里面直接按头结点id值等于图索引号获取。&lt;/p&gt;

&lt;h6 id=&#34;算法描述:0ba0c5309010af3a84f484f67a82e239&#34;&gt;算法描述&lt;/h6&gt;

&lt;ol&gt;
&lt;li&gt;将图文件中的节点读进来，按照上面的图表格式存储，然后将有出度的头结点用指针联系起来，方便后面的访问。&lt;/li&gt;
&lt;li&gt;根据demand节点的个数，初始化蚂蚁的个数，并置位ant相关数据。选择每一只蚂蚁第一次的初始位置（起点+所有必经点+随机的非终点）。&lt;/li&gt;
&lt;li&gt;开始进入ant_run的主程序
    1. 将记录蚂蚁经过的路径信息复位；
    2. 让每个蚂蚁run，直到终点，或者没法继续；
            1. 根据当前节点和上一步访问的节点情况，计算本节点出度节点各自的概率，用轮盘选择下一个出度节点（避免一些可推倒的不行解）
            2. 每步记录蚂蚁获得的一些报酬（跟必经点，普通节点，终点，前方有蛋糕的概率等有关），当该蚂蚁停下来时，计算其身上有的信息总量
            3. 待所有蚂蚁都跑完一代，更新他们的信息素到各自走过的路经上
    3. check每只蚂蚁的信息素，并计算各自的增量，叠加到路径的信息素上去；
    4. check本次迭代是否找到解：
            1. 找到一个解（暂时只考虑了一代中多种可行解的优化，和初步环避免）存到一个队列中，返回
            2. 没有找到完整的解，记录返回调试用。目前的路径上的信息素可能有问题，将当次不完整解走过的路径上的信息素，用台风吹吹:-)
    5. 清掉本次迭代图上和ant的各种状态标识等
    6. 直到迭代次数，结束&lt;/li&gt;
&lt;li&gt;善后工作，写结果文件，以及调试打印输出等&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;上述为程序的主要框架，均按照自己某时想法，一步步累积起来的，更多细节部分细节处理&lt;/strong&gt;
相比蚁群算法的核心收敛机制在于cpu的频率，上述方法应该收敛的条件是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;经过更多的必经点，蚂蚁报酬更多，从起点达到终点，经过所有必经点，报酬甚之(理想解);&lt;/li&gt;
&lt;li&gt;可能上一点不完备，有某些问题；&lt;/li&gt;
&lt;li&gt;结合了强化学习正反馈的报酬机制。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;缺陷-反思:0ba0c5309010af3a84f484f67a82e239&#34;&gt;缺陷-反思&lt;/h6&gt;

&lt;p&gt;缺少完备的理论证明。 并没有证明求解空间在这些规则下，是完备的，并且会收敛到最优(目前来看，收敛性不太好)。
因此，实践起来，发现并不如我心意。
需要在一些规则的限制下才能得到较简单问题的解，目前只能得到case0和case1的解，偶尔会出现次优解。因为，我只在一个地方优化了解&lt;em&gt;一次迭代中，当出现多个解得时候，即有多只蚂蚁同时获得解，才会去优化次优的信息素&lt;/em&gt;
所以当代与代之间有时不收敛的时候就只能通过其他的规则才能得到解，我一直在想，这个问题，估计我还有某些方面没考虑到，是不完备的解，所以导致不收敛。理论基础好生重要！&lt;/p&gt;

&lt;p&gt;软件系统规划仍比较薄弱。 没有学过程序设计模式和架构，都是按照自己的一些想法实现的，当遇到问题的时候，再在这上面添加补充和完善。一开始没有很好的布局式设计，如果一开始能把所有的想明白了，做好整体框架，程序的结构性就会好一些。耦合程度也会低一些。当然在实现的过程中，我也尽量使相关性程度比较高的在一起，为了以后更好地维护。&lt;/p&gt;

&lt;p&gt;整个工程的总共时间不长，应该算是我认真做过的项目中最短的了，两个隔离的周末（4天）加基本一周（6天），总共十天（满满的），包括了所有的构思和编码。总共编码在1700行左右，后期并未优化，想想，曾经一个五子棋也写了5000行，当时写dos下的界面花了不少行，当时的AI做的还挺好的，放在班群上也能得到很好的胜率。（当时也实现了自己的一个小想法，不但考虑自己胜算大小，还考虑了对方的，还有梯度的思想，哈哈~）&lt;/p&gt;

&lt;p&gt;此处仅当做学习的一个总结，全是自己一行一行码的代码，勿拍砖，不足之处敬请指正与讨论。：-)&lt;/p&gt;

&lt;p&gt;其实当每一次认真地做一个project，只要能单纯实现自己的一些想法，也是一件很美妙的事情，目前来看，至少也有6个这样的项目了吧
- 第一块电路板和自制电源
- 独角兽&amp;lt;一代,历时半年多，收货也大大&amp;gt;
- 倒立摆&amp;lt;惊喜之作&amp;gt;
- 四轴&amp;lt;历时也整整半年多，但不太尽人意&amp;gt;
- 五子棋&amp;lt;琢磨&amp;gt;
- 此次也算吧&lt;/p&gt;

&lt;p&gt;&amp;lt;感受码代码过程中的&amp;mdash;-那份喜悦与微妙&amp;gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;独角兽，幸运；更需要实力
2016.4.11晚&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>删除链表中倒数第n个节点</title>
      <link>https://tmhm.github.io/2016/03/25/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</link>
      <pubDate>Fri, 25 Mar 2016 09:25:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/03/25/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</guid>
      <description>&lt;p&gt;remove Nth node from end of list&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　给定一个链表，删除链表中倒数第n个节点，返回链表的头节点。&lt;/p&gt;
&lt;div class=&#34;m-t-lg m-b-lg&#34;&gt;&lt;strong&gt;样例：&lt;/strong&gt;
&lt;div class=&#34;m-t-sm&#34;&gt;
&lt;p&gt;　　删除倒数第二个节点之后，这个链表将变成&lt;strong&gt;&lt;span style=&#34;color: #e76363;&#34;&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;5-&amp;gt;null.&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;m-t-lg m-b-lg&#34;&gt;&lt;strong&gt;挑战：&lt;/strong&gt;
&lt;div class=&#34;m-t-sm&#34;&gt;
&lt;p&gt;　　O(n)时间复杂度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;先求得链表长度，查询链表依次时间O(n)，第二次找到倒数n位置，删除之，时间共O(n)+O(n)~ O(n)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;cnblogs_code&#34;&gt;
&lt;pre&gt;&lt;span style=&#34;color: #008080;&#34;&gt; 1&lt;/span&gt; &lt;span style=&#34;color: #800000;&#34;&gt;&amp;raquo;&amp;laquo;&amp;raquo;&lt;/span&gt;
&lt;span style=&#34;color: #008080;&#34;&gt; 2&lt;/span&gt; &lt;span style=&#34;color: #800000;&#34;&gt;Definition of ListNode
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt; 3&lt;/span&gt; &lt;span style=&#34;color: #800000;&#34;&gt;class ListNode(object):
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt; 4&lt;/span&gt;
&lt;span style=&#34;color: #008080;&#34;&gt; 5&lt;/span&gt; &lt;span style=&#34;color: #800000;&#34;&gt;    def &lt;strong&gt;init&lt;/strong&gt;(self, val, next=None):
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt; 6&lt;/span&gt; &lt;span style=&#34;color: #800000;&#34;&gt;        self.val = val
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt; 7&lt;/span&gt; &lt;span style=&#34;color: #800000;&#34;&gt;        self.next = next
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt; 8&lt;/span&gt; &lt;span style=&#34;color: #800000;&#34;&gt;&amp;raquo;&amp;laquo;&amp;raquo;&lt;/span&gt;
&lt;span style=&#34;color: #008080;&#34;&gt; 9&lt;/span&gt; &lt;span style=&#34;color: #0000ff;&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt; Solution:
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt;10&lt;/span&gt;     &lt;span style=&#34;color: #800000;&#34;&gt;&amp;raquo;&amp;laquo;&amp;raquo;&lt;/span&gt;
&lt;span style=&#34;color: #008080;&#34;&gt;11&lt;/span&gt; &lt;span style=&#34;color: #800000;&#34;&gt;    @param head: The first node of linked list.
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt;12&lt;/span&gt; &lt;span style=&#34;color: #800000;&#34;&gt;    @param n: An integer.
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt;13&lt;/span&gt; &lt;span style=&#34;color: #800000;&#34;&gt;    @return: The head of linked list.
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt;14&lt;/span&gt;     &lt;span style=&#34;color: #800000;&#34;&gt;&amp;raquo;&amp;laquo;&amp;raquo;&lt;/span&gt;
&lt;span style=&#34;color: #008080;&#34;&gt;15&lt;/span&gt;     &lt;span style=&#34;color: #0000ff;&#34;&gt;def&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt; removeNthFromEnd(self, head, n):
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt;16&lt;/span&gt;         &lt;span style=&#34;color: #008000;&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color: #008000;&#34;&gt; write your code here&lt;/span&gt;
&lt;span style=&#34;color: #008080;&#34;&gt;17&lt;/span&gt;         dummy =&lt;span style=&#34;color: #000000;&#34;&gt; ListNode(0)
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt;18&lt;/span&gt;         dummy.next =&lt;span style=&#34;color: #000000;&#34;&gt; head
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt;19&lt;/span&gt;
&lt;span style=&#34;color: #008080;&#34;&gt;20&lt;/span&gt;         &lt;span style=&#34;color: #008000;&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color: #008000;&#34;&gt; for length&lt;/span&gt;
&lt;span style=&#34;color: #008080;&#34;&gt;21&lt;/span&gt;         len =&lt;span style=&#34;color: #000000;&#34;&gt; 0
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt;22&lt;/span&gt;         pre =&lt;span style=&#34;color: #000000;&#34;&gt; dummy
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt;23&lt;/span&gt;         &lt;span style=&#34;color: #0000ff;&#34;&gt;while&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt; pre.next:
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt;24&lt;/span&gt;             len += 1
&lt;span style=&#34;color: #008080;&#34;&gt;25&lt;/span&gt;             pre =&lt;span style=&#34;color: #000000;&#34;&gt; pre.next
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt;26&lt;/span&gt;
&lt;span style=&#34;color: #008080;&#34;&gt;27&lt;/span&gt;         &lt;span style=&#34;color: #008000;&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color: #008000;&#34;&gt; find the Nth node from end of list&lt;/span&gt;
&lt;span style=&#34;color: #008080;&#34;&gt;28&lt;/span&gt;         cnt =&lt;span style=&#34;color: #000000;&#34;&gt; 0
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt;29&lt;/span&gt;         tarCnt = len -&lt;span style=&#34;color: #000000;&#34;&gt; n
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt;30&lt;/span&gt;         pre =&lt;span style=&#34;color: #000000;&#34;&gt; dummy
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt;31&lt;/span&gt;         &lt;span style=&#34;color: #0000ff;&#34;&gt;while&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt; pre.next:
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt;32&lt;/span&gt;             &lt;span style=&#34;color: #0000ff;&#34;&gt;if&lt;/span&gt; cnt ==&lt;span style=&#34;color: #000000;&#34;&gt; tarCnt:
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt;33&lt;/span&gt;                 pre.next =&lt;span style=&#34;color: #000000;&#34;&gt; pre.next.next
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt;34&lt;/span&gt;                 &lt;span style=&#34;color: #0000ff;&#34;&gt;break&lt;/span&gt;
&lt;span style=&#34;color: #008080;&#34;&gt;35&lt;/span&gt;             &lt;span style=&#34;color: #0000ff;&#34;&gt;else&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;:
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt;36&lt;/span&gt;                 cnt +=1
&lt;span style=&#34;color: #008080;&#34;&gt;37&lt;/span&gt;                 pre =&lt;span style=&#34;color: #000000;&#34;&gt; pre.next
&lt;/span&gt;&lt;span style=&#34;color: #008080;&#34;&gt;38&lt;/span&gt;
&lt;span style=&#34;color: #008080;&#34;&gt;39&lt;/span&gt;         &lt;span style=&#34;color: #0000ff;&#34;&gt;return&lt;/span&gt; dummy.next&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>