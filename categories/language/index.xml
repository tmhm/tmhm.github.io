<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Language on Well</title>
    <link>https://tmhm.github.io/categories/language/index.xml</link>
    <description>Recent content in Language on Well</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>wells217@163.com (Well)</managingEditor>
    <webMaster>wells217@163.com (Well)</webMaster>
    <copyright>(c) 2017 Well.</copyright>
    <atom:link href="https://tmhm.github.io/categories/language/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>SQL初识</title>
      <link>https://tmhm.github.io/2017/04/01/taste_sql/</link>
      <pubDate>Sat, 01 Apr 2017 22:51:52 +0800</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2017/04/01/taste_sql/</guid>
      <description>

&lt;h3 id=&#34;事务的四项特性&#34;&gt;事务的四项特性&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ACID&lt;/li&gt;
&lt;li&gt;A（atomic）原子性

&lt;ul&gt;
&lt;li&gt;用户a 少 200元－》 用户b 多 200元， 同时成立&lt;/li&gt;
&lt;li&gt;或者成立，或者回滚&lt;/li&gt;
&lt;li&gt;加锁，写日志&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;C（consistency）一致性

&lt;ul&gt;
&lt;li&gt;事务不存在中间状态&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;I（isolation）隔离性

&lt;ul&gt;
&lt;li&gt;一个事务没有完成，新事务提交请求，为了可以并发，&lt;/li&gt;
&lt;li&gt;undo－log记录行数据版本信息， 可重复读，&lt;/li&gt;
&lt;li&gt;序列化读，全部加锁&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;D（durability） 持久性

&lt;ul&gt;
&lt;li&gt;事务提交，记录到硬盘，&lt;/li&gt;
&lt;li&gt;刷新机制，时间－》秒， 事务提交即刷新，操作系统决定&lt;br /&gt;

&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;sql&#34;&gt;SQL&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;四种操作&lt;/li&gt;
&lt;li&gt;增删改查&lt;/li&gt;
&lt;li&gt;ddl 数据定义语言，  建库，建表&lt;/li&gt;
&lt;li&gt;dml 数据操作语言，  增删改查&lt;/li&gt;
&lt;li&gt;dcl 数据控制语言，  用户授权，权限回收，清空表数据&lt;/li&gt;
&lt;li&gt;delete 会有redo－log， truncate 里面直接操作，不记日志&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Python 中logging 模块的配置和使用</title>
      <link>https://tmhm.github.io/2016/12/25/logging-%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 25 Dec 2016 04:49:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/12/25/logging-%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/</guid>
      <description>

&lt;p&gt;reference :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://python.usyiyi.cn/python_278/library/logging.handlers.html#&#34;&gt;logging cookbook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://python.usyiyi.cn/translate/python_278/howto/logging.html#logging-advanced-tutorial&#34;&gt;logging HOWTO&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;测试源码，example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import logging

nt = &#39;xwei&#39;
# logging.basicConfig(filename=&#39;log/log_test.log&#39;,
#                     format=&#39;%(asctime)s, %(levelname)s:%(message)s&#39;, datefmt=&#39;%m/%d/%Y %I:%M:%S %p&#39;,
#                     filemode=&#39;w&#39;, level=logging.INFO)

# set up logging to file - see previous section for more details
# w ,new file
logging.basicConfig(level=logging.DEBUG,
                    format=&#39;%(asctime)s %(name)-12s %(levelname)-8s %(message)s&#39;,
                    datefmt=&#39;%m/%d/%Y %H:%M:%S %p&#39;,
                    filename=&#39;log/log_test.log&#39;,
                    filemode=&#39;w&#39;)
# define a Handler which writes INFO messages or higher to the sys.stderr
console = logging.StreamHandler()
console.setLevel(logging.INFO)
# set a format which is simpler for console use
formatter = logging.Formatter(&#39;%(name)-12s: %(levelname)-8s %(message)s&#39;)
# tell the handler to use this format
console.setFormatter(formatter)
# add the handler to the root logger
logging.getLogger(&#39;&#39;).addHandler(console)

# Now, we can log to the root logger, or any other logger. First the root...
logging.info(&#39;Jackdaws love my big sphinx of quartz.&#39;)

# Now, define a couple of other loggers which might represent areas in your
# application:
logger1 = logging.getLogger(&#39;myapp.area1&#39;)
logger2 = logging.getLogger(&#39;myapp.area2&#39;)

logger1.debug(&#39;Quick zephyrs blow, vexing daft Jim.&#39;)
logger1.info(&#39;How quickly daft jumping zebras vex.&#39;)
logger2.warning(&#39;Jail zesty vixen who grabbed pay from quack.&#39;)
logger2.error(&#39;The five boxing wizards jump quickly.&#39;)

# &#39;application&#39; code
logging.debug(&amp;quot;this is debug.&amp;quot;)
logging.info(&amp;quot;this is info form %s.&amp;quot; % nt)
logging.warning(&amp;quot;this is warning from %s.&amp;quot; % nt)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认设置文件的level 是debug，基础上再设置console的格式。&lt;/p&gt;

&lt;p&gt;程序分别在文件中和console里面保留了对应level的信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;console 记录显示大于info level的信息&lt;/li&gt;
&lt;li&gt;文件中记录level 超过 debug 的信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;level设计&#34;&gt;level设计&lt;/h4&gt;

&lt;p&gt;logging函数根据它们用来跟踪的事件的级别或严重程度来命名。&lt;a href=&#34;http://python.usyiyi.cn/translate/python_278/howto/logging.html#logging-advanced-tutorial&#34;&gt;标准级别及其适用性描述&lt;/a&gt;如下（以严重程度递增排序）：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;级别&lt;/th&gt;
&lt;th&gt;数字值&lt;/th&gt;
&lt;th&gt;何时使用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;DEBUG&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;详细信息，典型地调试问题时会感兴趣。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;INFO&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;证明事情按预期工作。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;WARNING&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;表明发生了一些意外，或者不久的将来会发生问题（如‘磁盘满了’）。软件还是在正常工作。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ERROR&lt;/td&gt;
&lt;td&gt;40&lt;/td&gt;
&lt;td&gt;由于更严重的问题，软件已不能执行一些功能了。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CRITICAL&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;td&gt;严重错误，表明软件已不能继续运行了。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;默认级别为 WARNING，表示只有该级别及其以上的事件会被跟踪，除非另外配置了logging包。&lt;/p&gt;

&lt;p&gt;我希望：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在console里面输出所有的交互信息，用debug level；&lt;/li&gt;
&lt;li&gt;在文件里面保存每次迭代完成的数据，用于分析画图，不要太多的中间数据，应该用info level。&lt;/li&gt;
&lt;li&gt;logging 可以配置&lt;a href=&#34;http://python.usyiyi.cn/python_278/library/logging.handlers.html#&#34;&gt;RotatingFileHandler保留循环文件的大小以及个数&lt;/a&gt;，不想保存太多的log信息。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>C_Cplus程序设计涉及的一些知识点</title>
      <link>https://tmhm.github.io/2016/08/30/c_cplus%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%B6%89%E5%8F%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
      <pubDate>Tue, 30 Aug 2016 10:47:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/08/30/c_cplus%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%B6%89%E5%8F%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
      <description>

&lt;h3 id=&#34;c中的printf函数&#34;&gt;c中的printf函数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;main() {
	int b = 3;
	int arr[]= {6,7,8,9,10};

	int * ptr = arr;
    *(ptr++) += 123;
    printf(&amp;quot;%d,%d\n&amp;quot;,*ptr,*(++ptr));
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;输出 ：8,8&lt;/p&gt;

&lt;p&gt;原因：printf函数计算参数是&lt;strong&gt;从右往左压栈的&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;c和c-的关系&#34;&gt;c和c++的关系&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;c++ 语言支持函数重载，c语言不支持函数重载；&lt;/li&gt;
&lt;li&gt;函数在C++编译后在库中的名字和C语言的不同，假设某个函数原型是void foo（int x， int y）。该函数被C编译器编译后，在库中的名字是_foo,而在C++编译器中则会产生像_foo_int_int之类的名字。&lt;/li&gt;
&lt;li&gt;C++提供了C连接交换指定符 extern &amp;laquo;c&amp;raquo; 解决名字匹配的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;指针和引用&#34;&gt;指针和引用&lt;/h3&gt;

&lt;p&gt;区别：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;非空区别，在任何情况下都不能使用指向空值的引用。一个引用必须总是指向某些对象；&lt;/li&gt;
&lt;li&gt;合法性，在使用引用之前不需要测试它的合法性，相反，指针则应该总是被测试，防止其为空；&lt;/li&gt;
&lt;li&gt;可修改区别，指针可被重新赋值以指向另一个不同对象。但是引用则总是指向在初始化被指定的对象，以后不能改变，但是指向的对象的其内容可以改变&lt;/li&gt;
&lt;li&gt;应用区别，有存在不指向任何对象的可能和不同时刻会指向不同的对象等情况时，使用指针；如果总是指向一个对象并且指向一个对象以后就不会改变指向，那么应该使用引用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;传递动态内存&#34;&gt;传递动态内存&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;void swap3(int *p, int *q) {
	int *tmp;
    tmp = p;
    p = q;
    q = tmp;//仅仅交换了指针的值，并没有改变两块内存的值
}

void swap4(int *p, int *q) {
	int tmp;
    tmp = *p;  //获取p指向内存的值
    *p = *q;
    *q = tmp;
}

void swap5(int &amp;amp;p, int &amp;amp;q) {
	int tmp;
    tmp = p; //获取p指向内存的值
    p = q;
    q = tmp;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    int t1 = 1,t2 = 2;
    cout &amp;lt;&amp;lt; t1 &amp;lt;&amp;lt; &amp;quot;&amp;quot;&amp;lt;&amp;lt; t2 &amp;lt;&amp;lt; endl;
    swap3(&amp;amp;t1,&amp;amp;t2); //仅仅交换了指针的值，并没有改变两块内存的值
    cout &amp;lt;&amp;lt; t1 &amp;lt;&amp;lt; &amp;quot;&amp;quot;&amp;lt;&amp;lt; t2 &amp;lt;&amp;lt; endl;
    // 后面两个函数分别用指针和引用交换成功
    swap4(&amp;amp;t1,&amp;amp;t2);
    cout &amp;lt;&amp;lt; t1 &amp;lt;&amp;lt; &amp;quot;&amp;quot;&amp;lt;&amp;lt; t2 &amp;lt;&amp;lt; endl;
    swap5(t1,t2);
    cout &amp;lt;&amp;lt; t1 &amp;lt;&amp;lt; &amp;quot;&amp;quot;&amp;lt;&amp;lt; t2 &amp;lt;&amp;lt; endl;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;malloc-申请内存&#34;&gt;malloc 申请内存&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;void getMemory_err(char *p, int num) {
p = (char *)malloc(sizeof(char )* num);
        // 没有return 指针，不能传递动态内存
}

//返回指针变量
char *pGetMemory(char *p, int num) {
p = (char *)malloc(sizeof(char )* num);
        return p;
}

// 用指针的指针，
void getMemory(char **p, int num) {
*p = (char *)malloc(sizeof(char )* num);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//&amp;mdash;&amp;mdash;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char *str = NULL;
getMemory(&amp;amp;str,10);
strcpy(str,&amp;quot;hello&amp;quot;);

char *str2 = NULL;
str2 = pGetMemory(str2,10);
strcpy(str2,&amp;quot;test&amp;quot;);

cout&amp;lt;&amp;lt; *str &amp;lt;&amp;lt;endl;
cout&amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;
cout&amp;lt;&amp;lt; &amp;amp;str &amp;lt;&amp;lt; endl;

cout&amp;lt;&amp;lt; *str2 &amp;lt;&amp;lt;endl;
cout&amp;lt;&amp;lt; str2 &amp;lt;&amp;lt; endl;
cout&amp;lt;&amp;lt; &amp;amp;str2 &amp;lt;&amp;lt; endl;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    h
    hello
    012FF774
    t
    test
    012FF768
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;字符串变量存储问题&#34;&gt;字符串变量存储问题&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;int a = 0; //全局初始化区
char *p1; //全局未初始化区
int _tmain(int argc, _TCHAR* argv[]) {
int b; //栈
char s[] = &amp;quot;abc&amp;quot;; //s在栈上， 常量区会存储一份&amp;quot;abc\0&amp;quot;，用于共享，s[]初始化的时候拷贝过来放到栈上
char *p2; //栈
char *p3 = &amp;quot;123456&amp;quot;; //123456\0在常量区，p3在栈上。
const char *m = &amp;quot;123456&amp;quot;; //m在栈上， “123456” 在常量区
static int c =0; //全局（静态）初始化区
p1 = (char *)malloc(10);
p2 = (char *)malloc(20);
//分配得来得10和20字节的区域就在堆区。
strcpy(p1, &amp;quot;123456&amp;quot;); //123456\0放在常量区，编译器可能会将它与p3所指向的&amp;quot;123456&amp;quot; 优化成一个地方。

cout &amp;lt;&amp;lt; (m == p3 ? 1: 0) &amp;lt;&amp;lt; endl;
// out 1,
cout &amp;lt;&amp;lt; (p1 == p3? 1: 0) &amp;lt;&amp;lt; endl;
// out 0;
cout &amp;lt;&amp;lt; p1 &amp;lt;&amp;lt; &amp;quot;———&amp;quot; &amp;lt;&amp;lt; p3 &amp;lt;&amp;lt; endl; // out 123456---123456

return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//&amp;mdash;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char *strA() {
	char str[] = &amp;quot;hello world&amp;quot;;
    cout &amp;lt;&amp;lt; &amp;quot;in str[] &amp;quot;&amp;lt;&amp;lt;endl;
    cout &amp;lt;&amp;lt; &amp;quot;before: &amp;quot;&amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;
    str[0] = &#39;t&#39;;
    cout &amp;lt;&amp;lt;&amp;quot;After:&amp;quot; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;
    return str;
}

char *pStrA_err() {
	char *str = &amp;quot;hello world&amp;quot;;
    cout &amp;lt;&amp;lt; &amp;quot;in *str &amp;quot;&amp;lt;&amp;lt;endl;
    cout &amp;lt;&amp;lt; &amp;quot;before: &amp;quot;&amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;
    //*str = &#39;P&#39;; // !!!!!!------runtime error 字符串常量保存在只读数据段
    cout &amp;lt;&amp;lt;&amp;quot;After:&amp;quot; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;
    return str;
}
char *pStrA(){
    static char *str = &amp;quot;hello world&amp;quot;;
    cout &amp;lt;&amp;lt; &amp;quot;in *str &amp;quot;&amp;lt;&amp;lt;endl;
    cout &amp;lt;&amp;lt; &amp;quot;before: &amp;quot;&amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;
    //*str = &#39;P&#39;; // !!!!!!------runtime error  ,字符串常量保存在只读数据段
    cout &amp;lt;&amp;lt;&amp;quot;After:&amp;quot; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;
    return str;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;main:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char *c = strA();
char *c2 = pStrA_err();
char *c3 = pStrA();

cout &amp;lt;&amp;lt; &amp;quot;After fun return:&amp;quot; &amp;lt;&amp;lt; &amp;quot;--c:&amp;quot; &amp;lt;&amp;lt; c &amp;lt;&amp;lt; &amp;quot;--c2:&amp;quot; &amp;lt;&amp;lt; c2 &amp;lt;&amp;lt; &amp;quot;--c3&amp;quot; &amp;lt;&amp;lt; c3 &amp;lt;&amp;lt; endl;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    in str[]
    before: hello world
    After:tello world
    in *str
    before: hello world
    After:hello world
    in *str
    before: hello world
    After:hello world
    After fun return:--c:@?--c2:hello world--c3hello world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt;
&amp;gt; - 字符串数据保存在常量区，只读的数据段，不能直接修改
&amp;gt; - 函数内数组是局部变量，在函数内通过str[0] 可以修改。return之后，局部变量释放，&lt;/p&gt;

&lt;h3 id=&#34;构造函数&#34;&gt;构造函数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;class tA{
public:
        int _a;
        tA(){
                _a = 1;
        }
        void print(){
                printf(&amp;quot;%d&amp;quot;,_a);
        }
};
class tB :public tA{
public:
        int _a;
        tB(){
                _a = 2;
        }

};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//&amp;ndash;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tB b;
tB b;
b.print(); // 在构造B类之前，先调用A的构造函数，在A类中_a =1,
printf(&amp;quot;%d&amp;quot;,b._a); // B类中 _a = 2;
return 0;
    
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;output:        12&lt;/p&gt;

&lt;p&gt;在构造B类之前，先调用A的构造函数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;malloc-free-new-delete&#34;&gt;malloc/free ＆＆new/delete&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;malloc/free 是c++/c语言的标准库函数，new/delete是c++的运算符，它们都可以用于申请和释放动态内存&lt;/li&gt;
&lt;li&gt;由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能执行构造函数和析构函数&lt;/li&gt;
&lt;li&gt;c++语言中new运算符， 能完成动态内存分配和初始化工作； delete 运算符完成清理和释放内存工作&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;指针和句柄&#34;&gt;指针和句柄&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;句柄和指针其实是两个截然不同的概念。&lt;/li&gt;
&lt;li&gt;windows系统用句柄标记系统资源，隐藏系统的信息，它是一个32bit的uint。&lt;/li&gt;
&lt;li&gt;指针则标记某个物理内存的地址&lt;/li&gt;
&lt;li&gt;句柄可以看做是指向指针的指针。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;this-指针&#34;&gt;this 指针&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;本质上是一个函数参数，只是编译器隐藏起形式，语法层面的参数，this指针只能在成员函数中使用，全局函数，静态函数都不能使用this指针。 在python中直接显性给出&lt;/li&gt;
&lt;li&gt;this指针在成员函数的开始前构造，在成员的结束后清除&lt;/li&gt;
&lt;li&gt;this指针并不占用对象的空间， 只会占用参数传递时的栈空间，或者直接占用一个寄存器&lt;/li&gt;
&lt;li&gt;this指针会因编译器不同而有不同的存放位置，可能是堆，栈，也可能是寄存器。&lt;/li&gt;
&lt;li&gt;this指针只有在成员函数中才有定义。因此，在获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数中才有this指针的位置）&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;程序员面试宝典（第五版）&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>python 与时间有关的操作</title>
      <link>https://tmhm.github.io/2016/05/31/python-%E4%B8%8E%E6%97%B6%E9%97%B4%E6%9C%89%E5%85%B3%E7%9A%84%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 31 May 2016 10:46:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/05/31/python-%E4%B8%8E%E6%97%B6%E9%97%B4%E6%9C%89%E5%85%B3%E7%9A%84%E6%93%8D%E4%BD%9C/</guid>
      <description>

&lt;p&gt;源代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import time
# ISOTIMEFORMAT=&#39;%Y-%m-%d %X&#39;
ISOTIMEFORMAT=&#39;%Y-%m-%d&#39;
t= time.strftime( ISOTIMEFORMAT, time.gmtime( time.time() ) )
f = open( t + &amp;quot;test.txt&amp;quot;,&#39;wb&#39;)
f.write(&amp;quot;hello,\n This is a test file&amp;quot;)
f.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;计算程序运行时间&#34;&gt;计算程序运行时间&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;import time
# ISOTIMEFORMAT=&#39;%Y-%m-%d %X&#39;
start = time.time()
ISOTIMEFORMAT=&#39;%Y-%m-%d&#39;
t= time.strftime( ISOTIMEFORMAT, time.gmtime( time.time() ) )
f = open( t + &amp;quot;test.txt&amp;quot;,&#39;wb&#39;)
f.write(&amp;quot;hello,\n This is a test file&amp;quot;)
f.close()
print t
elapsed = time.time() - start
print elapsed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;out：
​&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2016-05-31
0.00300002098083
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>python之面向对象（继承）</title>
      <link>https://tmhm.github.io/2016/05/26/python%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Thu, 26 May 2016 09:53:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/05/26/python%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF/</guid>
      <description>

&lt;h4 id=&#34;python之面向对象-继承&#34;&gt;python之面向对象（继承）&lt;/h4&gt;

&lt;p&gt;面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。继承完全可以理解成类之间的类型和子类型关系。&lt;/p&gt;

&lt;p&gt;需要注意的地方：继承语法 class 派生类名（基类名）：//&amp;hellip; 基类名写作括号里，基本类是在类定义的时候，在元组之中指明的。&lt;/p&gt;

&lt;p&gt;在python中继承中的一些特点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在继承中&lt;strong&gt;基类的构造（&lt;strong&gt;init&lt;/strong&gt;()方法）不会被自动调用&lt;/strong&gt;，它需要在其派生类的构造中亲自专门调用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在调用基类的方法时，需要加上基类的类名前缀，且需要带上self参数变量。区别于在类中调用普通函数时并不需要带上self参数.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中&lt;strong&gt;逐个查找&lt;/strong&gt;。（先在本类中查找调用的方法，找不到才去基类中找）。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;class animal(object):
    def __init__(self):
        print &#39;animal init&#39;

    def say(self):
        print &#39;animal say&#39;

class dog(animal):
    def __init__(self):
        #animal.__init__(self)
        print &#39;dog init&#39;

    def say(self):
        animal.say(self)
        print &#39;dog say&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In [23]:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;d = dog()
d.say()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;out:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dog init
animal say
dog say
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果在继承元组中列了一个以上的类，那么它就被称作&amp;raquo;多重继承&amp;raquo; 。
当多个类之间有包含关系，不能继承。&lt;/p&gt;

&lt;p&gt;比如，下面的例子不行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        class A:
        class B(A):
        class C(A,B)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是，多重继承逐个查找的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class animal(object):
    def __init__(self):
        print &#39;animal init&#39;

    def say(self):
        print &#39;animal say&#39;

class dog(animal):
    def __init__(self):
        #animal.__init__(self)
        print &#39;dog init&#39;

    def say(self):
        animal.say(self)
        print &#39;dog say&#39;

class cat(animal):
    def __init__(self):
        #animal.__init__(self)
        print &#39;cat init&#39;

    def say(self):
        #animal.say(self)
        print &#39;cat say&#39;

class wolfhound(cat,dog):  #先继承cat，后面测试案例只输出了cat say。
    def __init__(self):
        print &amp;quot;wolfhound init.&amp;quot;

    def run(self):
        print &amp;quot;wolfhound run&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;d = dog()
d.say()
w = wolfhound()
w.run()
w.say()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;out：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dog init
animal say
dog say
wolfhound init.
wolfhound run
cat say

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>C_Cplus中一些不太注意到的小知识点--[锦集]</title>
      <link>https://tmhm.github.io/2016/05/22/c_cplus%E4%B8%AD%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%A4%AA%E6%B3%A8%E6%84%8F%E5%88%B0%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9--%E9%94%A6%E9%9B%86/</link>
      <pubDate>Sun, 22 May 2016 14:55:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/05/22/c_cplus%E4%B8%AD%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%A4%AA%E6%B3%A8%E6%84%8F%E5%88%B0%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9--%E9%94%A6%E9%9B%86/</guid>
      <description>

&lt;p&gt;C/C++小知识点&amp;ndash;[锦集]&lt;/p&gt;

&lt;h4 id=&#34;和-的优先级&#34;&gt;“=”和“&amp;lt;=” 的优先级&lt;/h4&gt;

&lt;p&gt;1.(   (file_got_len = recv_str(sock,buf,BUF_SIZE) )    &amp;lt;= 0)&lt;/p&gt;

&lt;p&gt;2.(     file_got_len = recv_str(sock,buf,BUF_SIZE) &amp;lt;= 0   )&lt;/p&gt;

&lt;p&gt;第二种情况下，当recv_str()函数成功返回发送字符串的时候，尽管会成功返回发送字节数大于0，&lt;/p&gt;

&lt;p&gt;但是，file_got_len只会返回0，&lt;/p&gt;

&lt;p&gt;因为“&amp;lt;=”的优先级大于“=”。&lt;/p&gt;

&lt;p&gt;所以在多语句写在一起时，最好用（） 明示！！&lt;/p&gt;

&lt;h4 id=&#34;运算操作符&#34;&gt;运算操作符&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;int i,t;
t = (i=1)+(++i);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出
&lt;code&gt;t= 4
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;i首先被赋值1，随后++i，使i的值变为2，到做加法的操作的时候，两个操作数都要读i此时的值，结果是两个2相加，等于4.&lt;/p&gt;

&lt;p&gt;其汇编程序（基于vs2010），如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int i,t;
t = (i=1)+(++i);
011413FE  mov         dword ptr [i],1
01141405  mov         eax,dword ptr [i]
01141408  add         eax,1
0114140B  mov         dword ptr [i],eax
0114140E  mov         ecx,dword ptr [i]
01141411  add         ecx,dword ptr [i]
01141414  mov         dword ptr [t],ecx

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;i自加后，只保留在eax 寄存器里，然后将eax的2赋给i，所以，i 就变成2了。此处和动态语言的引用似乎有所类似。&lt;/p&gt;

&lt;h4 id=&#34;sizeof操作符与数组&#34;&gt;sizeof操作符与数组&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;int t,tt,num;
int array[5];
int *p = array;

t= sizeof(p); //t =4
t= sizeof(int [5]);     // t= 20
tt = sizeof(array);     // tt = 20
num = sizeof(array)/sizeof(array[0]);  // get the number of array .  num =5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开始自以为，数组名不是首地址嘛。 应该是一个指针，然后对指针sizeof ，应该是4
个字节才对，&lt;strong&gt;为什么呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此时&lt;strong&gt;sizeof的是整个数组，而非首指针&lt;/strong&gt;。
要学会多查看&lt;a href=&#34;https://msdn.microsoft.com/en-us/library/0w557fh7.aspx&#34;&gt;MSDN&lt;/a&gt;，解释如下：
&amp;gt; When you apply the sizeof operator to an array identifier, the result is the size of the entire array rather than the size of the pointer represented by the array identifier.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>python 有关引用的一些问题</title>
      <link>https://tmhm.github.io/2016/05/21/python_reference/</link>
      <pubDate>Sat, 21 May 2016 14:24:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/05/21/python_reference/</guid>
      <description>

&lt;pre&gt;&lt;code&gt;print id.__doc__
​
id(object) -&amp;gt; integer

Return the identity of an object.  This is guaranteed to be unique among
simultaneously existing objects.  (Hint: it&#39;s the object&#39;s memory address.)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;python中的引用对象特点&#34;&gt;python中的引用对象特点：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;python不允许程序员选择采用传值还是传引用。
    - Python参数传递采用的肯定是“传对象引用”的方式。实际上，这种方式相当于传值和传引用的一种综合。如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值——相当于通过“传引用”来传递对象。
    - 如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象——相当于通过“传值&amp;rsquo;来传递对象。&lt;/li&gt;
&lt;li&gt;当人们复制列表或字典时，就复制了对象列表的引用，如果改变引用的值，则修改了原始的参数。&lt;/li&gt;
&lt;li&gt;为了简化内存管理，Python通过引用计数机制实现自动垃圾回收功能，Python中的每个对象都有一个引用计数，用来计数该对象在不同场所分别被引用了多少次。每当引用一次Python对象，相应的引用计数就增1，每当消毁一次Python对象，则相应的引用就减1，只有当引用计数为零时，才真正从内存中删除Python对象。
&lt;a href=&#34;http://www.cnblogs.com/yuyan/archive/2012/04/21/2461673.html&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下是一些例子：&lt;/p&gt;

&lt;p&gt;In [19]:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# variable 动态创建一个新的变量，但是，list，tuple，dictionary 却不会创建新的实例
a= 1
b = a
print id(a)
print id(b)
​
b = 3
print &amp;quot;change b to 3 &amp;quot;
print  &amp;quot;a: %s, b: %s&amp;quot; %(a ,b)
print &amp;quot;a id is : %s; b id is : %s&amp;quot; %(id(a),id(b))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;out:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;42295960
42295960
change b to 3
a: 1, b: 3
a id is : 42295960; b id is : 42295912
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In [25]:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# list
a= [1,2,3]
b = a   # 引用
print id(a)
print id(b)
​
b[2] = 6
print &amp;quot;change b to 3 &amp;quot;
print  &amp;quot;a: %s, b: %s&amp;quot; %(a ,b)
print &amp;quot;a id is : %s; b id is : %s&amp;quot; %(id(a),id(b))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;out：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;66189960
66189960
change b to 3
a: [1, 2, 6], b: [1, 2, 6]
a id is : 66189960; b id is : 66189960
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In [38]:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# list
a= [1,2,3]
b = a[:] # 值拷贝， 创建了新的对象实例
print id(a)
print id(b)
​
b[2] = 6
print &amp;quot;change b to 3 &amp;quot;
print  &amp;quot;a: %s, b: %s&amp;quot; %(a ,b)
print &amp;quot;a id is : %s; b id is : %s&amp;quot; %(id(a),id(b))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;out：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;65422344
65421832
change b to 3
a: [1, 2, 3], b: [1, 2, 6]
a id is : 65422344; b id is : 65421832
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In [32]:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# dictionary
a= {&#39;ta&#39;:11,&#39;tb&#39;:22,&#39;tc&#39;:33}
b = a # 引用，改变的是原实例的值
print id(a)
print id(b)
​
b[&#39;tb&#39;] = 6
print &amp;quot;change b to 3 &amp;quot;
print  &amp;quot;a: %s,\n b: %s&amp;quot; %(a ,b)
print &amp;quot;a id is : %s;\n b id is : %s&amp;quot; %(id(a),id(b))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;out：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;66214904
66214904
change b to 3
a: {&#39;tb&#39;: 6, &#39;tc&#39;: 33, &#39;ta&#39;: 11},
 b: {&#39;tb&#39;: 6, &#39;tc&#39;: 33, &#39;ta&#39;: 11}
a id is : 66214904;
 b id is : 66214904
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In [36]:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# tuple 元组用&amp;quot;()&amp;quot;标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。
a= (1,2,3)
b = a
print id(a)
print id(b)
​
# b[0] = 6
print &amp;quot;change b to 3 &amp;quot;
print  &amp;quot;a: %s,\n b: %s&amp;quot; %(a ,b)
print &amp;quot;a id is : %s;\n b id is : %s&amp;quot; %(id(a),id(b))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;out：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;66132296
66132296
change b to 3
a: (1, 2, 3),
 b: (1, 2, 3)
a id is : 66132296;
 b id is : 66132296
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In [9]:此案例的问题来自&lt;a href=&#34;http://www.cnblogs.com/yuyan/archive/2012/04/21/2461673.html&#34;&gt;博文&lt;/a&gt; ，经改进。如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def add_list(p):
    pt = p +[5,6]  # 1
    p = p + [5,6]  # 2   1 和2 是等价的，没有将值返回， ‘=’左边的变量，都是函数内部生成的局部临时对象，并没有返回，故不会修改传入参数的值。
    # 此处和静态语言的理解方式是一样的。
​
p1 = [1,2,3]
add_list(p1)  #1 和2 是等价的，没有改变返回值
print p1
​
​
def add_list2(p):
    p += [5,6]
p2 = [1,2,3]
add_list2(p2)
print p2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;out：​&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1, 2, 3]
[1, 2, 3, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此处‘=’号左边的p 应该是一个函数新建的一个局部的、临时的对象实例，等号的右边的p是才是函数传进来的，由于临时的“P”并没有返回，故肯定不会改变传入list的值。此处和静态语言应该是一致的。 所以，它并没有修改原来的p引用。&lt;/p&gt;

&lt;p&gt;In [6]:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;help(&#39;+=&#39;)

An augmented assignment expression like &amp;quot;x += 1&amp;quot; can be rewritten as
&amp;quot;x = x + 1&amp;quot; to achieve a similar, but not exactly equal effect. In the
augmented version, &amp;quot;x&amp;quot; is only evaluated once. Also, when possible,
the actual operation is performed *in-place*, meaning that rather than
creating a new object and assigning that to the target, the old object
is modified instead.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In [11]:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 字典引用
a = []
b = {&#39;num&#39;:0, &#39;sqrt&#39;:0}
resurse = [1,2,3]
for i in resurse:
  b[&#39;num&#39;] = i
  b[&#39;sqrt&#39;] = i * i
  a.append(b)
print &amp;quot;a: &amp;quot;,a
​
d=[]
for i in resurse:
    b[&#39;num&#39;] = i
    b[&#39;sqrt&#39;] = i * i
    d1 = b.copy()
    d.append(d1)
print &amp;quot;d: &amp;quot;,d
​
c=[]
for i in resurse:
    c.append({&amp;quot;num&amp;quot;:i, &amp;quot;sqrt&amp;quot;:i*i})
print &amp;quot;c: &amp;quot;,c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;out：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;​a:  [{&#39;num&#39;: 3, &#39;sqrt&#39;: 9}, {&#39;num&#39;: 3, &#39;sqrt&#39;: 9}, {&#39;num&#39;: 3, &#39;sqrt&#39;: 9}]
d:  [{&#39;num&#39;: 1, &#39;sqrt&#39;: 1}, {&#39;num&#39;: 2, &#39;sqrt&#39;: 4}, {&#39;num&#39;: 3, &#39;sqrt&#39;: 9}]
c:  [{&#39;num&#39;: 1, &#39;sqrt&#39;: 1}, {&#39;num&#39;: 2, &#39;sqrt&#39;: 4}, {&#39;num&#39;: 3, &#39;sqrt&#39;: 9}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;b[&amp;lsquo;num&amp;rsquo;] = i  和 b[&amp;lsquo;sqrt&amp;rsquo;] = i * i  中的 b[&amp;lsquo;num&amp;rsquo;] 和 b[&amp;lsquo;sqrt&amp;rsquo;] 是已经&lt;strong&gt;压入list a 中元素的一个引用&lt;/strong&gt;，故它可以在不断地改变list 内部变量的值。&lt;/p&gt;

&lt;p&gt;单步调试可以看到，&lt;/p&gt;

&lt;p&gt;a中值的变化情况：*以执行完语句a.append(b)为节点 *&lt;/p&gt;

&lt;p&gt;[{&amp;lsquo;num&amp;rsquo;: 1, &amp;lsquo;sqrt&amp;rsquo;: 1}]&lt;/p&gt;

&lt;p&gt;&amp;ndash;&amp;gt; [{&amp;lsquo;num&amp;rsquo;: 2, &amp;lsquo;sqrt&amp;rsquo;: 4},{&amp;lsquo;num&amp;rsquo;: 2, &amp;lsquo;sqrt&amp;rsquo;: 4}]&lt;/p&gt;

&lt;p&gt;&amp;ndash;&amp;gt;  [{&amp;lsquo;num&amp;rsquo;: 3, &amp;lsquo;sqrt&amp;rsquo;: 9}, {&amp;lsquo;num&amp;rsquo;: 3, &amp;lsquo;sqrt&amp;rsquo;: 9}, {&amp;lsquo;num&amp;rsquo;: 3, &amp;lsquo;sqrt&amp;rsquo;: 9}]&lt;/p&gt;

&lt;p&gt;在append(b)到list a之前获得b的值拷贝，将值append 到list a 也可以达到目标。如&lt;strong&gt;示例d&lt;/strong&gt;所示。&lt;/p&gt;

&lt;p&gt;​
当然，示例C是更加简洁的一个版本，这里应该还有迭代器的知识点，暂时还没折腾内部，待到下次和生成器一起分析。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>python运算符一些注意项</title>
      <link>https://tmhm.github.io/2016/05/19/python%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E9%A1%B9/</link>
      <pubDate>Thu, 19 May 2016 06:07:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/05/19/python%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E9%A1%B9/</guid>
      <description>

&lt;h3 id=&#34;浮点除-和-整除&#34;&gt;&amp;rsquo;/&amp;lsquo;浮点除，和&amp;rsquo;//&amp;lsquo;整除&lt;/h3&gt;

&lt;p&gt;单个&amp;rsquo;/&amp;lsquo;是浮点除，两个除号&amp;rsquo;//&amp;lsquo;是整除&lt;/p&gt;

&lt;p&gt;整除也适用于浮点数。但是，用整除计算浮点除的结果只是在整除的结果上*浮点化*，比如3.6//2.1,结果是1.0。&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = 5
for i in [1.0,1.5,2,3,4,5,6]:
        b= 5//i
        c = 5/i
        print a, b,c
print &amp;quot;3.6/2.1 =&amp;quot;,3.6/2.1
print &amp;quot;3.6//2.1 =&amp;quot;,3.6//2.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;out：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;5 5.0 5.0
5 3.0 3.33333333333
5 2 2
5 1 1
5 1 1
5 1 1
5 0 0
3.6/2.1 = 1.71428571429
3.6//2.1 = 1.0
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>python一些内建函数(map,zip,filter,reduce,yield等)</title>
      <link>https://tmhm.github.io/2016/05/17/some-built-in-function-of-python-mapzipfilterreduceyield/</link>
      <pubDate>Tue, 17 May 2016 15:06:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/05/17/some-built-in-function-of-python-mapzipfilterreduceyield/</guid>
      <description>

&lt;h4 id=&#34;map函数&#34;&gt;map函数&lt;/h4&gt;

&lt;p&gt;Python实际上提供了一个内置的工具，map函数。这个函数的主要功能是对一个序列对象中的每一个元素应用被传入的函数，并且返回一个包含了所有函数调用结果的一个列表。&lt;/p&gt;

&lt;p&gt;map?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Docstring:
map(function, sequence[, sequence, ...]) -&amp;gt; list

Return a list of the results of applying the function to the items of
the argument sequence(s).  If more than one sequence is given, the
function is called with an argument list consisting of the corresponding
item of each sequence, substituting None for missing values when not all
sequences have the same length.  If the function is None, return a list of
the items of the sequence (or a list of tuples if more than one sequence).
Type:      builtin_function_or_method
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面三个例子参考了&lt;a href=&#34;http://my.oschina.net/zyzzy/blog/115096&#34;&gt;该博文&lt;/a&gt;
​
对可迭代函数&amp;rsquo;iterable&amp;rsquo;中的每一个元素应用‘function’方法，将结果作为list返回。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def add100(x):
    return x+100
hh = [11,22,33]
map(add100,hh)
Out[2]:
[111, 122, 133]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果给出了额外的可迭代参数，则对每个可迭代参数中的元素‘并行’的应用‘function’。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def abc(a, b, c):
    return a*10000 + b*100 + c
​
list1 = [11,22,33]
list2 = [44,55,66]
list3 = [77,88,99]
map(abc,list1,list2,list3)
Out[3]:
[114477, 225588, 336699]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果&amp;rsquo;function&amp;rsquo;给出的是‘None’，自动假定一个‘identity’函数（这个‘identity’不知道怎么解释，看例子吧）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list1 = [11,22,33]
map(None,list1)
Out[5]:
[11, 22, 33]


list1 = [11,22,33]
list2 = [44,55,66]
list3 = [77,88,99]
map(None,list1,list2,list3)
Out[6]:
[(11, 44, 77), (22, 55, 88), (33, 66, 99)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;zip函数&#34;&gt;zip函数&lt;/h4&gt;

&lt;p&gt;以下参考了&lt;a href=&#34;http://www.bkjia.com/Pythonjc/664161.html&#34;&gt;博文&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;函式说明：zip(seq1[,seq2 [&amp;hellip;]])-&amp;gt;[(seq1(0),seq2(0)&amp;hellip;,(&amp;hellip;)]。 同时循环两个一样长的函数，返回一个包含每个参数元组对应元素的元组。若不一致，采取截取方式，使得返回的结果元组的长度为各参数元组长度最小值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for x,y in zip([1,2,3],[4,5,6]):
    print x,y
for x,y in zip([1,2,3],[4,5,6]):
    print x,y
1 4
2 5
3 6


for x,y in zip([1,2,3],[5,6]):
    print x,y
1 5
2 6
        
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;filter函数&#34;&gt;filter函数&lt;/h4&gt;

&lt;p&gt;filter(bool_func,seq)：此函数的功能相当于过滤器。 调用一个布尔函数bool_func来迭代遍历每个seq中的元素，返回一个使bool_seq返回值为true的元素的序列。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;filter(lambda x:x%2==0,[1,2,3,4,6,5,7])
Out[15]:
[2, 4, 6]   
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;reduce函数&#34;&gt;reduce函数&lt;/h4&gt;

&lt;p&gt;reduce(func,seq[,init])：func为二元函数，将func作用于seq序列的元素，每次携带一对（先前的结果以及下一个序列的元素），连续的将现有的结果和下一个值作用在获得的随后的结果上，最后减少我们的序列为一个单一的返回值：如果初始值init给定，第一个比较会是init和第一个序列元素而不是序列的头两个元素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;reduce(lambda x,y:x+y,[1,2,3,4])
Out[22]:
10

reduce(lambda x,y: x-y,[1,2,3,4,5],19)
reduce(lambda x,y: x-y,[1,2,3,4,5],19)
Out[23]:
4

reduce(lambda x,y: x-y,[1,2,3,5],5)
Out[21]:
-6
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;isinstance&#34;&gt;isinstance&lt;/h4&gt;

&lt;p&gt;isinstance(object, classinfo)  判断一个对象是否是一个已知的类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;isinstance(object, class-or-type-or-tuple) -&amp;gt; bool

Return whether an object is an instance of a class or of a subclass thereof.
With a type as second argument, return whether that is the object&#39;s type.
The form using a tuple, isinstance(x, (A, B, ...)), is a shortcut for
isinstance(x, A) or isinstance(x, B) or ... (etc.).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其第一个参数为对象，第二个为类型名或类型名的一个列表。其返回值为布尔型。若对象的类型与参数二的类型相同则返回True。若参数二为一个元组，则若对象类型与元组中类型名之一相同即返回True。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tes = list()
tes.append(3)
ta= &#39;a&#39;,&#39;b&#39;
print tes
print isinstance(tes, list)
print isinstance(ta, tuple)

print isinstance(tes,(int, tuple, list))
print isinstance(tes,(int, tuple))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Out:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [3]
    True
    True
    True
    False
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;id&#34;&gt;id&lt;/h4&gt;

&lt;p&gt;查看object 地址&lt;/p&gt;

&lt;p&gt;in：
&lt;code&gt;print id.__doc__
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Out：​
 &lt;code&gt;id(object) -&amp;gt; integer
&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Return the identity of an object.  This is guaranteed to be unique among
    simultaneously existing objects.  (Hint: it&#39;s the object&#39;s memory address.)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;assert&#34;&gt;assert&lt;/h4&gt;

&lt;p&gt;断言&lt;/p&gt;

&lt;p&gt;Python中assert用来判断语句的真假，如果&lt;strong&gt;为假的时候，将触发AssertionError错误&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = None
assert a != None
print a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;out：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language----------------------------------------------------------------------------&#34;&gt;AssertionError                            Traceback (most recent call last)
&amp;lt;ipython-input-1-4165ca7bb901&amp;gt; in &amp;lt;module&amp;gt;()
      1
      2 a = None
----&amp;gt; 3 assert a != None
      4 print a

AssertionError:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a=[1,2,3]
# a = None
assert len(a) &amp;lt; 5  # 为真通过
assert a != None
print a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;out：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;min-max&#34;&gt;min &amp;amp;&amp;amp; max&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;c = [-10, -45, 0, 5, 3, 50, 15, -20, 25]

print &amp;quot;min: %s&amp;quot; %c.index(min(c))  # 返回最小值
print &amp;quot;max: %s&amp;quot; %c.index(max(c)) # 返回最大值
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;out:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        min: 1
        max: 5
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>python &amp;&amp; anaconda &amp;&amp; pycharm工具包安装</title>
      <link>https://tmhm.github.io/2016/04/24/python--anaconda-pycharm-tools-install/</link>
      <pubDate>Sun, 24 Apr 2016 13:24:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/04/24/python--anaconda-pycharm-tools-install/</guid>
      <description>

&lt;p&gt;&lt;code&gt;$ conda update conda
&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;更新pip&#34;&gt;更新pip&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;python -m pip install --upgrade pip
&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;更新所有&#34;&gt;更新所有&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;conda update --all
&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;安装ffmpeg&#34;&gt;安装ffmpeg&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;conda install ffmpeg
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;不存在该包，用&lt;code&gt;anaconda search&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
[Anaconda2] C:\Users\xwei&amp;gt;anaconda search -t conda ffmpeg
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;groakat/ffmpeg-dev        |    2.4.3 | conda           | linux-64, win-64,osx-64
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[Anaconda2] C:\Users\xwei&amp;gt;conda install -c https://conda.anaconda.org/groakat ffmpeg-dev&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;安装theano&#34;&gt;安装theano&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://deeplearning.net/software/theano/install_windows.html#install-windows&#34;&gt;source for win-install&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://deeplearning.net/software/theano/install.html&#34;&gt;source for install&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/33671453/g-not-detected-while-data-set-goes-larger-is-there-any-limit-to-matrix-size&#34;&gt;stack overflow&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[Anaconda2] C:\Users\xwei\Desktop\lstm-test&amp;gt;
&amp;gt;anaconda search -t conda theano&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jaikumarm/theano          |    0.8.2 | conda           | linux-64, win-32, win-64, linux-32, osx-64  : Optimizing compiler for evaluating mathematical expressions on CPUs and GPUs.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;[Anaconda2] C:\Users\xwei\Desktop\lstm-test&amp;gt;
&amp;gt;conda install -c &lt;a href=&#34;https://conda.anaconda.org/jaikumarm&#34;&gt;https://conda.anaconda.org/jaikumarm&lt;/a&gt; theano&lt;/p&gt;

&lt;p&gt;[Anaconda2] C:\Users\xwei\Desktop\lstm-test&amp;gt;python lstm.py&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;WARNING (theano.configdefaults): g++ not detected ! Theano will be unable to execute optimized C-implementations (for both CPU and GPU) and will default to Python implementations. Performance will be severely degraded. To remove this warning, set Theano flags cxx to an empty string.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;[Anaconda2] C:\Users\xwei&amp;gt; &lt;strong&gt;conda install mingw libpython&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;之后即可以在anaconda Prompt 里面直接调用theano ，包括g++&lt;/li&gt;
&lt;li&gt;运行&lt;a href=&#34;http://www.deeplearning.net/tutorial/lstm.html#lstm&#34;&gt;LSTM Networks for Sentiment Analysis&lt;/a&gt; 明显快了很多很多，直接在cpu下运行纯python代码，一两分钟才出来第一次迭代， 安装之后，运行c代码的时候，基本上两三秒一次迭代。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;安装出现anaconda-python-installation-error&#34;&gt;安装出现Anaconda Python installation error&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://images2015.cnblogs.com/blog/781469/201606/781469-20160612222301152-884209750.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;解决参考&lt;a href=&#34;http://stackoverflow.com/questions/34780267/anaconda-python-installation-error&#34;&gt;stackoverflow&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;First, open a DOS prompt and admin rights. Then, go to your Anaconda2\Scripts folder.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;conda update conda&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;and allow all updates. One of the updates should be menuinst.&lt;/p&gt;

&lt;p&gt;Then, change to the Anaconda2\Lib directory, and type in the following command:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;..\python _nsis.py mkmenus&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Wait for this to complete, then check your Start menu for the new shortcuts.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ipython notebook 一些技巧</title>
      <link>https://tmhm.github.io/2016/04/20/ipython-notebook-%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Wed, 20 Apr 2016 09:40:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/04/20/ipython-notebook-%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;在模块后面输入：？，运行可以显示说明；&lt;/li&gt;
&lt;li&gt;输入：？？，运行可以显示源代码。&lt;/li&gt;
&lt;li&gt;输入%matplotlib inline将matplotlib库导入，要显示的图片就可以嵌入到网页中了&lt;/li&gt;
&lt;li&gt;%prun用于代码的执行性能分析，可以作为行命令和单元命令使用&lt;/li&gt;
&lt;li&gt;在网页中输入%pylab inline，将自动导入SciPy、NumPy、Matplotlib模块&lt;/li&gt;
&lt;li&gt;显示行号：在编辑模式，esc键启用之后，按键盘L键，即可开启当前单元格行号&lt;/li&gt;
&lt;li&gt;esc进入命令模式，然后按h键进入快捷键帮助界面。&lt;/li&gt;
&lt;li&gt;多查看&lt;a href=&#34;https://plot.ly/python/ipython-notebook-tutorial/&#34;&gt;Ipython notebook tutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>QT环境下，全局变量共享问题</title>
      <link>https://tmhm.github.io/2016/03/08/qt_shared_global_var/</link>
      <pubDate>Tue, 08 Mar 2016 12:47:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/03/08/qt_shared_global_var/</guid>
      <description>&lt;p&gt;&lt;strong&gt;开始的技术路线是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;首先有两个主线程：&lt;/p&gt;
&lt;p&gt;　　1，gui线程&lt;/p&gt;
&lt;p&gt;　　2，等待客户端socket连接用的，listen线程&lt;/p&gt;
&lt;p&gt;　　（当有客户端连接时，即creat一个新的线程2用来跟客户端通信，再来新的客户端，继续creat新的work线程3用于通信，以此类推，目前最多可以creat5个线程，即可以同时跟5台客户端通信，设置了监听的socket服务器最多监听5个队列。线程2继续listen）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;出现的问题是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　用来通信的work线程3，收到一个来自客户端的xml文件，然后解析文件，并将其数据放在一个全局的静态struct数组里。数据正常，线程2和线程3均可以看到已经更新的数据值。但是，&lt;/p&gt;
&lt;p&gt;　　当gui线程去访问时，发现数据并没有更新到其线程，在gui线程下改变该全局变量的数值，也并没有更新到

&lt;p&gt;&lt;em&gt;一博主，有如此解释&lt;/em&gt;：&lt;/p&gt;
&lt;div id=&#34;article_content&#34; class=&#34;article_content&#34;&gt;&lt;a href=&#34;http://blog.csdn.net/lmh12506/article/details/8452700&#34; target=&#34;_blank&#34;&gt;其实在Linux 中，新建的线程并不是在原先的进程中，而是系统通过一个系统调用clone() 。该系统copy 了一个和原先进程完全一样的进程，并在这个进程中执行线程函数。不过这个copy 过程和fork 不一样。copy 后的进程和原先的进程共享了所有的变量，运行环境（clone的实现是可以指定新进程与老进程之间的共享关系，100%共享就表示创建了一个线程）。这样，原先进程中的变量变动在copy 后的进程中便能体现出来。&lt;/a&gt;&lt;/div&gt;
&lt;div class=&#34;bdsharebuttonbox tracking-ad bdshare-button-style0-16&#34; data-mod=&#34;popu_172&#34; data-bd-bind=&#34;1457096202549&#34;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div id=&#34;digg&#34;&gt;&amp;nbsp;不过，问题并没有清晰化。&lt;/div&gt;


&lt;div&gt;想到的解决方案暂时有两种：&lt;/div&gt;
&lt;div&gt;　　1，不在work线程里面解析数据，直接在gui线程里面解析数据。&lt;/div&gt;
&lt;div&gt;&amp;nbsp;　　2，采用&lt;a href=&#34;https://www.ibm.com/developerworks/cn/linux/thread/posix_threadapi/part2/&#34; target=&#34;_blank&#34;&gt;线程私有数据&lt;/a&gt;&lt;/div&gt;


&lt;p&gt;（此处出现过，小插曲：QT的变量查看器，在调试时不太稳定，更新过后的值在窗口中查看，并没有得到及时更新，需要通过程序判定验证！）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://images2015.cnblogs.com/blog/781469/201603/781469-20160309170140991-312431222.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;由于程序需要在线程创建之后必须返回到gui主线程，所以采用创建两次线程的方式：创建线程A，返回，然后在线程A里面创建&lt;/p&gt;
&lt;p&gt;在多线程POSIX标准下，主线程（1），即是GUI线程。它初始化一个类，并调用其一个成员函数创建一个线程3（ininlistenThred）【不知，为什么不从2开始？】，然后在线程3里面一直循环检测是否有新的客户端发来socket连接。当有新的客户端连接上时，即创建一个新的线程专门用于socket通信。&lt;/p&gt;
&lt;p&gt;此时有一客户端连接上，创建了通信工作线程4（listenthreadwork）。&lt;/p&gt;

&lt;p&gt;输出g_buf[0].carid的代码位置分别为：&lt;/p&gt;
&lt;p&gt;1，initlistenthread线程在进入循环入口 即打印出：&lt;/p&gt;
&lt;div class=&#34;cnblogs_code&#34;&gt;
&lt;p&gt;for( ; ; )&lt;br /&gt;    {&lt;/p&gt;
&lt;p&gt;　　 &amp;nbsp;qDebug(&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;listenthread g_buf[0].carid: %s &lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;,g_buf[&lt;span style=&#34;color: #800080;&#34;&gt;0&lt;/span&gt;&lt;span&gt;].carid);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&#34;__mceDel&#34;&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;&amp;nbsp; 　　char&lt;/span&gt; *t = &amp;amp;(g_buf[&lt;span style=&#34;color: #800080;&#34;&gt;0&lt;/span&gt;].carid[&lt;span style=&#34;color: #800080;&#34;&gt;0&lt;/span&gt;&lt;span&gt;]);&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;em id=&#34;__mceDel&#34;&gt;&lt;em id=&#34;__mceDel&#34;&gt;&lt;span style=&#34;color: #000000;&#34;&gt;　　qDebug(&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;dizhi: %d&lt;/span&gt;&lt;/em&gt;&lt;span style=&#34;color: #800000;&#34;&gt; \n\n&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;,&amp;amp;t);&lt;br /&gt;//......&lt;br /&gt;}&lt;/em&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;2，gui主线程在点击按钮的时候，即打印：&lt;/p&gt;
&lt;div class=&#34;cnblogs_code&#34;&gt;
&lt;pre&gt;qDebug(&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;mainwindow g_buf[0].carid: %s&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;,g_buf[&lt;span style=&#34;color: #800080;&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;].carid);
&lt;/span&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;char&lt;/span&gt; *t = &amp;amp;(g_buf[&lt;span style=&#34;color: #800080;&#34;&gt;0&lt;/span&gt;].carid[&lt;span style=&#34;color: #800080;&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;]);
qDebug(&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;dizhi: %d \n\n&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;,&amp;amp;t);&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;3，listenthreadwork线程在循环工作的时候开始就打印信息：（一进去此线程就会先打印一次值，然后每次收到文件就会打印一次）&lt;/p&gt;
&lt;div class=&#34;cnblogs_code&#34;&gt;
&lt;pre&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;for&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;( ; ; )
    {
        qDebug(&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;listenthreadwork g_buf[0].carid: %s&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;,g_buf[&lt;span style=&#34;color: #800080;&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;].carid);
        &lt;/span&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;char&lt;/span&gt; *t = &amp;amp;(g_buf[&lt;span style=&#34;color: #800080;&#34;&gt;0&lt;/span&gt;].carid[&lt;span style=&#34;color: #800080;&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #000000;&#34;&gt;]);
        qDebug(&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;dizhi: %d \n\n&lt;/span&gt;&lt;span style=&#34;color: #800000;&#34;&gt;&#34;&lt;/span&gt;,&amp;amp;&lt;span style=&#34;color: #000000;&#34;&gt;t);
&lt;/span&gt;&lt;span style=&#34;color: #008000;&#34;&gt;//&lt;/span&gt;&lt;span style=&#34;color: #008000;&#34;&gt;.........&lt;/span&gt;
}&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线程3和4的值一样的！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程1跟另外两个线程是不同的值！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;nbsp;跟类没关系的两个线程值一样&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://images2015.cnblogs.com/blog/781469/201603/781469-20160309171434179-548213179.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://images2015.cnblogs.com/blog/781469/201603/781469-20160309191531804-530669003.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://images2015.cnblogs.com/blog/781469/201603/781469-20160309191541944-1721815549.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>