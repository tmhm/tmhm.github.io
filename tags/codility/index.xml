<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Codility on Well</title>
    <link>https://tmhm.github.io/tags/codility/</link>
    <description>Recent content in Codility on Well</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>wells217@163.com (Well)</managingEditor>
    <webMaster>wells217@163.com (Well)</webMaster>
    <copyright>(c) 2017 Well.</copyright>
    <lastBuildDate>Sat, 17 Sep 2016 10:44:00 +0000</lastBuildDate>
    <atom:link href="https://tmhm.github.io/tags/codility/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>stacks and queues--codility</title>
      <link>https://tmhm.github.io/2016/09/17/stacks-and-queues--codility/</link>
      <pubDate>Sat, 17 Sep 2016 10:44:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/09/17/stacks-and-queues--codility/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.7.1&#34;&gt;1. Nesting&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.7.2&#34;&gt;2. StoneWall&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.7.3&#34;&gt;3. Brackets&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.7.4&#34;&gt;4. Finsh&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id = &#34;1.7&#34;&gt;
lesson 7: &lt;i&gt;stacks and queues&lt;/i&gt;
&lt;/h3&gt;

&lt;h4 id = &#34;1.7.1&#34;&gt;
1. Nesting
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Determine whether given string of parentheses is properly nested.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A string S consisting of N characters is called properly nested if:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;S is empty;&lt;/li&gt;
&lt;li&gt;S has the form &amp;laquo;(U)&amp;raquo; where U is a properly nested string;&lt;/li&gt;
&lt;li&gt;S has the form &amp;laquo;VW&amp;raquo; where V and W are properly nested strings.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example, string &amp;laquo;(()(())())&amp;raquo; is properly nested but string &amp;laquo;())&amp;raquo; isn&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Assume that:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;N is an integer within the range [0..1,000,000];&lt;/li&gt;
&lt;li&gt;string S consists only of the characters &amp;laquo;(&amp;raquo; and/or &amp;laquo;)&amp;raquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Complexity:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;expected worst-case time complexity is O(N);&lt;/li&gt;
&lt;li&gt;expected worst-case space complexity is O(1) (not counting the storage required for input arguments).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;solution:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;li&gt;used stack&lt;/li&gt;
&lt;li&gt;must have &amp;laquo;(&amp;raquo; before &amp;laquo;)&amp;raquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(S):
    # write your code in Python 2.7
    tmp = 0
    for elem in S:
        if elem == &amp;quot;(&amp;quot;:
            tmp += 1
        elif elem == &amp;quot;)&amp;quot;:
            tmp -= 1
            if tmp &amp;lt; 0:
                return 0
    if tmp == 0:
        return 1
    else:
        return 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.7.2&#34;&gt;
2. StoneWall
&lt;/h4&gt;

&lt;p&gt;You are going to build a stone wall. The wall should be straight and N meters long, and its thickness should be constant; however, it should have different heights in different places. The height of the wall is specified by a zero-indexed array H of N positive integers. H[I] is the height of the wall from I to I+1 meters to the right of its left end. In particular, H[0] is the height of the wall&amp;rsquo;s left end and H[N−1] is the height of the wall&amp;rsquo;s right end.&lt;/p&gt;

&lt;p&gt;The wall should be built of cuboid stone blocks (that is, all sides of such blocks are rectangular). Your task is to compute the minimum number of blocks needed to build the wall.&lt;/p&gt;

&lt;p&gt;For example, given array H containing N = 9 integers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      H[0] = 8    H[1] = 8    H[2] = 5
      H[3] = 7    H[4] = 9    H[5] = 8
      H[6] = 7    H[7] = 4    H[8] = 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the function should return 7. The figure shows one possible arrangement of seven blocks.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://codility-frontend-prod.s3.amazonaws.com/media/task_img/stone_wall/media/auto/mp2e167f4181a5967a0844fbd70a3a5bfb.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Assume that:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;N is an integer within the range [1..100,000];&lt;/li&gt;
&lt;li&gt;each element of array H is an integer within the range [1..1,000,000,000].&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Cover &amp;laquo;Manhattan skyline&amp;raquo; using the minimum number of rectangles.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(H):
    # write your code in Python 2.7
    cnt = 0
    stack = []
    for elem in H:
        while len(stack)!= 0 and stack[-1] &amp;gt; elem:
            stack.pop()

        if len(stack) != 0 and stack[-1] == elem:
            pass
        else:
            stack.append(elem)
            cnt += 1
    return cnt

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.7.3&#34;&gt;
3. Brackets

&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Determine whether a given string of parentheses is properly nested.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Task description&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A string S consisting of N characters is considered to be properly nested if any of the following conditions is true:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;S is empty;&lt;/li&gt;
&lt;li&gt;S has the form &amp;laquo;(U)&amp;raquo; or &amp;laquo;[U]&amp;raquo; or &amp;laquo; {
    U
}&amp;raquo; where U is a properly nested string;&lt;/li&gt;
&lt;li&gt;S has the form &amp;laquo;VW&amp;raquo; where V and W are properly nested strings.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example, the string &amp;laquo; {
        [()()]
}&amp;raquo; is properly nested but &amp;laquo;([)()]&amp;raquo; is not.&lt;/p&gt;

&lt;p&gt;For example, given S = &amp;laquo;{[()()]}&amp;laquo;, the function should return 1 and given S = &amp;laquo;([)()]&amp;laquo;, the function should return 0, as explained above.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Assume that:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;N is an integer within the range [0..200,000];&lt;/li&gt;
&lt;li&gt;string S consists only of the following characters: &amp;laquo;(&amp;raquo;, &amp;laquo;{&amp;raquo;, &amp;laquo;[&amp;laquo;, &amp;laquo;]&amp;raquo;, &amp;laquo;}&amp;raquo; and/or &amp;laquo;)&amp;raquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Complexity:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;expected worst-case time complexity is O(N);&lt;/li&gt;
&lt;li&gt;expected worst-case space complexity is O(N) (not counting the storage required for input arguments).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用一个stack，当栈头和新来的元素配对，即弹出，否则压栈。
注意：list为空的时候， 还有多个空值的list。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;solution：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def check(t,s):
    if len(t) &amp;lt; 1:
        return 0
    if s == &#39;)&#39; and t[-1] == &#39;(&#39;:
        return 1
    elif s == &#39;]&#39; and t[-1] == &#39;[&#39;:
        return 1
    elif s == &#39;}&#39; and t[-1] == &#39;{&#39;:
        return 1
    else:
        return 0


def solution(S):
    tmp = []
    for elem in S:
        if elem == &#39; &#39;:
            continue
        if check(tmp, elem):
            tmp.pop()
        else:
            tmp.append(elem)
            #print &amp;quot;append: %s, len: %s&amp;quot; %(elem,len(tmp))

    if len(tmp) &amp;lt; 1:
        return 1
    else:
        return 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.7.4&#34;&gt;

4. Fish

&lt;/h4&gt;

&lt;p&gt;Given two non-empty zero-indexed arrays A and B consisting of N integers. Arrays A and B represent N voracious fish in a river, ordered downstream along the flow of the river.&lt;/p&gt;

&lt;p&gt;The fish are numbered from 0 to N ? 1. If P and Q are two fish and P &amp;lt; Q, then fish P is initially upstream of fish Q. Initially, each fish has a unique position.&lt;/p&gt;

&lt;p&gt;Fish number P is represented by A[P] and B[P]. Array A contains the sizes of the fish. All its elements are unique. Array B contains the directions of the fish. It contains only 0s and/or 1s, where:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0 represents a fish flowing upstream,&lt;/li&gt;
&lt;li&gt;1 represents a fish flowing downstream.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If two fish move in opposite directions and there are no other (living) fish between them, they will eventually meet each other. Then only one fish can stay alive ? the larger fish eats the smaller one. More precisely, we say that two fish P and Q meet each other when P &amp;lt; Q, B[P] = 1 and B[Q] = 0, and there are no living fish between them. After they meet:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If A[P] &amp;gt; A[Q] then P eats Q, and P will still be flowing downstream,&lt;/li&gt;
&lt;li&gt;If A[Q] &amp;gt; A[P] then Q eats P, and Q will still be flowing upstream.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We assume that all the fish are flowing at the same speed. That is, fish moving in the same direction never meet. The goal is to calculate the number of fish that will stay alive.&lt;/p&gt;

&lt;p&gt;For example, consider arrays A and B such that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      A[0] = 4    B[0] = 0
      A[1] = 3    B[1] = 1
      A[2] = 2    B[2] = 0
      A[3] = 1    B[3] = 0
      A[4] = 5    B[4] = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Initially all the fish are alive and all except fish number 1 are moving upstream. Fish number 1 meets fish number 2 and eats it, then it meets fish number 3 and eats it too. Finally, it meets fish number 4 and is eaten by it. The remaining two fish, number 0 and 4, never meet and therefore stay alive.&lt;/p&gt;

&lt;p&gt;For example, given the arrays shown above, the function should return 2, as explained above.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Assume that:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;N is an integer within the range [1..100,000];&lt;/li&gt;
&lt;li&gt;each element of array A is an integer within the range [0..1,000,000,000];&lt;/li&gt;
&lt;li&gt;each element of array B is an integer that can have one of the following values: 0, 1;&lt;/li&gt;
&lt;li&gt;the elements of A are all distinct.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Complexity:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;expected worst-case time complexity is O(N);&lt;/li&gt;
&lt;li&gt;expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;考虑到所有鱼的速度一致，那么从上游开始check，
前面的鱼如果是往上游走的话，即永远不会被吃或者吃其他鱼,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def solution(A, B):
    # write your code in Python 2.7
    # record the num of fish with downstream
    lastFishDir = 0
    stackTmp = []

    # check fish from upstream
    for fish, curDir in zip(A,B):
        if lastFishDir &amp;lt; 1:
            stackTmp.append(fish)
            #lastFishDir += curDir
        else:
            if curDir == 0:
                while lastFishDir &amp;gt; 0 and fish &amp;gt; stackTmp[-1]:
                    stackTmp.pop()
                    lastFishDir -= 1
                if len(stackTmp) &amp;gt; 0 and fish &amp;lt; stackTmp[-1]:
                    continue
                stackTmp.append(fish)
            else:
                stackTmp.append(fish)

        lastFishDir += curDir
    return len(stackTmp)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;思考方式很重要：&lt;/p&gt;

&lt;p&gt;由于，上游的鱼如果是往上游走的话，即永远不会被吃或者吃其他鱼,
如果把这样的鱼也放在stack里面，每次fight之后，不太好处理，
故我们可以把一定可以存活的鱼直接计数， 将需要fight的鱼放在stack里面&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;[100%]&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A, B):
    lastFishDir = 0  # record the num of fish with downstream
    stackDown = []
    aliveCnt = 0

    # check fish from upstream
    for fish, curDir in zip(A,B):
        if curDir == 1:
            # only the downstream fish need fight,
            stackDown.append(fish)
        else:
            while lastFishDir &amp;gt; 0 :
                if fish &amp;gt; stackDown[-1]:
                    stackDown.pop()
                    lastFishDir -= 1
                else:
                    break
            else:
                aliveCnt += 1

        lastFishDir += curDir

    return len(stackDown)+aliveCnt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该博主分析的很详细，&lt;a href=&#34;https://codesays.com/2014/solution-to-fish-by-codility/&#34;&gt;https://codesays.com/2014/solution-to-fish-by-codility/&lt;/a&gt;
&amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def solution(A, B):
    alive_count = 0        # The number of fish that will stay alive
    downstream = []        # To record the fishs flowing downstream
    downstream_count = 0   # To record the number of elements in downstream

    for index in xrange(len(A)):
        # Compute for each fish
        if B[index] == 1:
            # This fish is flowing downstream. It would
            # NEVER meet the previous fishs. But possibly
            # it has to fight with the downstream fishs.
            downstream.append(A[index])
            downstream_count += 1
        else:
            # This fish is flowing upstream. It would either
            #    eat ALL the previous downstream-flow fishs,
            #    and stay alive.
            # OR
            #    be eaten by ONE of the previous downstream-
            #    flow fishs, which is bigger, and died.
            while downstream_count != 0:
                # It has to fight with each previous living
                # fish, with nearest first.
                if downstream[-1] &amp;lt; A[index]:
                    # Win and to continue the next fight
                    downstream_count -= 1
                    downstream.pop()
                else:
                    # Lose and die
                    break
            else:
                # This upstream-flow fish eat all the previous
                # downstream-flow fishs. Win and stay alive.
                alive_count += 1

    # Currently, all the downstream-flow fishs in stack
    # downstream will not meet with any fish. They will
    # stay alive.
    alive_count += len(downstream)

    return alive_count
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>sorting--codility</title>
      <link>https://tmhm.github.io/2016/09/14/sorting--codility/</link>
      <pubDate>Wed, 14 Sep 2016 09:36:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/09/14/sorting--codility/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.6.1&#34;&gt;1. Distinct&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.6.2&#34;&gt;2. Triangle&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.6.3&#34;&gt;2. MaxProductOfThree&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.6.4&#34;&gt;4. NumberOfDiscIntersections&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id = &#34;1.6&#34;&gt;
lesson 6: &lt;i&gt;sorting&lt;/i&gt;
&lt;/h3&gt;

&lt;h4 id=&#34;exercise&#34;&gt;exercise&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Problem:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You are given a zero-indexed array A consisting of n &amp;gt; 0 integers; you must return the number of unique values in array A.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Solution O(nlogn):&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;First, sort array A; similar values will then be next to each other. Finally, just count the number of distinct pairs in adjacent cells.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The number of distinct values — O(nlogn).
def distinct(A):
        n = len(A)
        A.sort()
        result = 1
        for k in xrange(1, n):
                if A[k] != A[k - 1]: result += 1
        return result
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The time complexity is O(n log n), in view of the sorting time.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id = &#34;1.6.1&#34;&gt;
1. Distinct
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Compute number of distinct values in an array.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;将list保存为set 即可&lt;/li&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;li&gt;也可以排序，然后对不同数进行计数，如exercise那样&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    Aset = set(A)
    return len(Aset)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.6.2&#34;&gt;
2. Triangle
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Determine whether a triangle can be built from a given set of edges.
&lt;a href=&#34;https://codesays.com/2014/solution-to-triangle-by-codility/&#34;&gt;https://codesays.com/2014/solution-to-triangle-by-codility/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;On one hand, there is no false triangular. Since the array is sorted, we already know A[index] &amp;lt; = A[index+1] &amp;lt;= A[index+2], and all values are positive. A[index] &amp;lt;= A[index+2], so it must be true that A[index] &amp;lt; A[index+1] + A[index+2]. Similarly, A[index+1] &amp;lt; A[index] + A[index+2]. Finally, we ONLY need to check &lt;strong&gt;A[index]+A[index+1] &amp;gt; A[index+2]&lt;/strong&gt; to confirm the existence of triangular.&lt;/p&gt;

&lt;p&gt;On the other hand, there is no underreporting triangular. If the inequality can hold for three out-of-order elements, to say, A[index]+A[index+m] &amp;gt; A[index+n], where n&amp;gt;m&amp;gt;1. Again, because the array is sorted, we must have A[index] &amp;lt; = A[index+m-1] and A[index+m+1] &amp;lt;= A[index + n]. So A[index+m-1] +A[index+m] &amp;gt;= A[index]+A[index+m] &amp;gt; A[index+n] &amp;gt;= A[index+m+1]. After simplification, A[index+m-1] +A[index+m] &amp;gt; A[index+m+1]. In other words, if we have any inequality holding for out-of-order elements, we MUST have AT LEAST an inequality holding for three consecutive elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    length = len(A)
    if length &amp;lt; 3:
        return 0
    A.sort()
    for idx in xrange(0,length -2):
        if A[idx]+A[idx + 1] &amp;gt; A[idx + 2]:
            return 1
    return 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.6.3&#34;&gt;
3. MaxProductOfThree
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Maximize A[P] * A[Q] * A[R] for any triplet (P, Q, R).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;solution-1&#34;&gt;solution 1&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;O(N)&lt;/li&gt;
&lt;li&gt;Test score  100% OJ test is O(N * log(N))&lt;/li&gt;
&lt;li&gt;考虑到有负数存在， 故乘积最大的三个数，会出现在两种情况：

&lt;ul&gt;
&lt;li&gt;三个数均是正数，且是三个最大的数&lt;/li&gt;
&lt;li&gt;两个负数和一个正数，最大正数和最小的两个负数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    ma1, ma2, ma3 = -1000, -1000, -1000
    mi1, mi2 = 1000, 1000
    for elem in A:
        if elem &amp;gt; ma1:
            ma1, ma2, ma3 = elem, ma1, ma2
        elif elem &amp;gt; ma2:
            ma2, ma3 = elem, ma2
        elif elem &amp;gt; ma3:
            ma3 = elem

        if elem &amp;lt; mi1:
            mi1,mi2 = elem, mi1
        elif elem &amp;lt; mi2:
            mi2 = elem
    a, b = ma1*ma2*ma3, ma1*mi1*mi2
    return a if a &amp;gt; b else b
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution-2&#34;&gt;solution 2&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;just need return the value of the max product,&lt;/li&gt;
&lt;li&gt;基于解法一，我们可以先排序，然后直接取，不需要每个比较，相对来说，时间成本稍大&lt;/li&gt;

&lt;li&gt;&lt;p&gt;so, we can just consider the first or last teiplet, after sort&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Detected time complexity: O(N * log(N))&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    A.sort()
    return max(A[0]*A[1]*A[-1], A[-1]*A[-2]*A[-3])

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.6.4&#34;&gt;
4. NumberOfDiscIntersections
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;We draw N discs on a plane. The discs are numbered from 0 to N − 1. A zero-indexed array A of N non-negative integers, specifying the radiuses of the discs, is given. The J-th disc is drawn with its center at (J, 0) and radius A[J].&lt;/p&gt;

&lt;p&gt;We say that the J-th disc and K-th disc intersect if J ≠ K and the J-th and K-th discs have at least one common point (assuming that the discs contain their borders).&lt;/p&gt;

&lt;p&gt;The figure below shows discs drawn for N = 6 and A as follows:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;      A[0] = 1
      A[1] = 5
      A[2] = 2
      A[3] = 1
      A[4] = 4
      A[5] = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://codility-frontend-prod.s3.amazonaws.com/media/task_img/number_of_disc_intersections/media/auto/mpaecfada7c1e52a7b01b04916c859b15d.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;There are eleven (unordered) pairs of discs that intersect, namely:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;discs 1 and 4 intersect, and both intersect with all the other discs;&lt;/li&gt;
&lt;li&gt;disc 2 also intersects with discs 0 and 3.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;problem:&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Compute the number of intersections in a sequence of discs.&lt;/p&gt;

&lt;p&gt;given an array A describing N discs as explained above, returns the number of (unordered) pairs of intersecting discs. The function should return −1 if the number of intersecting pairs exceeds 10,000,000.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Assume that:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;N is an integer within the range [0..100,000];&lt;/li&gt;
&lt;li&gt;each element of array A is an integer within the range [0..2,147,483,647].&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Complexity:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;expected worst-case time complexity is O(N*log(N));&lt;/li&gt;
&lt;li&gt;expected worst-case space complexity is O(N).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/dear0607/article/details/42671621&#34;&gt;参考csdn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/4801242/algorithm-to-calculate-number-of-intersecting-discs#&#34;&gt;stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;initially we calculate all start and end points of discs. After go by all line and check count of discs inside current point. If in current point started some discs and intersection count increased by: already active distsc multiplied by count of started in current point (result += t * dps[i]) and count of intersections of started(result += dps[i] * (dps[i] - 1) / 2) eg. if started 5 discs in one of point it will increased by(1+2+3+4+5 intersections, or 5*(5-1) / 2[sum formula]).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;构造成区间，[i-A[i],i+A[i]]

&lt;ul&gt;
&lt;li&gt;e.g. A ＝ ［1，5，2，1，4，0］&lt;/li&gt;
&lt;li&gt;=&amp;gt; [－1,1],[-4,6],[0,4],[2,4],[0,8],[5,5]&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;因为我们圆的中心位置在［0，len(A)],e.g. 在上例中 [0,5], 所以起点数组dps计算［0，i-A[i]］的范围，故有max(0,i-A[i])&lt;/li&gt;
&lt;li&gt;终点数组不要超过每个圆心的最大值，即小于len（A）－1， 故有min（length－1，i+A［i］）&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;sloution-100&#34;&gt;sloution:[100%]&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    result = 0
    length = len(A)
    dps = [0]*length
    dpe = [0]*length
    for i in xrange(length):
        dps[max(0, i-A[i])] += 1
        dpe[min(length-1, i+A[i])] += 1
    tmp = 0
    for i in xrange(length):
        if dps[i] &amp;gt; 0:
            result += tmp*dps[i]
            result += dps[i] * (dps[i] - 1)/2
            if result &amp;gt; 10000000:
                return -1
            tmp += dps[i]
        tmp -= dpe[i]
    return result
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>prefix sums--codility</title>
      <link>https://tmhm.github.io/2016/09/04/prefix-sums--codility/</link>
      <pubDate>Sun, 04 Sep 2016 09:08:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/09/04/prefix-sums--codility/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.5.1&#34;&gt;1. PassingCars&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.5.2&#34;&gt;2. CountDiv&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.5.3&#34;&gt;3. GenomicRangeQuery&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.5.4&#34;&gt;4. MinAvgTwoSlice&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id = &#34;1.5&#34;&gt;
lesson 5: &lt;i&gt;prefix sums&lt;/i&gt;
&lt;/h3&gt;

&lt;h4 id = &#34;1.5.1&#34;&gt;
1. &lt;i&gt; PassingCars&lt;/i&gt;
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Count the number of passing cars on the road.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A non-empty zero-indexed array A consisting of N integers is given. The consecutive elements of array A represent consecutive cars on a road.&lt;/p&gt;

&lt;p&gt;Array A contains only 0s and/or 1s:&lt;/p&gt;

&lt;p&gt;0 represents a car traveling east,
1 represents a car traveling west.
The goal is to count passing cars. We say that a pair of cars (P, Q), where 0 ≤ P &amp;lt; Q &amp;lt; N, is passing when P is traveling to the east and Q is traveling to the west.&lt;/p&gt;

&lt;p&gt;For example, consider array A such that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  A[0] = 0
  A[1] = 1
  A[2] = 0
  A[3] = 1
  A[4] = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have five pairs of passing cars: (0, 1), (0, 3), (0, 4), (2, 3), (2, 4).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Assume that:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;N is an integer within the range [1..100,000];&lt;/li&gt;
&lt;li&gt;each element of array A is an integer that can have one of the following values: 0, 1.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Complexity:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;expected worst-case time complexity is O(N);&lt;/li&gt;
&lt;li&gt;expected worst-case space complexity is O(1),&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以计算suffix sum的方式&lt;/li&gt;
&lt;li&gt;然后，从前面开始遍历list，遇到a ＝ 0，result即加上当前的suffix sum的值&lt;/li&gt;

&lt;li&gt;&lt;p&gt;此题元素是0，1，故可以不用保留每一步的计算，题目有要求限制O(1)的space， 也是给出提示，用一个变量retsum值来记录，每一步的prefix sum值，每移动一步，元素是1的话，将retsum 减1， 即是下一个prefix sum 值。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Detected time complexity: O(N)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[100%]&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    result = 0
    retsum = sum(A)
    for a in A:
        if a == 0:
            result += retsum
            if result &amp;gt; 1000000000:
                return -1
        else:
            retsum -= 1
    return result
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.5.2&#34;&gt;
2. &lt;i&gt; CountDiv &lt;/i&gt;
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Compute number of integers divisible by k in range [a..b].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;given three integers A, B and K, returns the number of integers within the range [A..B] that are divisible by K, i.e.:&lt;/p&gt;

&lt;p&gt;{ i : A ≤ i ≤ B, i mod K = 0 }&lt;/p&gt;

&lt;p&gt;For example, for A = 6, B = 11 and K = 2, your function should return 3, because there are three numbers divisible by 2 within the range [6..11], namely 6, 8 and 10.&lt;/p&gt;

&lt;p&gt;Assume that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A and B are integers within the range [0..2,000,000,000];&lt;/li&gt;
&lt;li&gt;K is an integer within the range [1..2,000,000,000];
A ≤ B.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Complexity:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;expected worst-case time complexity is O(1);&lt;/li&gt;
&lt;li&gt;expected worst-case space complexity is O(1).&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;countdiv-solution-1:7636a8ab415e12ff71d303247ac5f18e&#34;&gt;CountDiv solution 1&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A, B, K):
    # write your code in Python 2.7
    ra = -1 if A == 0 else (A - 1)/K
    rb = B/K

    return rb -ra

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution-2:7636a8ab415e12ff71d303247ac5f18e&#34;&gt;solution 2&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A, B, K):
    # write your code in Python 2.7
    c = 1 if A%K == 0 else 0
    return B/K -A/K + c

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;def solution(A, B, K):
    # write your code in Python 2.7
    return (B/K - A/K) if (A%K != 0 ) else (B/K - A/K + 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.5.3&#34;&gt;
3. GenomicRangeQuery
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Find the minimal nucleotide from a range of sequence DNA.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A DNA sequence can be represented as a string consisting of the letters A, C, G and T, which correspond to the types of successive nucleotides in the sequence. Each nucleotide has an impact factor, which is an integer. Nucleotides of types A, C, G and T have impact factors of 1, 2, 3 and 4, respectively. You are going to answer several queries of the form: What is the minimal impact factor of nucleotides contained in a particular part of the given DNA sequence?&lt;/p&gt;

&lt;p&gt;The DNA sequence is given as a non-empty string S = S[0]S[1]&amp;hellip;S[N-1] consisting of N characters. There are M queries, which are given in non-empty arrays P and Q, each consisting of M integers. The K-th query (0 ≤ K &amp;lt; M) requires you to find the minimal impact factor of nucleotides contained in the DNA sequence between positions P[K] and Q[K](inclusive).&lt;/p&gt;

&lt;p&gt;For example, consider string S = CAGCCTA and arrays P, Q such that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    P[0] = 2    Q[0] = 4
    P[1] = 5    Q[1] = 5
    P[2] = 0    Q[2] = 6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The answers to these M = 3 queries are as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The part of the DNA between positions 2 and 4 contains nucleotides G and C (twice), whose impact factors are 3 and 2 respectively, so the answer is 2.&lt;/li&gt;
&lt;li&gt;The part between positions 5 and 5 contains a single nucleotide T, whose impact factor is 4, so the answer is 4.&lt;/li&gt;
&lt;li&gt;The part between positions 0 and 6 (the whole string) contains all nucleotides, in particular nucleotide A whose impact factor is 1, so the answer is 1.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;the function should return the values [2, 4, 1], as explained above.&lt;/p&gt;

&lt;p&gt;Assume that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;N is an integer within the range [1..100,000];&lt;/li&gt;
&lt;li&gt;M is an integer within the range [1..50,000];&lt;/li&gt;
&lt;li&gt;each element of arrays P, Q is an integer within the range [0..N − 1];&lt;/li&gt;
&lt;li&gt;P[K] ≤ Q[K], where 0 ≤ K &amp;lt; M;&lt;/li&gt;
&lt;li&gt;string S consists only of upper-case English letters A, C, G, T.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Complexity:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;expected worst-case time complexity is O(N+M);&lt;/li&gt;
&lt;li&gt;expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;解法一:7636a8ab415e12ff71d303247ac5f18e&#34;&gt;解法一：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Test score  62%&lt;/li&gt;
&lt;li&gt;Detected time complexity:
O(N * M)&lt;/li&gt;
&lt;li&gt;最初的想法是：根据给出的范围，用set保存，看是否有各元素&lt;/li&gt;
&lt;li&gt;时间复杂度，明显达不到O(N+M)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def getMinFactor(S,l,i,j):
    if j == (l-1):
        tmp = set(S[i:])  #
    else:
        tmp = set(S[i:(j+1)])
    if &#39;A&#39; in tmp:
        return 1
    elif &#39;C&#39; in tmp:
        return 2
    elif &#39;G&#39; in tmp:
        return 3
    else:
        return 4

def solution(S, P, Q):
    # write your code in Python 2.7
    length = len(S)
    result = []
    for x,y in zip(P,Q):
        #print x,y
        result.append(getMinFactor(S,length,x,y))
    return result
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;解法二:7636a8ab415e12ff71d303247ac5f18e&#34;&gt;解法二：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;li&gt;used each list to save that states whether has element or not&lt;/li&gt;
&lt;li&gt;在用prefix sum 做差的方式，依次检查是否存在A,C,G,T字符&lt;/li&gt;
&lt;li&gt;注意数值关系&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def calcPrefixSum(S):
    l = len(S)+1
    pa,pc,pg = [0]*l,[0]*l,[0]*l
    for idx,elem in enumerate(S):
        a,c,g = 0,0,0
        if elem == &#39;A&#39;:
            a = 1
        elif elem == &#39;C&#39;:
            c = 1
        elif elem == &#39;G&#39;:
            g = 1
        pa[idx+1] = pa[idx] + a
        pc[idx+1] = pc[idx] + c
        pg[idx+1] = pg[idx] + g
    return pa,pc,pg

def solution(S, P, Q):
    # write your code in Python 2.7
    pA,pC,pG = calcPrefixSum(S)
    result = []
    for i,j in zip(P,Q):
        if pA[j+1] - pA[i] &amp;gt; 0:
            ret = 1
        elif pC[j+1] - pC[i] &amp;gt; 0:
            ret = 2
        elif pG[j+1] - pG[i] &amp;gt; 0:
            ret = 3
        else:
            ret = 4
        result.append(ret)
    return result

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;根据prefix sum list:
pA = [0, 0, 1, 1, 1, 1, 1, 2]
pC = [0, 1, 1, 1, 2, 3, 3, 3]
pG = [0, 0, 0, 1, 1, 1, 1, 1]

故，是下标［j＋1］－［i］
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.5.4&#34;&gt;
4. MinAvgTwoSlice
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Find the minimal average of any slice containing at least two elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A non-empty zero-indexed array A consisting of N integers is given. A pair of integers (P, Q), such that 0 ≤ P &amp;lt; Q &amp;lt; N, is called a slice of array A (notice that the slice contains at least two elements). The average of a slice (P, Q) is the sum of A[P] + A[P + 1] + &amp;hellip; + A[Q] divided by the length of the slice. To be precise, the average equals (A[P] + A[P + 1] + &amp;hellip; + A[Q]) / (Q − P + 1).&lt;/p&gt;

&lt;p&gt;For example, array A such that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    A[0] = 4
    A[1] = 2
    A[2] = 2
    A[3] = 5
    A[4] = 1
    A[5] = 5
    A[6] = 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;contains the following example slices:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;slice (1, 2), whose average is (2 + 2) / 2 = 2;&lt;/li&gt;
&lt;li&gt;slice (3, 4), whose average is (5 + 1) / 2 = 3;&lt;/li&gt;
&lt;li&gt;slice (1, 4), whose average is (2 + 2 + 5 + 1) / 4 = 2.5.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The goal is to find the starting position of a slice whose average is minimal.&lt;/p&gt;

&lt;p&gt;Complexity:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;expected worst-case time complexity is O(N);&lt;/li&gt;
&lt;li&gt;expected worst-case space complexity is O(N),&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;sloution:7636a8ab415e12ff71d303247ac5f18e&#34;&gt;sloution&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt; transfer to 2/3 ,
- 只要查看相邻两个和三个的数的平均值即可
- &lt;a href=&#34;https://github.com/daotranminh/playground/blob/master/src/codibility/MinAvgTwoSlice/proof.pdf&#34;&gt;proof&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    length = len(A)
    minStartPos = 0
    minSum = (A[0] + A[1])/2.0

    for i in xrange(length - 2):
        tmp = (A[i] + A[i+1])/2.0
        if tmp &amp;lt; minSum:
            minSum = tmp
            minStartPos = i
        tmp = (tmp*2 + A[i+2])/3.0
        if tmp &amp;lt; minSum:
            minSum = tmp
            minStartPos = i
    if (A[-1] + A[-2])/2.0 &amp;lt; minSum:
        minStartPos = length - 2

    return minStartPos
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>counting elements--codility</title>
      <link>https://tmhm.github.io/2016/09/01/counting-elements--codility/</link>
      <pubDate>Thu, 01 Sep 2016 15:46:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/09/01/counting-elements--codility/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.4.1&#34;&gt;1. FrogRiverOne&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.4.2&#34;&gt;2. PermCheck&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.4.3&#34;&gt;3. MissingInteger&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.4.4&#34;&gt;4. MaxCounters&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id = &#34;1.4&#34;&gt;
lesson 4: &lt;i&gt;counting elements&lt;/i&gt;
&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;exercise&lt;/li&gt;
&lt;li&gt;Problem: You are given an integer m (1 &amp;lt;= m &amp;lt;= 1,000,000) and two non-empty, zero-indexed arrays A and B of n integers, a0,a1,&amp;hellip;,an−1 and b0,b1,&amp;hellip;,bn−1 respectively (0 &amp;lt;= ai,bi &amp;lt;= m).&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;For every element of array B, we assume that we will swap it with some element from array A. The difference d tells us the value from array A that we are interested in swapping, because only one value will cause the two totals to be equal. The occurrence of this value can be found in constant time from the array used for counting.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;假设A中ai和B中的bj交换可以满足要求，则有：A＋bj－ai ＝＝ B＋ai－bj&lt;/li&gt;
&lt;li&gt;假设 d ＝ bj － ai， 则有 A ＋ d ＝ B － d&lt;/li&gt;
&lt;li&gt;故有A－B ＝ 2d， 因此，两个数组的差必须是2的整数倍，即偶数，否则不存在交换可以满足题意的元素&lt;/li&gt;
&lt;li&gt;然后由d ＝ bj － ai，得到在A中存在元素ai ＝ bj － d。我们可以对每一个B中的元素bj，查找A中是否有bj－d 即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def counting(A, m):
        n = len(A)
        count=[0]*(m+1)
        for k in xrange(n):
                count[A[k]] += 1
        return count


## from collections import Counter
def fast_solution(A, B, m):
        n = len(A)
        sum_a = sum(A)
        sum_b = sum(B)
        d = sum_b - sum_a
        if d%2==1:
                return False
        d//=2
        count = counting(A, m)
        for i in xrange(n):
                if 0 &amp;lt;= B[i] - d &amp;lt;= m and count[B[i] - d] &amp;gt; 0:
                        return True
        return False

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;根本目的是找到A中存在元素ai ＝ bj － d， 前面的Bj －d 范围在 ［0，m］只是限定count的范围，防止越界！&lt;/p&gt;

&lt;p&gt;若使用collections 的Counter 函数计数，则可以直接查看是否存在bj－d这个元素即可，即count[bj-d] &amp;gt; 0要求。&lt;/p&gt;

&lt;p&gt;我们也可以直接用for everyone B element， 判断if （bj － d） in A 也可以,但是这样的复杂度又变高了， 变成O(N^2)了。因为，每次查找（bj － d） 是否in A 的时候就要N次遍历查找。
&lt;strong&gt;因此，还是用计数的方式好，首先统计A中的元素，以后只要O(1)的时间查找是否存在我们需要的ai。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以有如下解答：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;so,we can do it as follows:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from collections import Counter
def fast_solution(A, B, m):
        n = len(A)
        sum_a = sum(A)
        sum_b = sum(B)
        d = sum_b - sum_a
        if d%2==1:
                return False
        d//=2
        count = Counter(A, m)
        for i in xrange(n):
                if count[B[i] - d] &amp;gt; 0:
                        return True
        return False

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.4.1&#34;&gt;
1. FrogRiverOne----[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Find the earliest time when a frog can jump to the other side of a river.&lt;/p&gt;

&lt;p&gt;The goal is to find the earliest time when the frog can jump to the other side of the river. The frog can cross only when leaves appear at every position across the river from 1 to X (that is, we want to find the earliest moment when all the positions from 1 to X are covered by leaves). You may assume that the speed of the current in the river is negligibly small, i.e. the leaves do not change their positions once they fall in the river.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;each element of array A is an integer within the range [1..X].&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;鉴于元素的范围，所以，可以用list保存出现过的元素，比较list的长度跟X的关系，就可以得到第一次出现X的位置&lt;/li&gt;
&lt;li&gt;这里需要考虑的一个问题是，是第一次访问过所有的元素种类，停留的位置不要求必须是X元素；另一种情况是，不仅仅要求访问过所有的元素种类，还要最后停留在X元素上，再算达到要求。&lt;strong&gt;本题解法是第一种情况。&lt;/strong&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若是第二种情况的话，只需要在set的长度等于X后，多加一次判断，找到接下来第一次出现X的位置即好。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;鉴于O(N) -time  O(X)-space ,每次在保存过的元素中查找费时间，可以直接用set保存，因为set加入新元素的时候，重复元素不会再次加入，这里应该看看&lt;a href=&#34;http://svn.python.org/view/python/trunk/Objects/setobject.c?view=markup&#34;&gt;python源码set&lt;/a&gt;怎么加入的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(X, A):
    # write your code in Python 2.7
    visited = set()
    for idx,elem in enumerate(A):
        visited.add(elem)
        if len(visited) == X:
            return idx
    return -1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.4.2&#34;&gt;
2. PermCheck----[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Check whether array A is a permutation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;思路一：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用最大值是否等于set的长度来测试.
仔细看好题意， 比如是要求从1 开始的list ，
就不需要记最小的值，求长度了，只要记下最大值。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    #A.sort() # Nlog(N)
    if len(A) == 1:
        return 1 if (A[0] == 1) else 0

    sigle = set()
    #maxelem, minelem = A[0], A[0]   #needless minelem,owing to from 1 !!
    maxelem = A[0]
    for elem in A:
        if elem not in sigle:
            sigle.add(elem)
            if elem &amp;gt; maxelem:
                maxelem = elem
        else:
            #print &amp;quot;test&amp;quot;
            return 0
    #print sigle
    return 1 if (len(sigle) == maxelem) else 0

    #return 1 if (A[-1]-A[0]+1) == len(A) else 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;思路二：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果元素的取值是在N个范围内，即数组有N个元素，每个元素范围是[1,N] ,则我们可以用求sum的方式来做 ［score ：100%］&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    set_a = set(A)

    length = len(set_a)
    total = length*(length+1)//2
    tmp = sum(A)
    return 1 if total == tmp else 0

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.4.3&#34;&gt;
3. MissingInteger----[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Find the minimal positive integer not occurring in a given sequence.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;O(N) time &amp;amp; space complexity,if sort, will exceed.&lt;/li&gt;
&lt;li&gt;考虑到不能排序，从解空间出发考虑。返回解一定会在1~len(所给数组)+1的区间。用map记录这些数据是否都在，不在的话，找最小的空缺，都在的时候就是map/list最后一个数加1.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    length = len(A)
    tmp = [True]*(length + 1)
    #print tmp
    for elem in A:
        if 0 &amp;lt; elem &amp;lt; length+1:
            tmp[elem-1] = False
    for idx,elem in enumerate(tmp):
        if elem == True:
            return idx+1
    return length +1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    length = len(A)+1
    tmp = [True]*length
    for a in A:
        if 0 &amp;lt; a &amp;lt; length:
            tmp[a-1] = a
    for idx, a in enumerate(tmp):
        if a is True:
            return idx+1
    #return length

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;将tmp数组增大一位，就不需要最后考虑全部是有序的，再return length ＋ 1了&lt;/em&gt;&lt;/p&gt;

&lt;h3 id = &#34;1.4.4&#34;&gt;
4. MaxCounters
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Calculate the values of counters after applying all alternating operations:increase counter by 1; set value of all counters to current maximum.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;You are given N counters, initially set to 0, and you have two possible operations on them:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;increase(X) − counter X is increased by 1,&lt;/li&gt;
&lt;li&gt;max counter − all counters are set to the maximum value of any counter.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A non-empty zero-indexed array A of M integers is given. This array represents consecutive operations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;if A[K] = X, such that 1 ≤ X ≤ N, then operation K is increase(X),&lt;/li&gt;
&lt;li&gt;if A[K] = N + 1 then operation K is max counter.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example, given integer N = 5 and array A such that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A[0] = 3
A[1] = 4
A[2] = 4
A[3] = 6
A[4] = 1
A[5] = 4
A[6] = 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the values of the counters after each consecutive operation will be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(0, 0, 1, 0, 0)
(0, 0, 1, 1, 0)
(0, 0, 1, 2, 0)
(2, 2, 2, 2, 2)
(3, 2, 2, 2, 2)
(3, 2, 2, 3, 2)
(3, 2, 2, 4, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The goal is to calculate the value of every counter after all operations.&lt;/p&gt;

&lt;h5 id=&#34;解法一&#34;&gt;解法一：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Detected time complexity: O(N*M)&lt;/li&gt;
&lt;li&gt;Test score 66%&lt;/li&gt;
&lt;li&gt;Correctness 100%      Performance     60%&lt;/li&gt;
&lt;li&gt;计算正确，但是时间复杂度不满足要求。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(N, A):
    # write your code in Python 2.7
    ret = [0]*N
    #print ret

    for elem in A:
        if elem &amp;lt; (N + 1):
            #print elem
            #print ret
            ret[int(elem -1)] += 1
        else:
            #tmp = max(ret)
            #print &amp;quot;tmp&amp;quot;,tmp
            #ret = [tmp]*N
            ret = [max(ret)]*N
            #print &amp;quot;ret&amp;quot;,ret
    return ret
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;解法二&#34;&gt;解法二&lt;/h5&gt;

&lt;p&gt;[100%] MaxCounters
&amp;gt;
Calculate the values of counters after applying all alternating operations: increase counter by 1; set value of all counters to current maximum.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;分别记录上次update的值，在update的基础上，再记录当前最大值。&lt;/li&gt;
&lt;li&gt;有点类似操作系统的内存管理，按需分配的味道， 当出现缺页中断的时候再去分配内存。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这里是当出现N+1的时候，再去update 上次没有update的元素，并且在最后一次需要再检查一次update&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Detected time complexity:
O(N + M)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(N, A):
    # write your code in Python 2.7
    ret = [0]*N

    maxOfArray = 0
    last_update = 0
    tn = N + 1
    for elem in A:
        if elem &amp;lt; tn:
            if ret[elem -1] &amp;lt; last_update:
                ret[elem -1] = last_update

            ret[elem -1] += 1
            if ret[elem -1] &amp;gt; maxOfArray:
                maxOfArray = ret[elem -1]
        else:
            last_update = maxOfArray
            #print &amp;quot;last_update&amp;quot;,last_update
            #ret = [maxOfArray]*N

            #print &amp;quot;ret&amp;quot;,ret
    for elem in xrange(N):
        if ret[elem] &amp;lt; last_update:
            ret[elem] = last_update
    return ret
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;def solution(N, A):
    # write your code in Python 2.7
    tn = N + 1
    maxOfCounter = 0
    lastUpdate = 0
    ret = [0]*N
    for a in A:
        if a &amp;lt; tn:
            if ret[a-1] &amp;lt; lastUpdate :
                ret[a-1] = lastUpdate
            ret[a-1] += 1
            if ret[a-1] &amp;gt; maxOfCounter:
                # update max counter
                maxOfCounter = ret[a-1]
        else:
            lastUpdate = maxOfCounter
    for elem in xrange(N):
        if ret[elem-1] &amp;lt; lastUpdate:
            ret[elem-1] = lastUpdate
    return ret
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Time complexity--codility</title>
      <link>https://tmhm.github.io/2016/09/01/time-complexity--codility/</link>
      <pubDate>Thu, 01 Sep 2016 15:44:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/09/01/time-complexity--codility/</guid>
      <description>&lt;h3 id = &#34;1.3&#34;&gt;
lesson 3: &lt;i&gt;Time complexity&lt;/i&gt;
&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;exercise:&lt;/li&gt;
&lt;li&gt;Problem: You are given an integer n. Count the total of 1+2+&amp;hellip;+n.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def sumN(N):
    return N*(N+1)//2

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.3.1&#34;&gt;
1. TapeEquilibrium -----[100%]
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Minimize the value
|(A[0] + &amp;hellip; + A[P-1]) - (A[P] + &amp;hellip; + A[N-1])|.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A non-empty zero-indexed array A consisting of N integers is given. Array A represents numbers on a tape.&lt;/p&gt;

&lt;p&gt;Any integer P, such that 0 &amp;lt; P &amp;lt; N, splits this tape into two non-empty parts: A[0], A[1], &amp;hellip;, A[P − 1] and A[P], A[P + 1], &amp;hellip;, A[N − 1].&lt;/p&gt;

&lt;p&gt;The difference between the two parts is the value of: |(A[0] + A[1] + &amp;hellip; + A[P − 1]) − (A[P] + A[P + 1] + &amp;hellip; + A[N − 1])|&lt;/p&gt;

&lt;p&gt;In other words, it is the absolute difference between the sum of the first part and the sum of the second part.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt; 依次求sum&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):

    #left,right =A[0], sum(A)-A[0]
    left,right =A[0], sum(A[1:])
    result = abs(right - left)

    for elem in A[1:-1]:
        left,right = left + elem, right - elem
        retmp = abs(right - left)
        if retmp &amp;lt; result:
            result = retmp
    return result
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.3.2&#34;&gt;
2. FrogJmp -----[100%]
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Count minimal number of jumps from position X to Y.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A small frog wants to get to the other side of the road. The frog is currently located at position X and wants to get to a position greater than or equal to Y. The small frog always jumps a fixed distance, D.&lt;/p&gt;

&lt;p&gt;Count the minimal number of jumps that the small frog must perform to reach its target.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt; O(1) time complexity, 注意是否在边界上，否则加1即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def solution(X, Y, D):
    # write your code in Python 2.7
    if X == Y:
        return 0
    else:
        flag = (Y - X)%D
        ret = (Y - X)/D
        return ret if flag == 0 else ret + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id = &#34;1.3.3&#34;&gt;
3. PermMissingElem -----[100%]
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Find the missing element in a given permutation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A zero-indexed array A consisting of N different integers is given. The array contains integers in the range [1..(N + 1)], which means that exactly one element is missing.&lt;/p&gt;

&lt;p&gt;Your goal is to find that missing element.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;简单思路是排序，然后依此比较是否是增1关系，也可以用求sum的方式&lt;/li&gt;
&lt;li&gt;注意边界条件，N取值［0，100，000］， 元素取值［1，N+1］，&lt;/li&gt;
&lt;li&gt;故当没有元素的时候，返回1；当只有一个元素的时候，需要考虑元素是否是1&lt;/li&gt;
&lt;li&gt;当全部有序的时候，考虑最后元素＋1返回。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    if len(A) == 0:
        return 1
    elif len(A) == 1:
        return A[0]+1 if A[0] == 1 else A[0] -1
    A.sort()
    left = A[0]
    for elem in A[1:]:
        if elem == left + 1:
            left = elem
            continue
        else:
            return left + 1

    return A[-1]+1 if A[0] == 1 else A[0]-1
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    length = len(A)
    if length &amp;lt; 1:
        return 1
    #elif length &amp;lt; 2:  # can belong to the next tatal_sum
    #    return 1 if A[0]==2 else 2

    tatal = sum([i for i in xrange(1,length+2,1) ])
    tmp = sum(A)
    return tatal - tmp

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Arrays--codility</title>
      <link>https://tmhm.github.io/2016/09/01/arrays--codility/</link>
      <pubDate>Thu, 01 Sep 2016 15:40:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/09/01/arrays--codility/</guid>
      <description>&lt;h2 id = &#34;1.2&#34;&gt;
lesson 2: &lt;i&gt;Arrays&lt;/i&gt;
&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;exercise:&lt;/li&gt;
&lt;li&gt;Problem: Given array A consisting of N integers, return the reversed array.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def myreverse(A):
    length = len(A)
    for i in xrange(length//2):
        A[i], A[length -i-1] = A[length - i-1], A[i]
    return A

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.2.1&#34;&gt;
1. CyclicRotation------[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Rotate an array to the right by a given number of steps.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A zero-indexed array A consisting of N integers is given. Rotation of the array means that each element is shifted right by one index, and the last element of the array is also moved to the first place.&lt;/p&gt;

&lt;p&gt;For example, the rotation of array A = [3, 8, 9, 7, 6] is [6, 3, 8, 9, 7]. The goal is to rotate array A K times; that is, each element of A will be shifted to the right by K indexes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def re_enumerate(seq):
    n = -1
    length = len(seq)
    for elem in reversed(seq):
        yield length + n, elem
        n = n - 1

def solution(A, K):
    length = len(A)
    if length &amp;lt; 2:
        return A
    shift_times = K%length
    #print shift_times
    tmp= A[-shift_times:]
    #print tmp
    tmp.extend(A[:- shift_times])
    return tmp
    #for idx, ai in re_enumerate(A):
    #    if idx &amp;gt;= shift_times:
    #        A[idx] = A[idx-shift_times]
    #
    #    else:
    #        A[idx] = tmp[idx]
    #return A

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;要注意边界条件，考虑数组的长度少于旋转的次数，以及只有一个元素和数组为空&lt;/li&gt;
&lt;li&gt;当有除法的时候，注意是否除以零&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A, K):
    # write your code in Python 2.7
    length = len(A)
    #print length
    #print K
    if K == 0 or length == 0 or length == 1:
        return A
    if K &amp;gt; length:
        K %= length

    #print K
    tmp = [0]*K
    #print tmp
    for i in xrange(K):
        tmp[i] = A[length - K + i]
    tmp.extend(A[:-K])
    return tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.2.2&#34;&gt;
2. OddOccurrencesInArray ---[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Find value that occurs in odd number of elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A non-empty zero-indexed array A consisting of N integers is given. The array contains an odd number of elements, and each element of the array can be paired with another element that has the same value, except for one element that is left unpaired.&lt;/p&gt;

&lt;p&gt;For example, in array A such that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      A[0] = 9  A[1] = 3  A[2] = 9
      A[3] = 3  A[4] = 9  A[5] = 7
      A[6] = 9
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;the elements at indexes 0 and 2 have value 9,&lt;/li&gt;
&lt;li&gt;the elements at indexes 1 and 3 have value 3,&lt;/li&gt;
&lt;li&gt;the elements at indexes 4 and 6 have value 9,&lt;/li&gt;
&lt;li&gt;the element at index 5 has value 7 and is unpaired.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解题思路：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将数组排序，相同的数会在一起，比较前后两个数是否相同&lt;/li&gt;
&lt;li&gt;偶数个数的，继续测试下一个数，找到单独的一个数，返回&lt;/li&gt;
&lt;li&gt;当直到数组最后，还有没有找到单独的一个元素，我们得返回最后一个元素，因为我们统计的一直的是last 元素&lt;/li&gt;
&lt;li&gt;注意临界条件，只有一个元素&lt;/li&gt;
&lt;li&gt;O(N)时间复杂度&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    if len(A) == 1:
        return A[0]
    A.sort()
    #print A
    last_a,cnt = A[0],1
    #print last_a
    for ai in A[1:]:
        if ai == last_a:
            cnt += 1
        else:
            if cnt%2 != 0:
                return last_a
            last_a,cnt = ai,1

    return A[-1]

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    if len(A) &amp;lt; 2:
        return A[0]
    A.sort()
    last_a, cnt = A[0], 1
    for a in A[1:]:
        if last_a == a:
            cnt += 1
        else:
            if cnt%2 == 0 :
                last_a, cnt = a, 1
            else:
                return last_a
    return A[-1]

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Iterations --codility</title>
      <link>https://tmhm.github.io/2016/09/01/iterations---codility/</link>
      <pubDate>Thu, 01 Sep 2016 15:35:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/09/01/iterations---codility/</guid>
      <description>&lt;h3 id = &#34;1.1&#34;&gt;
lesson 1：&lt;i&gt;Iterations&lt;/i&gt;
&lt;/h3&gt;

&lt;h4 id = &#34;1.1.1&#34;&gt;
1. BinaryGap-----[100%]
&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Find longest sequence of zeros in binary representation of an integer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A binary gap within a positive integer N is any maximal sequence of consecutive zeros that is surrounded by ones at both ends in the binary representation of N.&lt;/p&gt;

&lt;p&gt;For example, number 9 has binary representation 1001 and contains a binary gap of length 2. The number 529 has binary representation 1000010001 and contains two binary gaps: one of length 4 and one of length 3. The number 20 has binary representation 10100 and contains one binary gap of length 1. The number 15 has binary representation 1111 and has no binary gaps.&lt;/p&gt;

&lt;p&gt;解题思路：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将整型数据转为二进制，然后利用python的split函数按‘1’分割，再用max函数找到最大的切片即可&lt;/li&gt;
&lt;li&gt;注意二进制为全1，或者第一位为1，后面全为0的数，e.g. 1, 100, 11111, 用log次的循环判定下即可&lt;/li&gt;
&lt;li&gt;满足于O(log(N))的时间复杂度&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;from math import log
def solution(N):

    #if N == 1:   #can belong to the next for i = 0
    #    return 0
    for i in xrange(int(log(N,2))+1):

        tmp = 2**i
        #print tmp
        if tmp == N+1 or tmp == N:
            return 0

    strb = bin(N).split(&amp;quot;1&amp;quot;)
    #print strb[1:-1]
        #last one can&#39;t included. e.g.1001000-&amp;gt;2, so [1:-1]
    if strb[1:-1] is None:
        #print &amp;quot;test&amp;quot;
        return 0
    return max([len(l) for l in strb[1:-1]])
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>codility lessons</title>
      <link>https://tmhm.github.io/2016/08/30/codility-lessons/</link>
      <pubDate>Tue, 30 Aug 2016 14:19:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/08/30/codility-lessons/</guid>
      <description>

&lt;pre&gt;&lt;code&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;http://yandex.st/highlightjs/6.2/styles/googlecode.min.css&amp;quot;&amp;gt;

&amp;lt;script src=&amp;quot;http://code.jquery.com/jquery-1.7.2.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;http://yandex.st/highlightjs/6.2/highlight.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;script&amp;gt;hljs.initHighlightingOnLoad();&amp;lt;/script&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
 $(document).ready(function() {
        $(&amp;quot;h2,h3,h4,h5,h6&amp;quot;).each(function(i,item){
        var tag = $(item).get(0).localName;
        $(item).attr(&amp;quot;id&amp;quot;,&amp;quot;wow&amp;quot;+i);
        $(&amp;quot;.newh2&amp;quot;).css(&amp;quot;margin-left&amp;quot;,0);
        $(&amp;quot;.newh3&amp;quot;).css(&amp;quot;margin-left&amp;quot;,20);
        $(&amp;quot;.newh4&amp;quot;).css(&amp;quot;margin-left&amp;quot;,40);
        $(&amp;quot;.newh5&amp;quot;).css(&amp;quot;margin-left&amp;quot;,60);
        $(&amp;quot;.newh6&amp;quot;).css(&amp;quot;margin-left&amp;quot;,80);
});
 });
&amp;lt;/script&amp;gt;
&amp;lt;div id=&amp;quot;category&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;hr /&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;#1&#34;&gt;codility lessons&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.1&#34;&gt;lesson 1: &lt;em&gt;Iterations&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1.1.1&#34;&gt;1. BinaryGap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.2&#34;&gt;lesson 2: &lt;em&gt;Arrays&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1.2.1&#34;&gt;1. CyclicRotation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.2.2&#34;&gt;2. OddOccurrencesInArray&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.3&#34;&gt;lesson 3: &lt;em&gt;Time complexity&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1.3.1&#34;&gt;1. TapeEquilibrium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.3.2&#34;&gt;2. FrogJmp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.3.3&#34;&gt;3. PermMissingElem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.4&#34;&gt;lesson 4: &lt;em&gt;counting elements&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1.4.1&#34;&gt;1. FrogRiverOne&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.4.2&#34;&gt;2. PermCheck&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.4.3&#34;&gt;3. MissingInteger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.4.4&#34;&gt;4. MaxCounters&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.5&#34;&gt;lesson 5: &lt;em&gt;prefix sums&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1.5.1&#34;&gt;1. PassingCars&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.5.2&#34;&gt;2. CountDiv&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.5.3&#34;&gt;3. GenomicRangeQuery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.5.4&#34;&gt;4. MinAvgTwoSlice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.6&#34;&gt;lesson 6: &lt;em&gt;sorting&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1.6.1&#34;&gt;1. Distinct&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.6.2&#34;&gt;2. MaxProductOfThree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.6.3&#34;&gt;3. Triangle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.6.4&#34;&gt;4. none&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#1.7&#34;&gt;lesson 7: &lt;em&gt;stacks and queues&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1.7.1&#34;&gt;1. none&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.7.2&#34;&gt;2. Nesting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.7.3&#34;&gt;3. none&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.4.4&#34;&gt;4. MaxCounters&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id = &#34;1&#34;&gt;
codility lessons
&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;切记临界点， 比如一个最小，最大的值， len(0), max() 无数据等&lt;/li&gt;
&lt;li&gt;仔细看好题意， 比如是要求从1 开始的list ，就不需要记最好的值，求长度了，只要记下最大值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id = &#34;1.1&#34;&gt;
lesson 1：&lt;i&gt;Iterations&lt;/i&gt;
&lt;/h2&gt;

&lt;h3 id = &#34;1.1.1&#34;&gt;
1. BinaryGap-----[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Find longest sequence of zeros in binary representation of an integer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;from math import log
def solution(N):
    # write your code in Python 2.7

    if N == 1:
        return 0
    for i in xrange(int(log(N,2))+1):

        tmp = 2**i
        #print tmp
        if tmp == N+1 or tmp == N:
            return 0

    strb = bin(N).split(&amp;quot;1&amp;quot;)
    #print strb[1:-1]
    if strb[1:-1] is None:
        #print &amp;quot;test&amp;quot;
        return 0
    return max([len(l) for l in strb[1:-1]])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id = &#34;1.2&#34;&gt;
lesson 2: &lt;i&gt;Arrays&lt;/i&gt;
&lt;/h2&gt;

&lt;h3 id = &#34;1.2.1&#34;&gt;
1. CyclicRotation------[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Rotate an array to the right by a given number of steps.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;
def re_enumerate(seq):
    n = -1
    length = len(seq)
    for elem in reversed(seq):
        yield length + n, elem
        n = n - 1

def solution(A, K):
    # write your code in Python 2.7
    length = len(A)
    if length &amp;lt; 2:
        return A
    shift_times = K%length
    #print shift_times
    tmp= A[-shift_times:]
    #print tmp
    tmp.extend(A[:- shift_times])
    return tmp
    #for idx, ai in re_enumerate(A):
    #    if idx &amp;gt;= shift_times:
    #        A[idx] = A[idx-shift_times]
    #
    #    else:
    #        A[idx] = tmp[idx]
    #return A
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.2.2&#34;&gt;
2. OddOccurrencesInArray ---[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Find value that occurs in odd number of elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    if len(A) == 1:
        return A[0]
    A.sort()
    #print A
    last_a,cnt = A[0],1
    #print last_a
    for ai in A[1:]:
        if ai == last_a:
            cnt += 1
        else:
            if cnt%2 != 0:
                return last_a
            last_a,cnt = ai,1

    return A[-1]

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id = &#34;1.3&#34;&gt;
lesson 3: &lt;i&gt;Time complexity&lt;/i&gt;
&lt;/h2&gt;

&lt;h3 id = &#34;1.3.1&#34;&gt;
1. TapeEquilibrium -----[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Minimize the value
|(A[0] + &amp;hellip; + A[P-1]) - (A[P] + &amp;hellip; + A[N-1])|.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7

    left,right =A[0], sum(A)-A[0]
    result = abs(right - left)

    for elem in A[1:-1]:
        left,right = left + elem, right - elem
        retmp = abs(right - left)
        if retmp &amp;lt; result:
            result = retmp
    return result
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.3.2&#34;&gt;
2. FrogJmp -----[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Count minimal number of jumps from position X to Y.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;def solution(X, Y, D):
    # write your code in Python 2.7
    if X == Y:
        return 0
    else:
        flag = (Y - X)%D
        ret = (Y - X)/D
        return ret if flag == 0 else ret + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.3.3&#34;&gt;
3. PermMissingElem -----[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Find the missing element in a given permutation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    if len(A) == 0:
        return 1
    elif len(A) == 1:
        return A[0]+1 if A[0] == 1 else A[0] -1
    A.sort()
    left = A[0]
    for elem in A[1:]:
        if elem == left + 1:
            left = elem
            continue
        else:
            return left + 1

    return A[-1]+1 if A[0] == 1 else A[0]-1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id = &#34;1.4&#34;&gt;
lesson 4: &lt;i&gt;counting elements&lt;/i&gt;
&lt;/h2&gt;

&lt;h3 id = &#34;1.4.1&#34;&gt;
1. FrogRiverOne----[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Find the earliest time when a frog can jump to the other side of a river.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;def solution(X, A):
    # write your code in Python 2.7
    ret = -1
    visited = set()
    for idx,elem in enumerate(A):
        visited.add(elem)
        if len(visited) == X:
            return idx
    return -1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.4.2&#34;&gt;
2. PermCheck----[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Check whether array A is a permutation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt;
仔细看好题意， 比如是要求从1 开始的list ，
就不需要记最好的值，求长度了，只要记下最大值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    #A.sort() # Nlog(N)
    if len(A) == 1:
        return 1 if (A[0] == 1) else 0

    sigle = set()
    #maxelem, minelem = A[0], A[0]   #needless minelem,owing to from 1 !!
    maxelem = A[0]
    for elem in A:
        if elem not in sigle:
            sigle.add(elem)
            if elem &amp;gt; maxelem:
                maxelem = elem
        else:
            #print &amp;quot;test&amp;quot;
            return 0
    #print sigle
    return 1 if (len(sigle) == maxelem) else 0

    #return 1 if (A[-1]-A[0]+1) == len(A) else 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.4.3&#34;&gt;
3. MissingInteger----[100%]
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Find the minimal positive integer not occurring in a given sequence.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt;
考虑到不能排序， 返回解一定会在1~len(所给数组)+1的区间。用map记录这些数据是否都在，不在的话，找最小的空缺，都在的时候就是map/list最后一个数加1.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    length = len(A)
    tmp = [True]*(length + 1)
    #print tmp
    for elem in A:
        if 0 &amp;lt; elem &amp;lt; length+1:
            tmp[elem-1] = False
    for idx,elem in enumerate(tmp):
        if elem == True:
            return idx+1
    return length +1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.4.4&#34;&gt;
4. MaxCounters
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Calculate the values of counters after applying all alternating operations:
increase counter by 1; set value of all counters to current maximum.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;解法一&#34;&gt;解法一：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Detected time complexity: O(N*M)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(N, A):
    # write your code in Python 2.7
    ret = [0]*N
    #print ret

    for elem in A:
        if elem &amp;lt; (N + 1):
            #print elem
            #print ret
            ret[int(elem -1)] += 1
        else:
            #tmp = max(ret)
            #print &amp;quot;tmp&amp;quot;,tmp
            #ret = [tmp]*N
            ret = [max(ret)]*N
            #print &amp;quot;ret&amp;quot;,ret
    return ret
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;解法二&#34;&gt;解法二&lt;/h5&gt;

&lt;p&gt;[100%] MaxCounters
&amp;gt;
Calculate the values of counters after applying all alternating operations: increase counter by 1; set value of all counters to current maximum.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt;
分别记录上次update的值，在update的基础上，再记录当前最大值。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Detected time complexity:
O(N + M)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(N, A):
    # write your code in Python 2.7
    ret = [0]*N

    maxOfArray = 0
    last_update = 0
    tn = N + 1
    for elem in A:

        if elem &amp;lt; tn:
            if ret[elem -1] &amp;lt; last_update:
                ret[elem -1] = last_update

            ret[elem -1] += 1
            if ret[elem -1] &amp;gt; maxOfArray:
                maxOfArray = ret[elem -1]
        else:
            last_update = maxOfArray
            #print &amp;quot;last_update&amp;quot;,last_update
            #ret = [maxOfArray]*N

            #print &amp;quot;ret&amp;quot;,ret
    for elem in xrange(N):
        if ret[elem] &amp;lt; last_update:
            ret[elem] = last_update
    return ret
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id = &#34;1.5&#34;&gt;
lesson 5: &lt;i&gt;prefix sums&lt;/i&gt;
&lt;/h2&gt;

&lt;h3 id = &#34;1.5.1&#34;&gt;
1. &lt;i&gt; PassingCars&lt;/i&gt;
&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;[100%]
&amp;gt;
Count the number of passing cars on the road.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Detected time complexity:
O(N)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    total = sum(A)
    ret = 0
    for elem in A:
        if elem == 0:
            ret += total
            if ret &amp;gt; 1000000000:
                return -1
        else:
            total -= elem
    return ret
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.5.2&#34;&gt;
2. &lt;i&gt; CountDiv &lt;/i&gt;
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Compute number of integers divisible by k in range [a..b].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;countdiv-solution-1&#34;&gt;CountDiv solution 1&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;test score 67%&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A, B, K):
    # write your code in Python 2.7
    ret = 0
    if A%K == 0:
        ret += 1
    if A != B and B%K == 0 :
        ret += 1

    if (B-A)%K == 0:
        if ret == 2:
            ret += ((B-A)/K - 1)
        else:
            ret += (B-A)/K
    else:
        ret += (B-A)/K
    return ret
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;countdiv-solution-2&#34;&gt;CountDiv solution 2&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A, B, K):
    # write your code in Python 2.7
    ret = 0
    ra = -1 if A == 0 else (A - 1)/K
    rb = B/K

    return rb -ra

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution-3&#34;&gt;solution 3&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A, B, K):
    # write your code in Python 2.7
    c = 1 if A%K == 0 else 0
    return B/K -A/K + c

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.5.3&#34;&gt;
3. GenomicRangeQuery
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Find the minimal nucleotide from a range of sequence DNA.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;解法一-1&#34;&gt;解法一：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Test score  37%&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def getMinFactor(S,l,i,j):
    if j == (l-1):
        tmp = set(S[i:-1])  # error ，should be s[i:]
    else:
        tmp = set(S[i:(j+1)])
    if &#39;A&#39; in tmp:
        return 1
    elif &#39;C&#39; in tmp:
        return 2
    elif &#39;G&#39; in tmp:
        return 3
    else:
        return 4

def solution(S, P, Q):
    # write your code in Python 2.7
    length = len(S)
    result = []
    for x,y in zip(P,Q):
        #print x,y
        result.append(getMinFactor(S,length,x,y))
    return result
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;解法二-1&#34;&gt;解法二：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%
&amp;gt; used each list to save that states whether has element or not&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def calcPrefixSum(s,l):
    category_a, category_c, category_g = [0]*(l+1), [0]*(l+1), [0]*(l+1)
    for i in xrange(l):
        a,c,g = 0,0,0
        if s[i] == &#39;A&#39;:
            a = 1
        elif s[i] == &#39;C&#39;:
            c = 1
        elif s[i] == &#39;G&#39;:
            g = 1
        category_a[i+1] += category_a[i] + a
        category_c[i+1] += category_c[i] + c
        category_g[i+1] += category_g[i] + g

    return category_a, category_c, category_g

def solution(S, P, Q):
    # write your code in Python 2.7

    length = len(S)
    result = []
    a, c, g =  calcPrefixSum(S,length)
    for x,y in zip(P,Q):
        #print x,y
        #result.append(getMinFactor(S,length,x,y))
        if a[y+1] - a[x] &amp;gt; 0:
            result.append(1)
        elif c[y+1] - c[x] &amp;gt; 0:
            result.append(2)
        elif g[y+1] - g[x] &amp;gt; 0:
            result.append(3)
        else:
            result.append(4)

    return result
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.5.4&#34;&gt;
4. MinAvgTwoSlice
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Find the minimal average of any slice containing at least two elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt; transfer to 2/3&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    length = len(A)
    minStartPos = 0
    minSum = (A[0] + A[1])/2.0

    for i in xrange(length - 2):
        tmp = (A[i] + A[i+1])/2.0
        if tmp &amp;lt; minSum:
            minSum = tmp
            minStartPos = i
        tmp = (tmp*2 + A[i+2])/3.0
        if tmp &amp;lt; minSum:
            minSum = tmp
            minStartPos = i
    if (A[-1] + A[-2])/2.0 &amp;lt; minSum:
        minStartPos = length - 2

    return minStartPos
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id = &#34;1.6&#34;&gt;
lesson 6: &lt;i&gt;sorting&lt;/i&gt;
&lt;/h2&gt;

&lt;h3 id = &#34;1.6.1&#34;&gt;
1. Distinct
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Compute number of distinct values in an array.
- Test score 100%&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    Aset = set(A)
    return len(Aset)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.6.2&#34;&gt;
2. MaxProductOfThree
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Maximize A[P] * A[Q] * A[R] for any triplet (P, Q, R).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;solution-1&#34;&gt;solution 1&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;O(N)&lt;/li&gt;
&lt;li&gt;Test score  100% OJ test is O(N * log(N))&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    ma1, ma2, ma3 = -1000, -1000, -1000
    mi1, mi2 = 1000, 1000
    for elem in A:
        if elem &amp;gt; ma1:
            ma1, ma2, ma3 = elem, ma1, ma2
        elif elem &amp;gt; ma2:
            ma2, ma3 = elem, ma2
        elif elem &amp;gt; ma3:
            ma3 = elem

        if elem &amp;lt; mi1:
            mi1,mi2 = elem, mi1
        elif elem &amp;lt; mi2:
            mi2 = elem
    a, b = ma1*ma2*ma3, ma1*mi1*mi2
    return a if a &amp;gt; b else b
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution-2&#34;&gt;solution 2&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;just need return the value of the max product,&lt;/li&gt;

&lt;li&gt;&lt;p&gt;so, we can just consider the first or last teiplet, after sort&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Detected time complexity: O(N * log(N))&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    A.sort()
    return max(A[0]*A[1]*A[-1], A[-1]*A[-2]*A[-3])

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.6.3&#34;&gt;
3. Triangle
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Determine whether a triangle can be built from a given set of edges.
&lt;a href=&#34;https://codesays.com/2014/solution-to-triangle-by-codility/&#34;&gt;https://codesays.com/2014/solution-to-triangle-by-codility/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;def solution(A):
    # write your code in Python 2.7
    length = len(A)
    if length &amp;lt; 3:
        return 0
    A.sort()
    for idx in xrange(0,length -2):
        if A[idx]+A[idx + 1] &amp;gt; A[idx + 2]:
            return 1
    return 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id = &#34;1.7&#34;&gt;
lesson 7: &lt;i&gt;stacks and queues&lt;/i&gt;
&lt;/h2&gt;

&lt;h3 id = &#34;1.7.2&#34;&gt;
2. Nesting
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Determine whether given string of parentheses is properly nested.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(S):
    # write your code in Python 2.7
    tmp = 0
    for elem in S:
        if elem == &amp;quot;(&amp;quot;:
            tmp += 1
        elif elem == &amp;quot;)&amp;quot;:
            tmp -= 1
            if tmp &amp;lt; 0:
                return 0
    if tmp == 0:
        return 1
    else:
        return 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id = &#34;1.7.4&#34;&gt;
4. StoneWall
&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Cover &amp;laquo;Manhattan skyline&amp;raquo; using the minimum number of rectangles.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Test score 100%&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def solution(H):
    # write your code in Python 2.7
    cnt = 0
    stack = []
    for elem in H:
        while len(stack)!= 0 and stack[-1] &amp;gt; elem:
            stack.pop()

        if len(stack) != 0 and stack[-1] == elem:
            pass
        else:
            stack.append(elem)
            cnt += 1
    return cnt

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>