<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Life on Well</title>
    <link>https://tmhm.github.io/tags/life/</link>
    <description>Recent content in Life on Well</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>wells217@163.com (Well)</managingEditor>
    <webMaster>wells217@163.com (Well)</webMaster>
    <copyright>(c) 2017 Well.</copyright>
    <lastBuildDate>Wed, 15 Mar 2017 16:38:20 +0800</lastBuildDate>
    <atom:link href="https://tmhm.github.io/tags/life/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>一语未尽</title>
      <link>https://tmhm.github.io/2017/03/15/%E4%B8%80%E8%AF%AD%E6%9C%AA%E5%B0%BD/</link>
      <pubDate>Wed, 15 Mar 2017 16:38:20 +0800</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2017/03/15/%E4%B8%80%E8%AF%AD%E6%9C%AA%E5%B0%BD/</guid>
      <description>&lt;p&gt;&lt;em&gt;某些言语，让人若有所思。&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;传奇故事有千万种，但却如此相似。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;&amp;ndash;How Google work&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;幸福的家庭都是相似的，不幸的家庭各有各的不幸。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;&amp;ndash;安娜·卡列尼娜&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>读《微软的梦工厂》</title>
      <link>https://tmhm.github.io/2016/11/30/%E8%AF%BB%E5%BE%AE%E8%BD%AF%E7%9A%84%E6%A2%A6%E5%B7%A5%E5%8E%82/</link>
      <pubDate>Wed, 30 Nov 2016 07:25:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/11/30/%E8%AF%BB%E5%BE%AE%E8%BD%AF%E7%9A%84%E6%A2%A6%E5%B7%A5%E5%8E%82/</guid>
      <description>&lt;p&gt;前段时间看了扎克伯格和李叔同的传记，最近在看《&lt;span style=&#34;font-family: 隶书;&#34;&gt;微软的梦工厂&lt;/span&gt;》。
&lt;p&gt;看的过程总是会让我想起一些人，想起一些事情。。。&lt;/p&gt;
&lt;p&gt;文字在我的嘴里总是略带苦涩：&lt;/p&gt;
&lt;p&gt;也许这就是环境的影响，MSRA从一开始，就塑造了一个优秀的环境。&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;同时也让我看到自己的渺小，其实曾经我总是会把自己看成&amp;ldquo;全能&amp;rdquo;的，一直活在自己的小世界里，突然不断地让我接触了越来越大的世界，这也是我总是爱多想的次因。&lt;/p&gt;

&lt;p&gt;还有原因是，不愿接受过去的自己，不愿接受依次放大的阶梯，其实我也是在不断成长中，知足，&lt;/p&gt;
&lt;p&gt;沉淀，时间需要沉淀，成长更需要沉淀。&lt;/p&gt;
&lt;p&gt;我总是希望急于求成，希望一下就能学会所有，做到所有，&lt;/p&gt;
&lt;p&gt;做人得符合实际，不急不躁，踏实。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>语录收集</title>
      <link>https://tmhm.github.io/2016/11/18/%E8%AF%AD%E5%BD%95%E6%94%B6%E9%9B%86/</link>
      <pubDate>Fri, 18 Nov 2016 08:43:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/11/18/%E8%AF%AD%E5%BD%95%E6%94%B6%E9%9B%86/</guid>
      <description>&lt;p&gt;马化腾，第三次互联网大会
&amp;gt; 创新一定是所有公司都重视的，一定要有突破。腾讯过去再有优势，但在新趋势面前也有压力，微信之后，我们也在思考，未来三年还能做什么？回头看，创新不是搞一个部门，名字叫创新。而是把为用户服务的意识灌输到每一个产品和设计上，不要让员工掉入KPI陷阱。在快速服务用户过程中，用户抱怨，那就是你创新的机会。&lt;/p&gt;

&lt;p&gt;真格基金 王强老师推荐的三本书&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pic.36krcnd.com/201611/17092410/2y1m00k6ocjkz47h!1200&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;沃尔玛的创始人Sam Walton的自传《Made in America》&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pic.36krcnd.com/201611/17093654/8314vcwe06vx4kco!1200&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If Aristotle Ran General Motors《如果亚里士多德来管理通用汽车》&lt;/p&gt;

&lt;p&gt;真，善，美&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pic.36krcnd.com/201611/17094055/wylsehjibfs4wqjt!1200&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;PourYour Heart Into It: How Starbucks Built a Company One Cup at aTime 《将心注入-星巴克传奇》&lt;/p&gt;

&lt;p&gt;星巴克创始人霍华德·舒尔茨（Howard Schultz）的自传。&lt;/p&gt;

&lt;p&gt;Pour your heart into a cup of coffee。“把心倾注进一杯小小的咖啡里”。成功之树的全部秘诀正是在这颗初心的种子里。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>一些书单</title>
      <link>https://tmhm.github.io/2016/10/10/%E4%B8%80%E4%BA%9B%E4%B9%A6%E5%8D%95/</link>
      <pubDate>Mon, 10 Oct 2016 08:40:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/10/10/%E4%B8%80%E4%BA%9B%E4%B9%A6%E5%8D%95/</guid>
      <description>&lt;p&gt;&lt;em&gt;仅对近来的学习做些回顾吧&lt;/em&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;学习永无止境&amp;ndash;&amp;gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2015年已完成书单：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文学：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;硅谷之火&lt;/li&gt;
&lt;li&gt;浪潮之巅&lt;/li&gt;
&lt;li&gt;天才在左疯子在右&lt;/li&gt;
&lt;li&gt;从0到1&lt;/li&gt;
&lt;li&gt;生命咖啡馆&lt;/li&gt;
&lt;li&gt;黑客与画家&lt;/li&gt;
&lt;li&gt;奇思妙想：15位计算机天才及其重大发现&lt;/li&gt;
&lt;li&gt;乔布斯传&lt;/li&gt;
&lt;li&gt;平凡的世界（三部全）&lt;/li&gt;
&lt;li&gt;一只iphone的全球旅行&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&amp;nbsp;专业类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;C++ Primer（中文第五版）匆忙过了一遍，未实现代码。&lt;/li&gt;
&lt;li&gt;ios 游戏开发：创意与实现&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;2016年书单：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文学：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;历史的教训&lt;/li&gt;
&lt;li&gt;硅谷之谜&lt;/li&gt;
&lt;li&gt;文明之光&lt;/li&gt;
&lt;li&gt;facebook 马克 扎克伯格传记：后乔布斯时代的传奇&lt;/li&gt;
&lt;li&gt;弘一大师新传&lt;/li&gt;
&lt;li&gt;三体（未完成，过半后，吸引力下降）&lt;/li&gt;
&lt;li&gt;微软的梦工厂（一口气读完了）&lt;/li&gt;
&lt;li&gt;数学之美（第二版）&lt;/li&gt;
&lt;li&gt;富爸爸穷爸爸&lt;/li&gt;
&lt;li&gt;人类简史&lt;/li&gt;
&lt;li&gt;智能时代（吴军著）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;专业类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;C++语言的设计与演化&lt;/li&gt;
&lt;li&gt;数据结构与算法分析（C语言描述） &amp;nbsp; &amp;nbsp;缺代码实现&lt;/li&gt;
&lt;li&gt;统计学习方法. 李航&lt;/li&gt;
&lt;li&gt;控制系统设计指南（第三版）&lt;/li&gt;
&lt;li&gt;嵌入式Linux系统使用开发（主要包括完成linux系统，c/c++的回顾，多线程等）&lt;/li&gt;
&lt;li&gt;机器学习实践（-ing）&lt;/li&gt;
&lt;li&gt;机器学习.周志华（-ing）&lt;/li&gt;
&lt;li&gt;算法（第四版）. Robert Sedgewick（-ing，看进去以后，相见恨晚）&lt;/li&gt;
&lt;li&gt;Reinforcement learning: An&amp;nbsp;induction.&amp;nbsp;Richard S. Sutton（-ing）&lt;/li&gt;
&lt;li&gt;无人驾驶车辆模型预测控制.北京理工大学出版社（-ing）（发现战线好长，得收敛到某个方向）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;16年的专业书籍还有很多在继续。。&lt;/p&gt;

&lt;p&gt;&lt;p&gt;&lt;strong&gt;&amp;nbsp;2017年书单：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Google 未来之镜&lt;/li&gt;
&lt;li&gt;写给大家看的设计书（第四版）&lt;/li&gt;
&lt;li&gt;创新者的窘境 （-ing）&lt;/li&gt;
&lt;li&gt;围城（-ing）&lt;/li&gt;
&lt;li&gt;重新定义团队：谷歌如何工作（-ing）&lt;/li&gt;
&lt;/ol&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>求解路由路径问题（华为挑战赛小思）</title>
      <link>https://tmhm.github.io/2016/04/11/%E6%B1%82%E8%A7%A3%E8%B7%AF%E7%94%B1%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E5%8D%8E%E4%B8%BA%E6%8C%91%E6%88%98%E8%B5%9B%E5%B0%8F%E6%80%9D/</link>
      <pubDate>Mon, 11 Apr 2016 13:47:00 +0000</pubDate>
      <author>wells217@163.com (Well)</author>
      <guid>https://tmhm.github.io/2016/04/11/%E6%B1%82%E8%A7%A3%E8%B7%AF%E7%94%B1%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E5%8D%8E%E4%B8%BA%E6%8C%91%E6%88%98%E8%B5%9B%E5%B0%8F%E6%80%9D/</guid>
      <description>&lt;nav&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#问题定义&#34;&gt;问题定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#说明&#34;&gt;说明：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#最终得分机制&#34;&gt;最终得分机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#思&#34;&gt;思：&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#初衷&#34;&gt;初衷：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#于是-开始慢慢地折腾和实现了&#34;&gt;于是，开始慢慢地折腾和实现了 :-)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#算法描述&#34;&gt;算法描述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#缺陷-反思&#34;&gt;缺陷-反思&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/nav&gt;

&lt;p&gt;赛题源自“未来网络”业务发放中的路由计算问题。&lt;/p&gt;

&lt;h6 id=&#34;问题定义&#34;&gt;问题定义&lt;/h6&gt;

&lt;p&gt;给定一个带权重的有向图G=(V,E)，V为顶点集，E为有向边集，每一条有向边均有一个权重。对于给定的顶点s、t，以及V的子集V&amp;rsquo;，寻找从s到t的不成环有向路径P，使得P经过V&amp;rsquo;中所有的顶点(对经过V&amp;rsquo;中节点的顺序不做要求)。
若不存在这样的有向路径P，则输出无解，程序运行时间越短，则视为结果越优；若存在这样的有向路径P，则输出所得到的路径，路径的权重越小，则视为结果越优，在输出路径权重一样的前提下，程序运行时间越短，则视为结果越优。&lt;/p&gt;

&lt;h6 id=&#34;说明&#34;&gt;说明：&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;1）图中所有权重均为[1，20]内的整数；&lt;/li&gt;
&lt;li&gt;2）任一有向边的起点不等于终点；&lt;/li&gt;
&lt;li&gt;3）连接顶点A至顶点B的有向边可能超过一条，其权重可能一样，也可能不一样；&lt;/li&gt;
&lt;li&gt;4）该有向图的顶点不会超过600个，每个顶点出度(以该点为起点的有向边的数量)不超过8；&lt;/li&gt;
&lt;li&gt;5）V&amp;rsquo;中元素个数不超过50；&lt;/li&gt;
&lt;li&gt;6）从s到t的不成环有向路径P是指，P为由一系列有向边组成的从s至t的有向连通路径，且不允许重复经过任一节点；&lt;/li&gt;

&lt;li&gt;&lt;p&gt;7）路径的权重是指所有组成该路径的所有有向边的权重之和。&lt;/p&gt;

&lt;h6 id=&#34;最终得分机制&#34;&gt;最终得分机制&lt;/h6&gt;

&lt;p&gt;华为后台会使用N个测试用例判题，该N个测试用例分为初级、中级、高级三个等级，参赛者对于每个测试用例都会得到一个百分制分数，使用加权平均分(初级权重为0.2，中级权重为0.3，高级权重为0.5)作为该参赛者的最终得分。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;输入输出采用文件的形式。&lt;/p&gt;

&lt;h5 id=&#34;思&#34;&gt;思：&lt;/h5&gt;

&lt;p&gt;对于上述，这么一个问题，
最初的想法是根据dijkstra最短路径算法中贪心的思想，结合剪枝进行求解，但是对于复杂图节点的情况，主要是在于当必经节点变多，这个规则感觉就太多，没法继续下去。&lt;/p&gt;

&lt;p&gt;然后，接触到蚁群算法。
我从旅行商问题（TSP）开始学习这个算法，但是对于我们这个要求经过给定必经点的问题，跟TSP还是有比较大的差距。
TSP问题得以求解的核心思想在于：
&lt;em&gt;每只蚂蚁经过所有的节点，蚂蚁行走相对于cpu总的频率是一样的，当路径越短，其蚂蚁行走的次数就会增大&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;然后，突然有了一个这样类蚂蚁的想法，接下来就是围绕这个想法在实现了。
此处，仅仅是自己的一个思路的回顾，可能会存在一些问题。仅供讨论。&lt;/p&gt;

&lt;h6 id=&#34;初衷&#34;&gt;初衷：&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;将所有蚂蚁丢在 起点和必经点上，然后再让他们自己去走，走到另一必经点，其信息素增大， 如果走到终点，信息素更大，直到某只蚂蚁找到终点。每次信息素更新时，信息素更新量的大小跟该蚂蚁走过的node数量和是否经过必经点有关。 这样来，理想情况下，每次更新时，经过必经点的路径信息素应该是比较大的，每次更新信息素后，进行一次从起点开始贪心搜，每次走信息素最大的，看是否可以走到终点，如果走到终点，本次路径即是一个解。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;因为，我们蚂蚁在每个节点，可供选择的节点是很少的， 最多才8个，而tsp问题是可以去任意个节点的 ，这样更新一遍信息素，就可以去类贪心一次，看是否可以找到解。&lt;/strong&gt;&lt;/p&gt;

&lt;h6 id=&#34;于是-开始慢慢地折腾和实现了&#34;&gt;于是，开始慢慢地折腾和实现了 :-)&lt;/h6&gt;

&lt;p&gt;####### 类邻接表的图表结构&lt;/p&gt;

&lt;p&gt;头结点表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    struct AlGraph{
EdgeNode *adjacencyNode[8];  //
AlGraph *algacency_alGraph[8];  //point to the adjacencyNode struct !!!
short int edgecnt;   // the num of node link to this head node
short int vertexNum;
long distToSource;    // distance from start to this node  ,default = 0;
                        // due to the pre cost among [1:20]
bool known;         // degault = false,  become to true when parse it.
short int path;    //default = -1  // due to the pre node value among [0:600], yes , are node
/*这样的缺点是,不能同时找多条路径,一个点只能记录一个它的path,一个node有多个入度的时候,就会出问题了!
    此path成员只在dijkstra里面用，到后面类蚁群算法并没有用，它通过每只蚂蚁走过的路径来体现*/
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;边节点，它也可能是一个头结点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    struct EdgeNode   //边表节点
    {
       short int adjvex;  //bian jiedian hao
       short int cost;   //cost
       short int linkID;  //the edge id :  point to this node

       /** ant  */
       float pheromone; //
       //short int pheromone_delta;  //改写到蚂蚁身上
       long long nth_antPathVisited;  //nth bits;   all 64  ,实际上只是用来确定该蚂蚁走过这条边, 这样可以尝试走通往该节点的多条边.
       /**
       * 1111 ... ... 1111
       *64,63,... , 3,2,1 nth ant
       **/
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;必经节点结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    struct demandIncNode{
        short int demandID;
        bool gotStatus;
    };
    struct demandNode{
        short int source_id;
        short int destination_id;
        bool reachEndFlag;
        short int includingCnt;
        demandIncNode *includingNode[50];
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;蚂蚁结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    struct sAnt{
        long int ant_pheromone_Q;   // the gross about pheromone of each ant need to different!
        float pheromone_delta ;

        long l_pathMoved_length ;         //the all length of this ant moved from &amp;lt;their&amp;gt; source!!
        short int CommonNode_movedCount ;         //the number of node had moved
        short int DemandNode_movedCount;    //the number of demand node had moved
        short int cakeOnFront ;

        //float prob[8];    // to my own choose
        float  prob[8];              //the temp for calculate probability to choose
        short int curCandidacyNodeNum; //the number of node can be select to move
        short int passedNodeId;//
        short int curNodeId;  //the node now
        short int nextNodeId; // select node
        short int antStartId;

        bool antDie_status;  // this ant may little value
        bool gotDestination;    //pass some demandNode and got destination.
        bool gotDestFromMidway;
        short int timeCnt;  //let this ant stop ,or they run how much

    };

    struct sAntResult{
        short int toNode;
        short int linkId;
       // sAntResult *next;
       // sAntResult *pre;
        //sAntResult(short int n, short int id) : toNode(n) ,linkId(id) {}
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了方便查找索引，建立了一个头结点索引数组，来存储已经读入头结点的值，来防止访问第一个图表，出现野指针的情况。当需要查找某个头结点的相关信息时，先在头结点数组确认存在后， 再去图*graph[600]里面直接按头结点id值等于图索引号获取。&lt;/p&gt;

&lt;h6 id=&#34;算法描述&#34;&gt;算法描述&lt;/h6&gt;

&lt;ol&gt;
&lt;li&gt;将图文件中的节点读进来，按照上面的图表格式存储，然后将有出度的头结点用指针联系起来，方便后面的访问。&lt;/li&gt;
&lt;li&gt;根据demand节点的个数，初始化蚂蚁的个数，并置位ant相关数据。选择每一只蚂蚁第一次的初始位置（起点+所有必经点+随机的非终点）。&lt;/li&gt;
&lt;li&gt;开始进入ant_run的主程序
    1. 将记录蚂蚁经过的路径信息复位；
    2. 让每个蚂蚁run，直到终点，或者没法继续；
            1. 根据当前节点和上一步访问的节点情况，计算本节点出度节点各自的概率，用轮盘选择下一个出度节点（避免一些可推倒的不行解）
            2. 每步记录蚂蚁获得的一些报酬（跟必经点，普通节点，终点，前方有蛋糕的概率等有关），当该蚂蚁停下来时，计算其身上有的信息总量
            3. 待所有蚂蚁都跑完一代，更新他们的信息素到各自走过的路经上
    3. check每只蚂蚁的信息素，并计算各自的增量，叠加到路径的信息素上去；
    4. check本次迭代是否找到解：
            1. 找到一个解（暂时只考虑了一代中多种可行解的优化，和初步环避免）存到一个队列中，返回
            2. 没有找到完整的解，记录返回调试用。目前的路径上的信息素可能有问题，将当次不完整解走过的路径上的信息素，用台风吹吹:-)
    5. 清掉本次迭代图上和ant的各种状态标识等
    6. 直到迭代次数，结束&lt;/li&gt;
&lt;li&gt;善后工作，写结果文件，以及调试打印输出等&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;上述为程序的主要框架，均按照自己某时想法，一步步累积起来的，更多细节部分细节处理&lt;/strong&gt;
相比蚁群算法的核心收敛机制在于cpu的频率，上述方法应该收敛的条件是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;经过更多的必经点，蚂蚁报酬更多，从起点达到终点，经过所有必经点，报酬甚之(理想解);&lt;/li&gt;
&lt;li&gt;可能上一点不完备，有某些问题；&lt;/li&gt;
&lt;li&gt;结合了强化学习正反馈的报酬机制。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;缺陷-反思&#34;&gt;缺陷-反思&lt;/h6&gt;

&lt;p&gt;缺少完备的理论证明。 并没有证明求解空间在这些规则下，是完备的，并且会收敛到最优(目前来看，收敛性不太好)。
因此，实践起来，发现并不如我心意。
需要在一些规则的限制下才能得到较简单问题的解，目前只能得到case0和case1的解，偶尔会出现次优解。因为，我只在一个地方优化了解&lt;em&gt;一次迭代中，当出现多个解得时候，即有多只蚂蚁同时获得解，才会去优化次优的信息素&lt;/em&gt;
所以当代与代之间有时不收敛的时候就只能通过其他的规则才能得到解，我一直在想，这个问题，估计我还有某些方面没考虑到，是不完备的解，所以导致不收敛。理论基础好生重要！&lt;/p&gt;

&lt;p&gt;软件系统规划仍比较薄弱。 没有学过程序设计模式和架构，都是按照自己的一些想法实现的，当遇到问题的时候，再在这上面添加补充和完善。一开始没有很好的布局式设计，如果一开始能把所有的想明白了，做好整体框架，程序的结构性就会好一些。耦合程度也会低一些。当然在实现的过程中，我也尽量使相关性程度比较高的在一起，为了以后更好地维护。&lt;/p&gt;

&lt;p&gt;整个工程的总共时间不长，应该算是我认真做过的项目中最短的了，两个隔离的周末（4天）加基本一周（6天），总共十天（满满的），包括了所有的构思和编码。总共编码在1700行左右，后期并未优化，想想，曾经一个五子棋也写了5000行，当时写dos下的界面花了不少行，当时的AI做的还挺好的，放在班群上也能得到很好的胜率。（当时也实现了自己的一个小想法，不但考虑自己胜算大小，还考虑了对方的，还有梯度的思想，哈哈~）&lt;/p&gt;

&lt;p&gt;此处仅当做学习的一个总结，全是自己一行一行码的代码，勿拍砖，不足之处敬请指正与讨论。：-)&lt;/p&gt;

&lt;p&gt;其实当每一次认真地做一个project，只要能单纯实现自己的一些想法，也是一件很美妙的事情，目前来看，至少也有6个这样的项目了吧
- 第一块电路板和自制电源
- 独角兽&amp;lt;一代,历时半年多，收货也大大&amp;gt;
- 倒立摆&amp;lt;惊喜之作&amp;gt;
- 四轴&amp;lt;历时也整整半年多，但不太尽人意&amp;gt;
- 五子棋&amp;lt;琢磨&amp;gt;
- 此次也算吧&lt;/p&gt;

&lt;p&gt;&amp;lt;感受码代码过程中的&amp;mdash;-那份喜悦与微妙&amp;gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;独角兽，幸运；更需要实力
2016.4.11晚&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>